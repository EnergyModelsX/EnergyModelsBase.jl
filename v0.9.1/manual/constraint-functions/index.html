<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraint functions ¬∑ EnergyModelsBase</title><meta name="title" content="Constraint functions ¬∑ EnergyModelsBase"/><meta property="og:title" content="Constraint functions ¬∑ EnergyModelsBase"/><meta property="twitter:title" content="Constraint functions ¬∑ EnergyModelsBase"/><meta name="description" content="Documentation for EnergyModelsBase."/><meta property="og:description" content="Documentation for EnergyModelsBase."/><meta property="twitter:description" content="Documentation for EnergyModelsBase."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">EnergyModelsBase</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quick-start/">Quick Start</a></li><li><a class="tocitem" href="../philosophy/">Philosophy</a></li><li><a class="tocitem" href="../optimization-variables/">Optimization variables</a></li><li class="is-active"><a class="tocitem" href>Constraint functions</a><ul class="internal"><li><a class="tocitem" href="#man-con-cap"><span>Capacity constraints</span></a></li><li><a class="tocitem" href="#man-con-flow"><span>Flow constraints</span></a></li><li><a class="tocitem" href="#man-con-stor_level"><span>Storage level constraints</span></a></li><li><a class="tocitem" href="#man-con-opex"><span>Operational expenditure constraints</span></a></li></ul></li><li><a class="tocitem" href="../data-functions/">ExtensionData functions</a></li><li><a class="tocitem" href="../simple-example/">Example</a></li><li><a class="tocitem" href="../investments/">Investment options</a></li><li><a class="tocitem" href="../NEWS/">Release notes</a></li></ul></li><li><span class="tocitem">Nodes</span><ul><li><a class="tocitem" href="../../nodes/source/">Source</a></li><li><a class="tocitem" href="../../nodes/networknode/">NetworkNode</a></li><li><a class="tocitem" href="../../nodes/storage/">Storage</a></li><li><a class="tocitem" href="../../nodes/sink/">Sink</a></li><li><a class="tocitem" href="../../nodes/availability/">Availability</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../how-to/create_new_element/">Create a new element</a></li><li><a class="tocitem" href="../../how-to/create-new-node/">Create a new node</a></li><li><a class="tocitem" href="../../how-to/utilize-timestruct/">Utilize TimeStruct</a></li><li><a class="tocitem" href="../../how-to/update-models/">Update models</a></li><li><a class="tocitem" href="../../how-to/contribute/">Contribute to EnergyModelsBase</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/public/resources/">Resources</a></li><li><a class="tocitem" href="../../library/public/model_data/">Modeltype and ExtensionData</a></li><li><a class="tocitem" href="../../library/public/nodes/">Nodes</a></li><li><a class="tocitem" href="../../library/public/links/">Links</a></li><li><a class="tocitem" href="../../library/public/case_element/">Case</a></li><li><a class="tocitem" href="../../library/public/functions/">Functions</a></li><li><a class="tocitem" href="../../library/public/misc/">Miscellaneous</a></li><li><a class="tocitem" href="../../library/public/emi_extension/">EMI extension</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Internal</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/internals/types/">Types</a></li><li><a class="tocitem" href="../../library/internals/functions/">Functions</a></li><li><a class="tocitem" href="../../library/internals/reference_EMIExt/">EMI extension</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Constraint functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constraint functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/EnergyModelsX/EnergyModelsBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/EnergyModelsX/EnergyModelsBase.jl/blob/main/docs/src/manual/constraint-functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-con"><a class="docs-heading-anchor" href="#man-con">Constraint functions</a><a id="man-con-1"></a><a class="docs-heading-anchor-permalink" href="#man-con" title="Permalink"></a></h1><p>The package provides standard constraint functions that can be used for new developed nodes. These standard constraint functions are used exclusively in all <code>create_node(m, n, ùíØ, ùí´, modeltype)</code> functions. They allow for both removing repititions of code as well as dispatching only on certain aspects. The majority of the constraint functions are created for the <code>abstract type</code> of the <code>Node</code> dispatching, that is, the supertypes described in <em><a href="../philosophy/#man-phil-nodes">Description of Technologies</a></em>. If a constraint function is not using the <code>abstract type</code> for dispatching, a warning is shown in this manual.</p><h2 id="man-con-cap"><a class="docs-heading-anchor" href="#man-con-cap">Capacity constraints</a><a id="man-con-cap-1"></a><a class="docs-heading-anchor-permalink" href="#man-con-cap" title="Permalink"></a></h2><p>Capacity constraints are constraints that limit both the capacity usage and installed capacity. The core function is given by</p><pre><code class="language-julia hljs">constraints_capacity(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)</code></pre><p>correponding to the constraint on the usage of the capacity of a technology node <span>$n$</span>. It is implemented for <code>Node</code>, <code>Storage</code>, and <code>Sink</code> types. The general implementation is limiting the capacity usage. That is, limiting the variable <span>$\texttt{cap\_use}[n, t]$</span> to the maximum installed capacity <span>$\texttt{cap\_inst}[n, t]$</span> (and correspondingly for both rate and level variables for storage). <code>Sink</code> nodes behave differently as we allow for both surplus (<span>$\texttt{sink\_surplus}[n, t]$</span>) and deficits (<span>$\texttt{sink\_deficit}[n, t]$</span>), as explained in <em><a href="../optimization-variables/#man-opt_var-sink"><code>Sink</code> variables</a></em>.</p><p>Within this function, the function</p><pre><code class="language-julia hljs">constraints_capacity_installed(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)</code></pre><p>is called to limit the variable <span>$\texttt{cap\_inst}$</span> (or <span>$\texttt{stor\_charge\_inst}$</span>, <span>$\texttt{stor\_level\_inst}$</span> and <span>$\texttt{stor\_discharge\_inst}$</span> for <code>Storage</code> nodes) of a technology node <span>$n$</span>. This functions is also used to subsequently dispatch on model type for the introduction of investments.</p><div class="admonition is-warning" id="Warning-8c51f8da0ea46218"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-8c51f8da0ea46218" title="Permalink"></a></header><div class="admonition-body"><p>As the function <code>constraints_capacity_installed</code> is used for including investments for nodes, it is important that it is also called when creating a new node. It is not possible to only add a function for</p><pre><code class="language-julia hljs">constraints_capacity_installed(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)</code></pre><p>without adding a function for</p><pre><code class="language-julia hljs">constraints_capacity_installed(m, n::Node, ùíØ::TimeStructure, modeltype::EMI.AbstractInvestmentModel)</code></pre><p>as this can lead to a method ambiguity error.</p></div></div><h2 id="man-con-flow"><a class="docs-heading-anchor" href="#man-con-flow">Flow constraints</a><a id="man-con-flow-1"></a><a class="docs-heading-anchor-permalink" href="#man-con-flow" title="Permalink"></a></h2><p>Flow constraints handle how the flow variables of a <code>Node</code> are connected to the internal variables. In <code>EnergyModelsBase</code>, we only consider capacity variables as internal variables. This can however be extended through the development of new <code>Node</code>s, if desired.</p><pre><code class="language-julia hljs">constraints_flow_in(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)</code></pre><p>corresponds to the constraints calculating the required inflow to a node <span>$n$</span> for a given capacity usage. It is implemented for <code>Node</code> (using <span>$\texttt{cap\_use}[n, t]$</span>) and <code>Storage</code> (using <span>$\texttt{stor\_rate\_use}[n, t]$</span>) types.</p><pre><code class="language-julia hljs">constraints_flow_out(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)</code></pre><p>corresponds to the constraints calculating the outflow of a node <span>$n$</span> for a given capacity usage. It is implemented for <code>Node</code> types using <span>$\texttt{cap\_use}[n, t]$</span> but not used for the <code>Storage</code> subtypes introduced in the model. The outflow of a <code>Storage</code> node is instead specified through the storage level balance.</p><h2 id="man-con-stor_level"><a class="docs-heading-anchor" href="#man-con-stor_level">Storage level constraints</a><a id="man-con-stor_level-1"></a><a class="docs-heading-anchor-permalink" href="#man-con-stor_level" title="Permalink"></a></h2><p>Storage level constraints are required to provide flexibility on how the level of a <code>Storage</code> node should be calculated depending on the chosen <a href="../../library/public/nodes/#lib-pub-nodes-stor_behav"><code>StorageBehavior</code></a>.</p><pre><code class="language-julia hljs">constraints_level(m, n::Storage, ùíØ, ùí´, modeltype::EnergyModel)</code></pre><p>corresponds to the main constraint for calculating the level balance of a <code>Storage</code> node. Within this constraint, two different functions are called:</p><pre><code class="language-julia hljs">constraints_level_aux(m, n::Storage, ùíØ, ùí´, modeltype::EnergyModel)</code></pre><p>and</p><pre><code class="language-julia hljs">constraints_level_iterate(m, n::Storage, prev_pers, cyclic_pers, t_inv, ts, modeltype::EnergyModel)</code></pre><p>The first function, <code>constraints_level_aux</code>, is used to calculate additional properties of a <code>Storage</code> node. These properties are independent of the chosen <code>TimeStructure</code>, but dependent on the stored <code>Resource</code> type and the storage type. General properties are the calculation of the change in storage level in an operational period, as described in <em><a href="../optimization-variables/#man-opt_var-cap">Capacity variables</a></em> as well as bounds on variables. It is implemented for a generic <code>Storage</code> node as well for a <code>RefStorage{AccumulatingEmissions}</code> node. Using the <code>AccumulatingEmissions</code> requires that the stored resource is a <code>ResourceEmit</code> and limits the variable <span>$\texttt{stor\_level\_}\Delta\texttt{\_op}[n, t, p] \geq 0$</span> as well as introduces emission variables.</p><p>The second function, <code>constraints_level_iterate</code>, iterates through the time structure and eventually declares the level balance of the <code>Storage</code> node within a strategic period. It automatically deduces the type of the time structure, <em>i.e.</em>, whether representative periods and/or operational scenarios are included, and subsequently calculates the corresponding previous period used in the level balance through calling the function <a href="../../library/public/functions/#EnergyModelsBase.previous_level"><code>previous_level</code></a>.</p><p><code>RepresentativePeriods</code> are handled through scaling of the change in the level in a representative period. This requires that the <code>RepresentativePeriods</code> are sequential.</p><p>The total function call structure is given by:</p><pre><code class="nohighlight hljs">constraints_level(m, n::Storage, ùíØ, ùí´, modeltype::EnergyModel)
‚îú‚îÄ constraints_level_aux(m, n, ùíØ, ùí´, modeltype::EnergyModel)
‚îî‚îÄ constraints_level_iterate(m, n, prev_pers, cyclic_pers, t_inv, ts::RepresentativePeriods, modeltype::EnergyModel)
   ‚îú‚îÄ constraints_level_rp(m, n, per, modeltype::EnergyModel)
   ‚îî‚îÄ constraints_level_iterate(m, n, prev_pers, cyclic_pers, t_inv, ts::OperationalScenarios, modeltype::EnergyModel)
      ‚îú‚îÄ constraints_level_scp(m, n, per, modeltype::EnergyModel)
      ‚îî‚îÄ constraints_level_iterate(m, n, prev_pers, cyclic_pers, t_inv, ts::SimpleTimes, modeltype::EnergyModel)
         ‚îú‚îÄ constraints_level_bounds(m, n, t, cyclic_pers, modeltype::EnergyModel)
         ‚îî‚îÄ previous_level(m, n, prev_pers, cyclic_pers, modeltype::EnergyModel)
            ‚îî‚îÄ previous_level_sp(m, n, cyclic_pers, modeltype::EnergyModel)</code></pre><p>Not all functions are called, as the framework automatically deduces the chosen time structure. Hence, if the time structure is given as <code>TwoLevel{SimpleTimes}</code>, all functions related to representative epriods and scenario periods are omitted.</p><div class="admonition is-success" id="Introducing-new-storage-behaviours-bcd3e71f8f81a091"><header class="admonition-header">Introducing new storage behaviours<a class="admonition-anchor" href="#Introducing-new-storage-behaviours-bcd3e71f8f81a091" title="Permalink"></a></header><div class="admonition-body"><p>If you want to introduce a new <em><a href="../../library/public/nodes/#lib-pub-nodes-stor_behav">storage behaviour</a></em>, it is best to dispatch on the following functions. It is not necessary to dispatch on all of the mentioned functions for all storage behaviours.</p><ol><li><code>constraints_level_rp(m, n, per, modeltype)</code> for inclusion of constraints on the variable <a href="../optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_level\_Œî\_rp}[n, t_{rp}]$</span></a>,</li><li><code>constraints_level_scp(m, n, per, modeltype)</code> for inclusion of constraints related to operational scenarios,</li><li><code>previous_level(m, n, prev_pers, cyclic_pers, modeltype)</code> for changing the behaviour of how previous storage levels should be calculated, and</li><li><code>previous_level_sp(m, n, cyclic_pers, modeltype)</code> for changing the behaviour of the first operational period (in the first representative period) within a strategic period.</li></ol><p>The exact implementation is not straight forward and care has to be taken if you want to dispatch on these functions to avoid method ambiguities. We plan on extending on the documentation on how you can best introduce new <em><a href="../../library/public/nodes/#lib-pub-nodes-stor_behav">storage behaviours</a></em> in a latter stage with an example.</p></div></div><h2 id="man-con-opex"><a class="docs-heading-anchor" href="#man-con-opex">Operational expenditure constraints</a><a id="man-con-opex-1"></a><a class="docs-heading-anchor-permalink" href="#man-con-opex" title="Permalink"></a></h2><p>Operational expenditure (OPEX) constraints calculate the contribution of operating a technology. The constraints are declared for both the fixed and variable OPEX.</p><pre><code class="language-julia hljs">constraints_opex_fixed(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)</code></pre><p>corresponds to the constraints calculating the fixed operational costs of a technology node <span>$n$</span>. It is implemented for <code>Node</code>, <code>Storage</code>, and <code>Sink</code> types. The fixed OPEX is in general dependent on the installed capacity.</p><p><code>EnergyModelsBase</code> provides a default approach for calculating the variable OPEX of <code>Storage</code> nodes to allow for variations in the individually chosen <em><a href="../../library/public/nodes/#lib-pub-nodes-stor_par">storage parameters</a></em>. Depending on the chosen storage parameters, the fixed OPEX can include the capacities for the charge (through the variable <a href="../optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_charge\_inst}[n, t]$</span></a>), storage level (through the variable <a href="../optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_level\_inst}[n, t]$</span></a>), and discharge (through the variable <a href="../optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_discharge\_inst}[n, t]$</span></a>) capacities. Note that the fixed OPEX can only be included if a storage parameter including a capacity is chosen.</p><p><code>Sink</code> nodes use the variable <a href="../optimization-variables/#man-opt_var-cap"><span>$\texttt{cap\_inst}$</span></a> for providing a demand. They do not have a capacity in their basic implementation. Hence, no fixed OPEX is calculated.</p><pre><code class="language-julia hljs">constraints_opex_var(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)</code></pre><p>corresponds to the constraints calculating the variable operational costs of a technology node <span>$n$</span>. It is implemented for <code>Node</code>, <code>Storage</code>, <code>RefStorage{T&lt;:ResourceEmit}</code>, and <code>Sink</code> types. The variable OPEX is in general dependent on the capacity usage.</p><p>As it is the case for the constraints for the fixed OPEX,  <code>EnergyModelsBase</code> provides a default approach for calculating the variable OPEX of <code>Storage</code> nodes to allow for variations in the individually chosen <em><a href="../../library/public/nodes/#lib-pub-nodes-stor_par">storage parameters</a></em>. Depending on the chosen storage parameters, the fixed OPEX can include values for charging (through the variable <a href="../optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_charge\_use}[n, t]$</span></a>), the storage level (through the variable <a href="../optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_level}[n, t]$</span></a>), and discharging (through the variable <a href="../optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_discharge\_use}[n, t]$</span></a>).</p><p>The variable OPEX calculations of <code>Sink</code> nodes include both the potential of a penalty for the surplus and deficit as described in <em><a href="../optimization-variables/#man-opt_var-sink"><code>Sink</code> variables</a></em>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization-variables/">¬´ Optimization variables</a><a class="docs-footer-nextpage" href="../data-functions/">ExtensionData functions ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Tuesday 24 June 2025 11:56">Tuesday 24 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
