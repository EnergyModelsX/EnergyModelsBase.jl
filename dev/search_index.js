var documenterSearchIndex = {"docs":
[{"location":"how-to/utilize-timestruct/#utilize_timestruct","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"EnergyModelsBase uses for the description of time the package TimeStruct. TimeStruct offers a large variety of different options that can appear to be overwhelming, when first exposed to them. Hence, it is important to highlight how it works and which parameters you would want to analyse.","category":"page"},{"location":"how-to/utilize-timestruct/#Structures-for-time-description","page":"Utilize TimeStruct.jl","title":"Structures for time description","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"TimeStruct introduces individual structures that are used for describing time. In the following introduction, the most important structures are explained. There are other structures, but these will be added once EnergyModelsbase supports their formulation.","category":"page"},{"location":"how-to/utilize-timestruct/#Operational-periods","page":"Utilize TimeStruct.jl","title":"Operational periods","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Operational periods correspond to periods in which no investments are allowed. In general, you can imagine operational periods to be the individual hours you want to model, although it is not limited to hours. In each operational period, we have an optimal dispatch problem given the constraints. Operational periods are normally implemented using the type SimpleTimes which has the following structure:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"op_duration = 1  # Each operational period has a duration of 1\nop_number = 24   # There are in total 24 operational periods\noperational_periods = SimpleTimes(op_number, op_duration)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"In above's example, we assume that we have in total 24 operational periods which have the same duration each, i.e., a duration of 1. The unit in itself is not important, but it can be either if you consider that a duration of 1 corresponds to one hour. In this case, the operational periods would correspond to a full day.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"note: Note\nAll operational periods are continuous. This implies that one is not allowed to have jumps in the representative periods. This affects all \"dynamic\" constraints, that is, constraints where the current operational period is dependent on the previous operational period. In EnergyModesBase, this is only the case for the level balance in RefStorage. Representative periods allow for jumps between operational periods, as outlined below.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Note that TimeStruct does not require that each operational period has the same length. Consider the following example:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"op_duration = [4, 2, 1, 1, 2, 4, 2, 1, 1, 2, 4]\nop_number = length(op_duration)\noperational_periods = SimpleTimes(op_number, op_duration)\n\n# output\nSimpleTimes{Int64}(11, [4, 2, 1, 1, 2, 4, 2, 1, 1, 2, 4])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"In this case, we model the day not with hourly resolution, but only have hourly resolution in the morning and afternoon. The night has a reduced time resolution of 4 hours. However, we still model a full 24 hours as can be seen by the command","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"duration(operational_periods)\n\n# output\n24","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"When having an Array as input to SimpleTimes, it is also not necessary to specify op_number. Instead, one can also write","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"operational_periods = SimpleTimes(op_duration)\n\n# output\nSimpleTimes{Int64}(11, [4, 2, 1, 1, 2, 4, 2, 1, 1, 2, 4])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"and a constructor will automatically deduce that there have to be 11 operational periods.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"SimpleTimes is also the lowest TimeStructure that is present in TimeStruct. It is used in all subsequent structures. When iterating over a TimeStructure, e.g., as t ∈ operational_periods, you obtain the single operational periods that are required for solving the optimal dispatch.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"warning: Warning\nEnergy conversion, production, or emissions of a node as well as all flows are always defined for a duration of length 1 in operational periods. You have to be careful when considering the output from the model. The same holds for capacities provided in the input file.","category":"page"},{"location":"how-to/utilize-timestruct/#ts_rp","page":"Utilize TimeStruct.jl","title":"Representative periods","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Representative periods are introduced through the structure RepresentativePeriods. Representative periods correspond to a repetition of different periods. This is a change from SimpleTimes in which a single period is scaled.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Consider the following example:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"day = SimpleTimes(24, 1)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"This example can represent a single day with hourly resolution. In pracice, when including the day into a TwoLevel, it is scaled multiple times. This can lead to an underestimation of storage requirements and makes it impossible to include seasonal storage.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Representative periods can be included through creating multiple instances of SimpleTimes. The following example creates two days with hourly resolution, one winter day and one summer day. These two days are the combined into a RepresentativePeriod with 2 periods. These two periods sum up to a duration of 8760, that is a year. Each representative period is scaled up 365/2=182.5 times.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"winter_day = SimpleTimes(24, 1)\nsummer_day = SimpleTimes(24, 1)\n\nperiods = 2                 # Number of representative periods\ntotal_duration = 8760       # Total duration\nshare = [0.5, 0.5]          # Share of the total duration of the representative periods\n\nrps = RepresentativePeriods(periods, total_duration, share, winter_day, summer_day)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Representative periods only affect the system if storage is included. In the case of storage, this scaling impacts the initial level of the storage in representative periods. Otherwise, the application of SimpleTimes suffices.","category":"page"},{"location":"how-to/utilize-timestruct/#Strategic-periods","page":"Utilize TimeStruct.jl","title":"Strategic periods","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Strategic periods are introduced through the structure TwoLevel. They correspond to the periods in which changes in capacity, efficiency, or operational expenditures can occur. The general structure is given by","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"day = SimpleTimes(24, 1)\nstrategic_duration = 5  # Each strategic period has a duration of 5\nstrategic_number = 5    # here are in total 5 strategic periods\nT = TwoLevel(strategic_number, strategic_duration, day)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"The example above corresponds to 5 strategic periods with a duration of 5 in each strategic period. Each strategic period includes 24 operational periods. One can choose any reference duration for a strategic period and the corresponding duration of an operational period. In above's example, there is no specified link between the duration of 1 of an operational period and a duration of 1 of a strategic period. TwoLevel assumes in this situation that the link is 1, that is both the strategic periods and the operational periods have the same duration.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"In general, it is easiest to use a duration of 1 of a strategic period to be equivalent to a single year while a duration of 1 of an operational period should correspond to 1 hour. In this case, we have to specifiy TwoLevel slightly differently:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"𝒯 = TwoLevel(strategic_number, strategic_duration, day; op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Note, that we used in this example the optional keyword argument op_per_strat which links the duration 1 of an operational period to the duration 1 of a strategic period. If we would like to have a duration of 1 in an operational period corresponding to an hour and a duration of 1 in a strategic period to a year, we need to use the value op_per_strat = 365*24 = 8760.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"warning: Warning\nIt is important to be certain which value one should use for op_per_strat. When using the wrong value, one obtains wrong operational results that may affect the analysis.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Similar to the SimpleTimes structure, it is possible to also have strategic periods of varying durations. In can be advantageous to, e.g., have a reduced duration in the initial investment periods, while having an increased duration in the latter. This would allow to reflect the higher uncertainty associated with future decisions and improve computational tractability by reducing model instance size.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"You can extract an iterator for the individual strategic periods by using the command:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"𝒯ᴵⁿᵛ = strategic_periods(𝒯)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"When iterating through 𝒯ᴵⁿᵛ, you obtain the individual strategic periods. When iterating through a strategic period, you obtain the individual operational periods:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"for t_inv ∈ 𝒯ᴵⁿᵛ, t ∈ t_inv end\n# is equivalent to\nfor t ∈ 𝒯 end","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"The advantage of approach 1 is that you can also use the indices of the strategic period. However, it may make the code look more complicated, when this is not required. It does not have any implication on the model building speed and it is up to the user, which approach to choose.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"warning: Warning\nFixed operational expenditures and emission limits provided to a model have to be provided for a duration of 1 in the strategic period.","category":"page"},{"location":"how-to/utilize-timestruct/#Summary","page":"Utilize TimeStruct.jl","title":"Summary","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"In the standard case, it is recommended to use hour as duration 1 of operational period and year as duration 1 of a strategic period. This still allows to utilize a higher resolution, like e.g. 15 minutes or less through specifying a duration of 0.25 for these operational periods, but it simplifies the overall design.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"day = SimpleTimes(24, 1)\nstrategic_duration = 5  # Each strategic period has a duration of 5\nstrategic_number = 5    # here are in total 5 strategic periods\n𝒯 = TwoLevel(strategic_number, strategic_duration, day; op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"This is especially relevant for capacities and emission limits, as well as anlysing the values obtained from the model.","category":"page"},{"location":"how-to/utilize-timestruct/#Profiles","page":"Utilize TimeStruct.jl","title":"Profiles","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Profiles are used for providing parameters to the model. There are in general three main profiles, that have to be considered:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"FixedProfile represents using the same value in all periods,\nOperationalProfile represents using the same profile in all strategic periods, although there can be variations in the individual strategic periods,\nRepresentativeProfile represents a profile that differes in the individual representative periods, and\nStrategicProfile represents using different values in the strategic periods.","category":"page"},{"location":"how-to/utilize-timestruct/#FixedProfile","page":"Utilize TimeStruct.jl","title":"FixedProfile","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"FixedProfile is the simplest profile. It represents a constant value over the whole modelling horizon. Its application is given by:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"profile = FixedProfile(10)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"This would provide a value of 10 in all operational periods in all strategic periods.","category":"page"},{"location":"how-to/utilize-timestruct/#OperationalProfile","page":"Utilize TimeStruct.jl","title":"OperationalProfile","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"OperationalProfile is used when there are operational variations. Consider the following example time structure, corresponding to 5 strategic periods, each with a duration of 5 years, and 24 operational periods, each with a duration of 24 hours.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"𝒯 = TwoLevel(5, 5, SimpleTimes(24, 1); op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"In this case, we would need to define an OperationalProfile as an array with length 24:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"op_profile = OperationalProfile(collect(1:1.0:24))","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"The example has a progressively increasing value going from 1 in the first hour to 24 in the last hour. collect is in this example required to obtain the value as array.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"OperationalProfile is normally used for varying demand or profiles for renewable power generation.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"warning: Warning\nIt is possible to have an OperationalProfile that is shorter or longer than the profile in the time structure. If the profile is shorter, then the last value is repeated. If the profile is longer, then the last values are ommitted. EnergyModelsBase provides the user with a warning if one of above's cases are presentIt is hence strongly advise to use an OperationalProfile with the same length.","category":"page"},{"location":"how-to/utilize-timestruct/#RepresentativeProfile","page":"Utilize TimeStruct.jl","title":"RepresentativeProfile","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"RepresentativeProfiles can be included in the case of RepresentativePeriods. Each profile in the structure corresponds to the respective representative period.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"Consider the following time structure,","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"winter_day = SimpleTimes(24, 1)\nsummer_day = SimpleTimes(24, 1)\nop = RepresentativePeriods(2, 8760, [0.5, 0.5], winter_day, summer_day)\n𝒯 = TwoLevel(5, 5, ; op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"in which two days with hourly resolution are scaled up 182.5 times each. The corresponding profiles then can look like the following:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"profile_winter = OperationalProfile(collect(range(1, stop=24, length=24)))\nprofile_summer = FixedProfile(0)\ndemand = RepresentativeProfile([profile_winter, profile_summer])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"This implies that we can use both OperationalProfile and FixedProfile combined. The only requirement is that if one is using Integer input, then the other also has to use Integer input.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"warning: Warning\nIt is possible to use RepresentativeProfile without RepresentativePeriods. In this case, the first provided profile is used.EnergyModelsBase provides the user with a warning if this is the case.","category":"page"},{"location":"how-to/utilize-timestruct/#StrategicProfile","page":"Utilize TimeStruct.jl","title":"StrategicProfile","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"StrategicProfile is used when there are strategic variations. Considering the same example time structure,","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"𝒯 = TwoLevel(5, 5, SimpleTimes(24, 1); op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"we can define a StrategicProfile as:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"strat_profile = StrategicProfile([1, 2, 3, 4, 5])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"In this case, we have variations between the strategic periods, but use the same value in all operational periods within a strategic period, that is all operational periods in strategic period 1 would use a value of 1, while the once in strategic period 2 a value of 2, and so on. This implementation is frequently used for changing capacities or efficiencies.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"It is also possible to have both variations on the strategic and operational level. A StrategicProfile then takes an Array of OperationalProfiles as input:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"op_profile_1 = OperationalProfile(rand(24))\nop_profile_2 = OperationalProfile(rand(24))\nop_profile_3 = OperationalProfile(rand(24))\nop_profile_4 = OperationalProfile(rand(24))\nop_profile_5 = OperationalProfile(rand(24))\nstrat_profile = StrategicProfile([op_profile_1, op_profile_2, op_profile_3, op_profile_4, op_profile_5])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"This approach is frequently used for demands where there are changes both on the operational level (e.g., hour) and strategic level (e.g., year).","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct.jl","title":"Utilize TimeStruct.jl","text":"It is similarly possible to include RepresentativeProfiles.","category":"page"},{"location":"manual/optimization-variables/#optimization_variables","page":"Optimization variables","title":"Optimization variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"EnergyModelsBase creates a variety of default variables for the individual nodes and edges. These default variables are in general also created when new Nodes or Links are developed. It is not necessary to utilize all of the default variables in the individual nodes. It is however recommended to include in this situation constraints or fixes using either the @constraint macro or alternatively the JuMP function fix(x, value). The latter is the recommended approach.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"note: Note\nThe majority of the variables in EnergyModelsBase are rate variables. This imples that they are calculated for either an operational period duration of 1, when indexed over operational period t or a strategic period duration of 1, when indexed over strategic period t_textttinv. Typical units for rates are MW for energy streams, tonne/hour for mass streams, tonne/year for strategic emissions, and €/year for operational expenditures. In this example, the duration of an operational period of 1 corresponds to an hour, while the duration of a strategic period of 1 corresponds to a year.Variables that are energy/mass based have that property highlighted in the documentation below. In the standard implementation of EnergyModelsBase, this is only the case for the level of a Storage node, the change of level of the node, and its installed capacity.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Rate variables can as well be translated to mass/energy variables. As an example, the total quantity that flows into a node n during the operational period t can found by","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"m[:flow_in][n, t, p] * duration(t)","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The multiplication then leads to an energy/mass quantity in stead of an energy/mass flow.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The coupling of strategic and operational periods can be achieved through the function EMB.multiple(t, t_inv). This functions allows for considering the scaling of the operational periods within a strategic period.","category":"page"},{"location":"manual/optimization-variables/#var_opex","page":"Optimization variables","title":"Operational cost variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Operational cost variables are included to account for operational expenditures (OPEX) of the model. These costs are pure dependent on either the use or the installed capacity of a node n. All nodes n (except Availability-nodes) have the following variables representing the operational costs of the nodes:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_varn t_textttinv: Variable OPEX of node n in strategic period t_textttinv.\ntextttopex_fixedn t_textttinv: Fixed OPEX of node n in strategic period t_textttinv.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The variable OPEX is a cost that derives from using a technology. It is calculated using the function constraints_opex_var. In general, it represents unmodelled feed to a process and the associated costs. Examples are catalyst replacement, cooling water or process water. The variable OPEX can also be utilized to provide values for a profit through using a technology.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The fixed OPEX is a cost that is independent of the usage of a technology. Instead, it is only dependent on the installed capacity. It is calculated using the function constraints_opex_fixed. It represents fixed costs like labour cost, maintenance, as well as insurances and taxes.","category":"page"},{"location":"manual/optimization-variables/#var_cap","page":"Optimization variables","title":"Capacity variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Capacity variables focus on both the capacity usage and installed capacity. The capacity variables are also created for all nodes except for Availability nodes. Capacity variables are differentiated between Storage nodes and all other Nodes. The implementation of the capacity variables allows for a time-varying capacity during an operational period for inclusion of variations in the demand in Sink nodes. It is however not possible to invest into a time-varying capacity.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The following capacity variables are created for node types other than Storage:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttcap_usen t: Absolute capacity usage of node n at operational period t, and\ntextttcap_instn t: Installed capacity of node n at operational period t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The capacity usage textttcap_use is the utilization of the installed capacity. It is declared in absolute values to avoid bilinearities when investing in capacities. It is normally constrained by the variable textttcap_inst of the individual nodes, except for Sink nodes.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The capacity variables for Storage nodes differentiate between storage capacity (stored energy in the Storage node) or rate of storage (storage rate of a Storage node). A key reasoning for this approach is that it is in general possible to invest both in the storage rate (e.g., the AC-DC transformer required in battery storage) as well as the storage capacity (e.g. the number of cells in battery storage). The same holds as well for pumped hydro storage and storage of gases. The differentiation leads to the following variables for Storage nodes:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttstor_leveln t: Absolute level of energy/mass stored in a Storage node n at operational period t with a typical unit of GWh or t,\ntextttstor_cap_instn t: Installed storage capacity in a Storage node n at operational period t with a typical unit of GWh or t,\ntextttstor_rate_usen t: Usage of the rate of a Storage node n at operational period t, and\ntextttstor_rate_instn t: Maximum available rate of a Storage node n at operational period t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The storage level is always defined for the end of an operational period. There are in addition two variables for the storage level that behave slightly different:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttstor_level_Δ_opn t: Change of the absolute level of energy/mass stored in a Storage node n in operational period t with a typical unit of GWh or t, and\ntextttstor_level_Δ_rpn t_rp: Change of the absolute level of energy/mass stored in a Storage node n in representative period t_rp with a typical unit of GWh or t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"These two variables are introduced to track the change in the storage level in a operational period and a representative period, respectively. They can be considered as helper variables to account for the duration of the operational period as well as the total change within a representative period. textttstor_level_Δ_rp is only declared if the TimeStructure includes RepresentativePeriods. The application of RepresentativePeriods is explained in How to use TimeStruct.jl.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The variables textttcap_inst, textttstor_cap_inst, and textttstor_rate_inst are used in EnergyModelsInvestment to allow for investments in capacity of individual nodes.","category":"page"},{"location":"manual/optimization-variables/#var_flow","page":"Optimization variables","title":"Flow variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Flow variables correspond to the input to and output from both technology nodes and links. They are always positive to avoid backflow.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The following flow variables are defined for the nodes:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttflow_inn t p represents the flow rate of resource p into node n at operational period t. It is created for subtypes of the types NetworkNode and Sink based on the field input in the composite type.\ntextttflow_outn t p represents the flow rate of resource p out of node n at operational period t. It is created for subtypes of the types Source and NetworkNode based on the field output in the composite type.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Links also have corresponding flow variables given by:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttlink_inn t p represents the flow rate of resource p into link l at operational period t, and\ntextttlink_outn t p represents the flow rate of resource p out of link l at operational period t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The resource index p is created based on the intersection of the output of the input node n_in and the input of the output node n_out through the function EMB.link_res(l::Link). Mathematically, this is given as","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"mathcalP^link = mathcalP^n^out_in cap mathcalP^n^in_out","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"It is also possible to create a new method for this function to limit the resources a link can transport.","category":"page"},{"location":"manual/optimization-variables/#var_emission","page":"Optimization variables","title":"Emission variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Emission variables are used for accounting for emissions of the individual technologies. Resources that can be emitted are defined through the type ResourceEmit. Nodes do not necessarily have associated emission variables. Emission variables are only created for a node n if the function has_emissions(n::EMB.Node) returns true. This is the case for all nodes that have EmissionsData within their field data as well as for a RefStorage node if a ResourceEmit is stored. The following node variable is then declared for all emission resource 𝒫ᵉᵐ:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttemissions_noden t p_textttem:  Emissions of node n at operational period t of emission resource p_textttem.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"In addition, EnergyModelsBase declares the following variables for the global emissions:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttemissions_totalt p_textttem: Total emissions of ResourceEmit p_textttem in operational period t, and\ntextttemissions_strategict_textttinv p_textttem: Total emissions of ResourceEmit p_textttem in strategic period t_textttinv.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"These emission variables introduce limits on the total emissions of a resource through the field emission_limit of an EnergyModel in the function EMB.variables_emission.","category":"page"},{"location":"manual/optimization-variables/#var_sink","page":"Optimization variables","title":"Sink variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Sink nodes are somehow different to the other nodes as they have additional variables associated with them. A key point here is to keep the overall mass balance intact while allowing for both overfulfilling and not meeting the demand. These variables are:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttsink_surplusn t: Surplus of energy/mass to Sink n at operational period t, and\ntextttsink_deficitn t: Deficit of energy/mass to Sink n at operational period t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The surplus in a sink corresponds to the energy/mass that is supplied to the sink in addition to the demand. The deficit in a sink corresponds to the energy/mass that is not supplied to the sink although the demand is specified. Both variables correspond to slack variables of the optimization problem. They simplify the problem and can make certain types of formulations feasible. It is possible to provide penalties for both surplus and deficits. This is implemented through the field penalty in the RefSource node.","category":"page"},{"location":"manual/optimization-variables/#var_node","page":"Optimization variables","title":"Node types and respective variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"As outlined in the introduction, EnergyModelsBase declares different variables for each Node. These variables are for the individual nodes given in the subsections below.","category":"page"},{"location":"manual/optimization-variables/#Source","page":"Optimization variables","title":"Source","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data","category":"page"},{"location":"manual/optimization-variables/#NetworkNode,-except-for-Storage","page":"Optimization variables","title":"NetworkNode, except for Storage","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data","category":"page"},{"location":"manual/optimization-variables/#Storage","page":"Optimization variables","title":"Storage","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_var\ntextttopex_fixed\ntextttstor_level\ntextttstor_cap_inst\ntextttstor_rate_use\ntextttstor_rate_inst\ntextttstor_level_Δ_op\ntextttstor_level_Δ_rp if the TimeStruct includes RepresentativePeriods\ntextttflow_in\ntextttflow_out\ntextttemissions_node if ResourceEmit is stored","category":"page"},{"location":"manual/optimization-variables/#Sink","page":"Optimization variables","title":"Sink","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttsink_surplus\ntextttsink_deficit\ntextttemissions_node if EmissionsData is added to the field data","category":"page"},{"location":"manual/data-functions/#data_functions","page":"Data functions","title":"Data functions","text":"","category":"section"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"The package provides the wildcard Data type as outlined in the Extensions to the model section of the philosophy page. Data can be utilized to extend the functionality of the model through dispatching on its type. The following function is included in all reference create_node functions, except for Storage types","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"# Iterate through all data and set up the constraints corresponding to the data\nfor data ∈ node_data(n)\n    constraints_data(m, n, 𝒯, 𝒫, modeltype, data)\nend","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"There is always a fallback option if a Data is specified, but no functions are provided:","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"constraints_data(m, n::Node, 𝒯, 𝒫, modeltype, data::Data) = nothing","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"Its application is best explained by the imlpemented functionality for emissions","category":"page"},{"location":"manual/data-functions/#Emissions-data","page":"Data functions","title":"Emissions data","text":"","category":"section"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"Emissions data is an application of extensions via the application of the wildcard data field in the nodes. It allows to consider:","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"no emissions of a node (no EmissionsData type has to be provided),\nenergy usage related emissions of a node, that is emissions through the utilization of an energy carrier (EmissionsEnergy) given as input,\nthe combination of process emissions and energy usage related emissions (EmissionsProcess),\nCO₂ capture of energy usage related emissions (CaptureEnergyEmissions),\nCO₂ capture of process emissions (CaptureProcessEmissions), and\nCO₂ capture of both process and energy usage related emissions (CaptureProcessEnergyEmissions).","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"The individual fields of the different types are described in the Public interface.","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"The extension is then implemented through the functions","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"function constraints_data(m, n::Node, 𝒯, 𝒫, modeltype, data::EmissionsEnergy)\nfunction constraints_data(m, n::Node, 𝒯, 𝒫, modeltype, data::EmissionsProcess)\nfunction constraints_data(m, n::Node, 𝒯, 𝒫, modeltype, data::CaptureEnergyEmissions)\nfunction constraints_data(m, n::Node, 𝒯, 𝒫, modeltype, data::CaptureProcessEmissions)\nfunction constraints_data(m, n::Node, 𝒯, 𝒫, modeltype, data::CaptureProcessEnergyEmissions)","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"in the file data_functions.jl. Correspondingly, we require only a single implementation of a Node to investigate multiple different emission scenarios, depending on the chosen EmissionsData. Both EmissionsEnergy and EmissionsProcess can handle input similar to the other EmissionsData types, allowing for a fast switch between individual emission configurations.","category":"page"},{"location":"manual/simple-example/#Examples","page":"Example","title":"Examples","text":"","category":"section"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"For the content of the individual examples, see the examples directory in the project repository.","category":"page"},{"location":"manual/simple-example/#The-package-is-installed-with-]-add","page":"Example","title":"The package is installed with ] add","text":"","category":"section"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"From the Julia REPL, run","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"# Starts the Julia REPL\njulia> using EnergyModelsBase\n# Get the path of the examples directory\njulia> exdir = joinpath(pkgdir(EnergyModelsBase), \"examples\")\n# Include the code into the Julia REPL to run the examples\njulia> include(joinpath(exdir, \"sink_source.jl\"))","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"The second example can be run using","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"# Starts the Julia REPL\njulia> using EnergyModelsBase\n# Get the path of the examples directory\njulia> exdir = joinpath(pkgdir(EnergyModelsBase), \"examples\")\n# Include the code into the Julia REPL to run the examples\njulia> include(joinpath(exdir, \"network.jl\"))","category":"page"},{"location":"manual/simple-example/#The-code-was-downloaded-with-git-clone","page":"Example","title":"The code was downloaded with git clone","text":"","category":"section"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"The examples can be run from the terminal with","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"~/../energymodelsrenewableproducers.jl/examples $ julia sink_source.jl","category":"page"},{"location":"how-to/create-new-node/#create_new_node","page":"Create a new node","title":"Creating a new node","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"The energy system model is based on the JuMP optimization framework, so some basic knowledge on this Julia package is needed to implement a new technology node.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"To create a new technology node named NewTechNode, we need toImplement a new struct (composite type), that is a subtypes of Node, Source, Sink, etc. Here, a central choice is to decide on what abstract node type to subtype to.\nOptional: implement the method\nvariables_node(m, 𝒩ˢᵘᵇ::Vector{<:NewTechNode}, 𝒯, modeltype::EnergyModel)\nImplement this method if you want to create additional optimization variables for the new node. See how to create JuMP variables in the JuMP documentation.\nImplement the method\ncreate_node(m, n::NewTechNode, 𝒯, 𝒫, modeltype::EnergyModel)\nIn this method the constraints for the new node are created. See how to create JuMP constraints in the JuMP documentation.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"While step 1 is always required, it is possible to omit step 2 if no new variables are required. It is also possible to create unregistered variables for each instance of the node. This is however only advised if you do not need to access the value of the variables after the optimization.","category":"page"},{"location":"how-to/create-new-node/#Additional-tips-for-creating-new-nodes","page":"Create a new node","title":"Additional tips for creating new nodes","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"If the NewNodeType should be able to include investments, it is necessary to i) call the function constraints_capacity_installed. and ii) have the field data. The function is used for dispatching on the constraints for investments while the field data is used for providing the InvestmentData.\nEmissions can be included in any way. It is however beneficial to reutilize the EmissionsData type to improve usability with other packages. This requries again the inclusion of the field data in NewNodeType. It is possible to also create new subtypes for EmissionsData as well as dispatch on the function constraints_data(m, n::Node, 𝒯, 𝒫, modeltype, data::Data).\nIt is in a first stage not important to include functions for handling all possible TimeStructures, that is, e.g., RepresentativePeriods. Instead, and error can be provided if an unsupported TimeStructure is chosen.\nThe existing reference nodes and their respectvve constraint functions can serve as idea generators.\nIt is possible to include constraints that are coupled to another Node by introduing a field with the Node as type in the NewNodeType, e.g., a field node::Storage when you plan to include additional constraints including a Storage node.\nEnergyModelsBase utilize functions for accessing the fields of the individual nodes. These functions can be found in Functions for accessing fields of Node types. In general, these functions dispatch on abstract types.\nIt is beneficial to include the fields input and output for the NewTechNode. This is not strictly required, but otherwise one has to provide new methods for the functions inputs() and  outputs().","category":"page"},{"location":"how-to/create-new-node/#Advanced-creation-of-new-nodes","page":"Create a new node","title":"Advanced creation of new nodes","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Step 3 in the procedure is not necessarily required. It is also possible to use the available constraint functions for the new node type. In this case, we have to first obtain an overview over the constraint functions called in","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"create_node(m, n::ParentNode, 𝒯, 𝒫, modeltype::EnergyModel)","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"in which ParentNode corresponds to the abstract type that is used as parent for the new NewTechNode. Subsequently, we can add a method to the existing constraint function which is called by the ParentNode. This constraint function has to dispatch on the created NewTechNode type.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"warning: Warning\nIt is in general advised to create a new function create_node(m, n::NewTechNode, 𝒯, 𝒫, modeltype::EnergyModel). The advantage here is that the user requires less understanding of the individual constraint functions. This may lead to repetetive code, but is the safer choice.","category":"page"},{"location":"how-to/create-new-node/#howto_create_node_subtype","page":"Create a new node","title":"What abstract node type should you subtype to?","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"The choice of node supertype depends on what optimization variables you need for the constraints describing the functionality of the new node.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"A new node is defined as a composite type (struct) and subtype of one of the standard node types,","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Source\nNetworkNode\nSink","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Furthermore, we have the types","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Availability <: NetworkNode\nStorage <: NetworkNode","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"which correspond to a routing node (Availability) and a storage node (Storage).","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"The overall structure of the individual nodes can be printed to the REPL using the following code:","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"julia> using EnergyModelsBase\njulia> const EMB = EnergyModelsBase\njulia> using AbstractTrees\njulia> AbstractTrees.children(x::Type) = subtypes(x)\n\njulia> print_tree(EMB.Node)","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Node\n├─ NetworkNode\n│  ├─ Availability\n│  │  └─ GenAvailability\n│  ├─ RefNetworkNode\n│  └─ Storage\n│     └─ RefStorage\n├─ Sink\n│  └─ RefSink\n└─ Source\n   └─ RefSource","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"The leaf nodes of the above type hierarchy tree are composite types, while the inner vertices are abstract types. The chosen parent type of the NewNodeType node decides what optimization variables are created for use by default. You can find the created default optimization variables in Optimization Variables and Node types and respective variables. The main difference between the individual parent types is whether they have only an energy/mass output (Source), input and output (NetworkNode), or input (Sink). A more detailed explanation of the different abstract types can be found in Description of Technologies","category":"page"},{"location":"how-to/create-new-node/#Example","page":"Create a new node","title":"Example","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"As an example, you can check out how EnergyModelsRenewableProducers introduces two new technology types, a Source and a Storage.","category":"page"},{"location":"manual/quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"Install the most recent version of Julia\nInstall the package EnergyModelsBase and the time package TimeStruct, by running:\n] add TimeStruct\n] add EnergyModelsBase","category":"page"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"note: Note\nIf you receive the error that EnergyModelsBase is not yet registered, you have to add the package using the GitHub repositories through] add https://github.com/EnergyModelsX/EnergyModelsBase.jlOnce the package is registered, this is not required.","category":"page"},{"location":"manual/philosophy/#Philosophy","page":"Philosophy","title":"Philosophy","text":"","category":"section"},{"location":"manual/philosophy/#General-design-philosophy","page":"Philosophy","title":"General design philosophy","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"One key aim in the development of EnergyModelsBase was to create an energy system model that","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"offers maximum flexibility with respect to the description of technologies,\nis simple to extend with additional features without requiring changes in the core structure, and\nis designed in a way such that the thought process for understanding the model is straight forward.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Julia as a programming language offers the flexibility required in points 1 and 2 through the concept of multiple dispatch. The philosophy hence focueses on only creating variables and constraintes that are used, instead of creating all potential constraints and variables and constrain a large fraction of these variables to a value of 0. In that respect, EnergyModelsBase moves away from a parameter driven flexibility to a type driven flexibility. Point 3 is achieved through a one direction flow in function calls, that is that we limit the number of required files and function calls for the individual technology constraint creations, and meaningful names of the individual functions.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"The general concept of the model in EnergyModelsBase is based on a graph structure. The technologies within the modeled energy system are represented by Nodes. These Nodes correspond to, eg, a hydropower plant, a gas turbine, or the Haber-Bosch process. The individual nodes are then connected via Links/edges representing the transport of mass or energy between the technologies. EnergyModelsBase is represented using directed graphs, that is, flow is only possible in one direction through the links. The included Resources 𝒫 are user defined. These resources have a unit associated with them, although this is not modelled explicitly in the current implementation. These units define the units/values that have to be applied when converting resources.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"EnergyModelsBase does not include all necessary constraints for individual technologies. Instead, it is seen as a lightweight core structure that can be extended by the user through the development of specific Node functions. Potential additional Nodes can focus on, e.g.:","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Piecewise linear efficiencies of technologies,\nInclusion of ramping constraints for technologies for which these are relevant,\nMinimmum capacity usage based on disjunctions, or\nImproved description of start-up and shut-down energy and time demands through disjunctions","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"to name some of potential new constraints.","category":"page"},{"location":"manual/philosophy/#sec_des_nodes","page":"Philosophy","title":"Description of technologies","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"The package utilizes different types that represent components in an energy system. These types can be summarized as:","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Source types have only an ouput to the system. Practical examples are solar PV, wind power, or available resources at a given price.\nNetworkNode types have both an input and an ouput. Practical examples are next to all technologies in an energy system, like e.g., a natural gas reforming plant with CCS (input: natural gas and electricity, output: hydrogen and CO₂) or an electrolyser (input: electricity, output: hydrogen).\nSink types have only an input from the system. They correspond in general to an energy/mass demand.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"In addition, there are two types that are subtypes of NetworkNode:","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Availability types are routing types. They guarantee the energy/mass balance of all connected inputs/outputs.\nStorage types are a special subtype as they include different variables.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"These types are connected using links that transport the energy/mass.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"New technologies can be introduced by defining a new composite type for the technology. You can find a description on how you can create a new node on the page Creating a new node.","category":"page"},{"location":"manual/philosophy/#sec_phil_ext","page":"Philosophy","title":"Extensions to the model","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"There are in general four ways to extend the model:","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Introducing new technology descriptions as described in Creating a new node,\nCall of the create_model function with subsequent function calls for adding additional constraints,\nDispatching on the type EnergyModel, and\nUse the field data in the individual composite types.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Introducing new technology descriptions is the basis for extending the model. This approach allows for a different mathematical description compared to the included reference nodes. As an example, it is possible to introduce a new demand node that provides a profit for satisfying a demand combined with having no penalty if the demand is not satisfied.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Calling create_model within a new function allows the introduction of entirely new functions. This approach is chosen in EnergyModelsGeography although it still uses dispatch on individual technology nodes.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Dispatching on the type EnergyModel allows for adding methods to all functions that have modeltype included in the call. This is done in the package EnergyModelsInvestments where investments are added to the model through introducting the abstract type AbstractInvestmentModel. It can be problematic when one also wants to use investments. In addition, care has to be taken with respect to method amibiguity when dispatching on the type EnergyModel.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"The Array{Data} field provides us with flexibility with respect to providing additional data to the existing nodes. It is implemented in EnergyModelsBase for including emissions (both process and energy usage related). In that case, it allows for flexibility through either saying whether process (or energy related emissions) are present, or not. In addition, it allows for capturing the CO₂ from either the individual CO₂ sources (process and energy usage related), alternatively from both sources, or not at all. The individual data types are explained in the Section Emissions data in the public library as well as on Data functions. In addition, it is already used in the package EnergyModelsInvestments through the introduction of the abstract type InvestmentData as subtype of Data. The introduction of InvestmentData allows providing additional parameters to individual technologies. However, the implementation in EnergyModelsInvestments does not utilize the extension through the Data functions. Instead, as outlined above, it dispatches on the type EnergyModel.","category":"page"},{"location":"manual/constraint-functions/#constraint_functions","page":"Constraint functions","title":"Constraint functions","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"The package provides standard constraint functions that can be used for new developed nodes. These standard constraint functions are used exclusively in all create_node(m, n, 𝒯, 𝒫, modeltype) functions. They allow for both removing repititions of code as well as dispatching only on certain aspects. The majority of the constraint functions are created for the abstract type of the Node dispatching, that is, the supertypes described in Description of Technologies. If a constraint function is not using the abstract type for dispatching, a warning is shown in this manual.","category":"page"},{"location":"manual/constraint-functions/#Capacity-constraints","page":"Constraint functions","title":"Capacity constraints","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Capacity constraints are constraints that limit both the capacity usage and installed capacity. The core function is given by","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_capacity(m, n::Node, 𝒯::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"correponding to the constraint on the usage of the capacity of a technology node n. It is implemented for Node, Storage, and Sink types. The general implementation is limiting the capacity usage. That is, limiting the variable textttcap_usen t to the maximum installed capacity textttcap_instn t (and correspondingly for both rate and level variables for storage). Sink nodes behave differently as we allow for both surplus (textttsink_surplusn t) and deficits (textttsink_deficitn t), as explained in Sink variables.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Within this function, the function","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_capacity_installed(m, n::Node, 𝒯::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"is called to limit the variable textttcap_inst (or textttstor_cap_inst and textttstor_rate_inst for Storage nodes) of a technology node n. This functions is also used to subsequently dispatch on model type for the introduction of investments.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"warning: Warning\nAs the function constraints_capacity_installed is used for including investments for nodes, it is important that it is also called when creating a new node. It is not possible to only add a function forconstraints_capacity_installed(m, n::Node, 𝒯::TimeStructure, modeltype::EnergyModel)without adding a function forconstraints_capacity_installed(m, n::Node, 𝒯::TimeStructure, modeltype::EMI.AbstractInvestmentModel)as this can lead to a method ambiguity error.","category":"page"},{"location":"manual/constraint-functions/#Flow-constraints","page":"Constraint functions","title":"Flow constraints","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Flow constraints handle how the flow variables of a Node are connected to the internal variables. In EnergyModelsBase, we only consider capacity variables as internal variables. This can however be extended through the development of new Nodes, if desired.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_flow_in(m, n::Node, 𝒯::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the constraints calculating the required inflow to a node n for a given capacity usage. It is implemented for Node (using textttcap_usen t) and Storage (using textttstor_rate_usen t) types.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_flow_out(m, n::Node, 𝒯::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the constraints calculating the outflow of a node n for a given capacity usage. It is implemented for Node types using textttcap_usen t but not used for the Storage subtypes introduced in the model. The outflow of a Storage node is instead specified through the storage level balance.","category":"page"},{"location":"manual/constraint-functions/#Storage-level-constraints","page":"Constraint functions","title":"Storage level constraints","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Storage level constraints are required to provide flexibility on how the level of a Storage node has to be calculated.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_level(m, n::Storage, 𝒯, 𝒫, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the main constraint for calculating the level balance of a Storage node. Within this constraint, two different functions are called:","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_level_aux(m, n, 𝒯, 𝒫, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"and","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_level_sp(m, n, t_inv, 𝒫, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"The first function, constraints_level_aux, is used to calculate additional properties of a Storage node. These properties are independent of the chosen TimeStructure, but dependent on the stored Resource type. General properties are the calculation of the change in storage level in an operational period, as described in Capacity variables as well as bounds on variables. It is implemented for the cases when the stored resource is either a ResourceEmit  or a ResourceCarrier. Storing a ResourceEmit in a RefStorage node limits the variable textttstor_level_Deltatexttt_opn t p geq 0 as well as introduces emission variables.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"The second function, constraints_level_sp, declares the level balance of the RefStorage node within a strategic period. The difference betwen storing a ResourceCarrier and a ResourceEmit is given by how the level at the first operational period in a strategic period is treated. While a ResourceCarrier uses circular constraints, that is, the first operational period in a strategic period is dependent on the last operational period in a strategic period, storing a ResourceEmit uses a value of 0 for the first operational period of a strategic period.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"In addition, RepresentativePeriods can be handled through scaling of the change in the level in a representative period. This requires that the RepresentativePeriods are sequential.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"warning: Warning\nBoth constraints_level_aux and constraints_level_sp dispatch on RefStorage as they behave differently when a ResourceEmit or ResourceCarrier is stored. This implies that developing a new Storage node requires creating a new level balance.","category":"page"},{"location":"manual/constraint-functions/#Operational-expenditure-constraints","page":"Constraint functions","title":"Operational expenditure constraints","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Operational expenditure (OPEX) constraints calculate the contribution of operating a technology. The constraints are declared for both the fixed and variable OPEX.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_opex_fixed(m, n::Node, 𝒯::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the constraints calculating the fixed operational costs of a technology node n. It is implemented for Node, Storage, RefStorage{T<:ResourceEmit}, and Sink types. The fixed OPEX is in general dependent on the installed capacity.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Storage nodes use a different variable for describing the installed capacity. Hence, the fixed OPEX calculations differs. The fixed OPEX of a RefStorage node is calculated using the installed capacity (textttstor_cap_inst) when the stored resource is a ResourceCarrier and using the installed rate (textttstor_rate_inst) when the stored resource is a ResourceEmit.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Sink nodes use the variable textttcap_inst for providing a demand. They do not have a capacity in their basic implementation. Hence, no fixed OPEX is calculated.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_opex_var(m, n::Node, 𝒯::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the constraints calculating the variable operational costs of a technology node n. It is implemented for Node, Storage, RefStorage{T<:ResourceEmit}, and Sink types. The variable OPEX is in general dependent on the capacity usage.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Storage nodes use a different variable for describing the capacity usage. The variable OPEX of a RefStorage node is calculated using the inlet flow of the stored resource (textttflow_inn t  p_textttstor). Storing a ResourceEmit allows also for emissions of the stored resource. In this case, the emissions are not included in the variable OEPX calculations","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"The variable OPEX calculations of Sink nodes include both the potential of a penalty for the surplus and deficit as described in Sink variables.","category":"page"},{"location":"manual/nodes/#Nodes","page":"Nodes","title":"Nodes","text":"","category":"section"},{"location":"manual/nodes/","page":"Nodes","title":"Nodes","text":"julia> using EnergyModelsBase\njulia> const EMB = EnergyModelsBase \njulia> using AbstractTrees\njulia> AbstractTrees.children(x::Type) = subtypes(x)\n\njulia> print_tree(EMB.Node)","category":"page"},{"location":"manual/nodes/","page":"Nodes","title":"Nodes","text":"Node\n├─ NetworkNode\n│  ├─ Availability\n│  │  └─ GenAvailability\n│  ├─ RefNetworkNode\n│  └─ Storage\n│     └─ RefStorage\n├─ Sink\n│  └─ RefSink\n└─ Source\n   └─ RefSource","category":"page"},{"location":"manual/nodes/","page":"Nodes","title":"Nodes","text":"The leaf nodes of the above type hierarchy tree are composite types, while the inner vertices are abstract types. The individual nodes and their fields are explained in the public library.","category":"page"},{"location":"library/internals/reference/#Internals","page":"Reference","title":"Internals","text":"","category":"section"},{"location":"library/internals/reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"library/internals/reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"library/internals/reference/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"library/internals/reference/","page":"Reference","title":"Reference","text":"Modules = [EnergyModelsBase]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"library/internals/reference/#EnergyModelsBase.Formulation","page":"Reference","title":"EnergyModelsBase.Formulation","text":"Declaration of the general type for formulation of links.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference/#EnergyModelsBase.Node","page":"Reference","title":"EnergyModelsBase.Node","text":"Node as supertype for all technologies.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference/#Methods","page":"Reference","title":"Methods","text":"","category":"section"},{"location":"library/internals/reference/","page":"Reference","title":"Reference","text":"Modules = [EnergyModelsBase]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"library/internals/reference/#EnergyModelsBase.check_data-Tuple{Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.check_data","text":"check_data(case, modeltype)\n\nCheck if the case data is consistent. Use the @assert_or_log macro when testing. Currently only checking node data.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.check_node-Tuple{EnergyModelsBase.Node, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.check_node","text":"check_node(n, 𝒯, modeltype::EnergyModel)\n\nCheck that the fields of a Node corresponds to required structure.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.check_profile_field-Tuple{Any, Any, StrategicProfile, TwoLevel}","page":"Reference","title":"EnergyModelsBase.check_profile_field","text":"check_profile_field(fieldname, value::TimeProfile, 𝒯)\n\nCheck that an individual TimeProfile corresponds to the time structure 𝒯.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.check_time_structure-Tuple{EnergyModelsBase.Node, Any}","page":"Reference","title":"EnergyModelsBase.check_time_structure","text":"check_time_structure(n::Node, 𝒯)\n\nCheck that all fields of a Node that are of type TimeProfile correspond to the time structure 𝒯.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.collect_types-Tuple{Any}","page":"Reference","title":"EnergyModelsBase.collect_types","text":"collect_types(types_list)\n\nReturn a Dict of all the give types_list and their supertypes. The keys in the dictionary are the types, and their corresponding value is the number in the type hierarchy.\n\nE.g., Node is at the top and will thus have the value 1. Types just below Node will have value 2, and so on.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.compile_logs-Tuple{Any, Any}","page":"Reference","title":"EnergyModelsBase.compile_logs","text":"compile_logs(case, log_by_element)\n\nSimple method for showing all log messages.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.constraints_emissions-Tuple{Any, Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.constraints_emissions","text":"constraints_emissions(m, 𝒩, 𝒯, 𝒫, modeltype::EnergyModel)\n\nCreate constraints for the emissions accounting for both operational and strategic periods.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.constraints_level_aux-Union{Tuple{S}, Tuple{Any, RefStorage{S}, Any, Any, EnergyModel}} where S<:ResourceCarrier","page":"Reference","title":"EnergyModelsBase.constraints_level_aux","text":"constraints_level_aux(m, n::RefStorage{S}, 𝒯, 𝒫, modeltype::EnergyModel) where {S<:ResourceCarrier}\n\nFunction for creating the Δ constraint for the level of a reference storage node with a ResourceCarrier resource.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.constraints_level_aux-Union{Tuple{S}, Tuple{Any, RefStorage{S}, Any, Any, EnergyModel}} where S<:ResourceEmit","page":"Reference","title":"EnergyModelsBase.constraints_level_aux","text":"constraints_level_aux(m, n::RefStorage{S}, 𝒯, 𝒫, modeltype::EnergyModel) where {S<:ResourceEmit}\n\nFunction for creating the Δ constraint for the level of a reference storage node with a ResourceEmit resource.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.constraints_level_sp-Union{Tuple{U}, Tuple{T}, Tuple{S}, Tuple{Any, RefStorage{S}, TimeStruct.StrategicPeriod{T, RepresentativePeriods{U, T, SimpleTimes{T}}}, Any, EnergyModel}} where {S<:ResourceCarrier, T, U}","page":"Reference","title":"EnergyModelsBase.constraints_level_sp","text":"constraints_level_sp(\n    m,\n    n::RefStorage{S},\n    t_inv::TS.StrategicPeriod{T, RepresentativePeriods{U, T, SimpleTimes{T}}},\n    𝒫,\n    modeltype::EnergyModel\n    ) where {S<:ResourceCarrier, T, U}\n\nFunction for creating the level constraint for a reference storage node with a ResourceCarrier resource when the operational TimeStructure is given as RepresentativePeriods.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.constraints_level_sp-Union{Tuple{U}, Tuple{T}, Tuple{S}, Tuple{Any, RefStorage{S}, TimeStruct.StrategicPeriod{T, RepresentativePeriods{U, T, SimpleTimes{T}}}, Any, EnergyModel}} where {S<:ResourceEmit, T, U}","page":"Reference","title":"EnergyModelsBase.constraints_level_sp","text":"constraints_level_sp(\n    m,\n    n::RefStorage{S},\n    t_inv::TS.StrategicPeriod{T, RepresentativePeriods{U, T, SimpleTimes{T}}},\n    𝒫,\n    modeltype::EnergyModel\n    ) where {S<:ResourceEmit, T, U}\n\nFunction for creating the level constraint for a reference storage node with a ResourceEmit resource when the operational TimeStructure is given as RepresentativePeriods.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.constraints_level_sp-Union{Tuple{U}, Tuple{T}, Tuple{S}, Tuple{Any, RefStorage{S}, TimeStruct.StrategicPeriod{T, U}, Any, EnergyModel}} where {S<:ResourceCarrier, T, U<:SimpleTimes}","page":"Reference","title":"EnergyModelsBase.constraints_level_sp","text":"constraints_level_sp(\n    m,\n    n::RefStorage{S},\n    t_inv::TS.StrategicPeriod{T, U},\n    𝒫,\n    modeltype::EnergyModel\n    ) where {S<:ResourceCarrier, T, U<:SimpleTimes}\n\nFunction for creating the level constraint for a reference storage node with a ResourceCarrier resource when the operational TimeStructure is given as SimpleTimes.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.constraints_level_sp-Union{Tuple{U}, Tuple{T}, Tuple{S}, Tuple{Any, RefStorage{S}, TimeStruct.StrategicPeriod{T, U}, Any, EnergyModel}} where {S<:ResourceEmit, T, U<:SimpleTimes}","page":"Reference","title":"EnergyModelsBase.constraints_level_sp","text":"constraints_level_sp(\n    m,\n    n::RefStorage{S},\n    t_inv::TS.StrategicPeriod{T, U},\n    𝒫,\n    modeltype::EnergyModel\n    ) where {S<:ResourceEmit, T, U<:SimpleTimes}\n\nFunction for creating the level constraint for a reference storage node with a ResourceEmit resource when the operational TimeStructure is given as SimpleTimes.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.constraints_links-Tuple{Any, Any, Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.constraints_links","text":"constraints_links(m, 𝒩, 𝒯, 𝒫, ℒ, modeltype::EnergyModel)\n\nCall the function create_link for link formulation\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.constraints_node-Tuple{Any, Any, Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.constraints_node","text":"constraints_node(m, 𝒩, 𝒯, 𝒫, ℒ, modeltype::EnergyModel)\n\nCreate link constraints for each n ∈ 𝒩 depending on its type and calling the function create_node(m, n, 𝒯, 𝒫) for the individual node constraints.\n\nCreate constraints for fixed OPEX.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.create_link-Tuple{Any, Any, Any, Any, EnergyModelsBase.Formulation}","page":"Reference","title":"EnergyModelsBase.create_link","text":"create_link(m, 𝒯, 𝒫, l, formulation::Formulation)\n\nSet the constraints for a simple Link (input = output). Can serve as fallback option for all unspecified subtypes of Link.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.is_network_node-Tuple{EnergyModelsBase.Node}","page":"Reference","title":"EnergyModelsBase.is_network_node","text":"is_network_node(n::Node)\n\nChecks, whether node n is a NetworkNode node\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.is_resource_emit-Tuple{Resource}","page":"Reference","title":"EnergyModelsBase.is_resource_emit","text":"is_resource_emit(p::Resource)\n\nChecks whether the Resource p is of type ResourceEmit.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.is_sink-Tuple{EnergyModelsBase.Node}","page":"Reference","title":"EnergyModelsBase.is_sink","text":"is_sink(n::Node)\n\nChecks, whether node n is a Sink node\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.is_source-Tuple{EnergyModelsBase.Node}","page":"Reference","title":"EnergyModelsBase.is_source","text":"is_source(n::Node)\n\nChecks, whether node n is a Source node\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.is_storage-Tuple{EnergyModelsBase.Node}","page":"Reference","title":"EnergyModelsBase.is_storage","text":"is_storage(n::Node)\n\nChecks, whether node n is a Storage node\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.link_res-Tuple{Link}","page":"Reference","title":"EnergyModelsBase.link_res","text":"link_res(l::Link)\n\nReturn the resources transported for a given link l.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.link_sub-Tuple{Any, EnergyModelsBase.Node}","page":"Reference","title":"EnergyModelsBase.link_sub","text":"link_sub(ℒ, n::Node)\n\nReturn connected links for a given node n.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.multiple-Tuple{Any, Any}","page":"Reference","title":"EnergyModelsBase.multiple","text":"multiple(t_inv, t)\n\nProvide a simplified function for returning the combination of the functions duration(t) * multiplestrat(tinv, t) * probability(t)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.node_sub","page":"Reference","title":"EnergyModelsBase.node_sub","text":"nodes_sub(𝒩::Array{Node}, sub/subs)\n\nReturn nodes that are of type sub/subs for a given Array ::Array{Node}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference/#EnergyModelsBase.nodes_not_av-Tuple{Array{EnergyModelsBase.Node}}","page":"Reference","title":"EnergyModelsBase.nodes_not_av","text":"nodes_not_av(𝒩::Array{Node})\n\nReturn nodes that are not Availability nodes for a given Array ::Array{Node}.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.nodes_not_sub","page":"Reference","title":"EnergyModelsBase.nodes_not_sub","text":"nodes_not_sub(𝒩::Array{Node}, sub)\n\nReturn nodes that are not of type sub for a given Array ::Array{Node}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference/#EnergyModelsBase.objective-Tuple{Any, Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.objective","text":"objective(m, 𝒩, 𝒯, 𝒫, modeltype::EnergyModel)\n\nCreate the objective for the optimization problem for a given modeltype.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.res_em-Tuple{Array{<:Resource}}","page":"Reference","title":"EnergyModelsBase.res_em","text":"res_em(𝒫::Array{<:Resource})\n\nReturns all emission resources for a\n\na given array ::Array{<:Resource}.The output is in this case an Array{<:Resource}\na given dictionary ::Dict.The output is in this case a dictionary Dict with the correct fields\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.res_not-Tuple{Array{<:Resource}, Resource}","page":"Reference","title":"EnergyModelsBase.res_not","text":"res_not(𝒩::Array{<:Resource}, res_inst)\n\nReturn all resources that are not res_inst for\n\na given array ::Array{<:Resource}.The output is in this case an Array{<:Resource}\na given dictionary ::Dict.The output is in this case a dictionary Dict with the correct fields\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.res_sub","page":"Reference","title":"EnergyModelsBase.res_sub","text":"res_sub(𝒫::Array{<:Resource}, sub = ResourceEmit)\n\nReturn resources that are of type sub for a given Array ::Array{Resource}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference/#EnergyModelsBase.sort_types-Tuple{Dict}","page":"Reference","title":"EnergyModelsBase.sort_types","text":"sort_types(types_list::Dict)\n\nSort the result of collect_types and return a vector where a supertype comes before all its subtypes.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.variables_capacity-Tuple{Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.variables_capacity","text":"variables_capacity(m, 𝒩, 𝒯, modeltype::EnergyModel)\n\nCreation of different capacity variables for nodes 𝒩ⁿᵒᵗ that are neither Storage nor Availability nodes. These variables are:\n\n:cap_use - use of a technology node in each operational period\n:cap_inst - installed capacity in each operational period in terms of either :flow_in\n\nor :flow_out (depending on node n ∈ 𝒩)\n\nCreation of different storage variables for Storage nodes 𝒩ˢᵗᵒʳ. These variables are:\n\n:stor_level - storage level at the end of each operational period\n:stor_level_Δ_op - storage level change in each operational period\n:stor_level_Δ_rp - storage level change in each representative period\n:stor_rate_use - storage rate use in each operational period\n:stor_cap_inst - installed capacity for storage in each operational period, constrained\n\nin the operational case to n.stor_cap\n\n:stor_rate_inst - installed rate for storage, e.g. power in each operational period,\n\nconstrained in the operational case to n.rate_cap\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.variables_capex-Tuple{Any, Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.variables_capex","text":"variables_capex(m, 𝒩, 𝒯, 𝒫, modeltype::EnergyModel)\n\nDeclaration of the CAPEX variables of the model for each investment period 𝒯ᴵⁿᵛ ∈ 𝒯. Empty for operational models but required for multiple dispatch in investment model.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.variables_emission-Tuple{Any, Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.variables_emission","text":"variables_emission(m, 𝒩, 𝒯, 𝒫, modeltype::EnergyModel)\n\nDeclaration of emission variables per technology node with emissions n ∈ 𝒩ᵉᵐ and emission resource 𝒫ᵉᵐ ∈ 𝒫.\n\nThe emission variables are differentiated in:\n\n:emissions_node - emissions of a node in an operational period,\n:emissions_total - total emissions in an operational period, and\n:emissions_strategic - total strategic emissions, constrained to an upper limit basedon the field emission_limit of the EnergyModel.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.variables_flow-Tuple{Any, Any, Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.variables_flow","text":"variables_flow(m, 𝒩, 𝒯, 𝒫, ℒ, modeltype::EnergyModel)\n\nDeclaration of the individual input (:flow_in) and output (:flow_out) flowrates for each technological node n ∈ 𝒩 and link l ∈ ℒ (:link_in and :link_out).\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.variables_nodes-Tuple{Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.variables_nodes","text":"variables_nodes(m, 𝒩, 𝒯, modeltype::EnergyModel)\n\nLoop through all node types and create variables specific to each type. This is done by calling the method variables_node on all nodes of each type.\n\nThe node type representing the widest cathegory will be called first. That is, variables_node will be called on a Node before it is called on NetworkNode-nodes.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference/#EnergyModelsBase.variables_opex-Tuple{Any, Any, Any, Any, EnergyModel}","page":"Reference","title":"EnergyModelsBase.variables_opex","text":"variables_opex(m, 𝒩, 𝒯, 𝒫, modeltype::EnergyModel)\n\nDeclaration of the OPEX variables (:opex_var and :opex_fixed) of the model for each investment period 𝒯ᴵⁿᵛ ∈ 𝒯. Variable OPEX can be non negative to account for revenue streams.\n\n\n\n\n\n","category":"method"},{"location":"manual/NEWS/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"manual/NEWS/#Version-0.6.4-(2024-01-18)","page":"Release notes","title":"Version 0.6.4 (2024-01-18)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Minor modification to the EmissionsData allowing now also time dependent process emissions. This is achieved through switching to a parametric type.","category":"page"},{"location":"manual/NEWS/#Version-0.6.3-(2024-01-17)","page":"Release notes","title":"Version 0.6.3 (2024-01-17)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Changed name of constraints_level  to constraints_level_sp when the time input is given as a StrategicPeriod to improve understandability.\nAdd modeltype::EnergyModel as an argument to the methods constraints_level_sp (see above) and constraints_level_aux.","category":"page"},{"location":"manual/NEWS/#Version-0.6.2-(2024-01-17)","page":"Release notes","title":"Version 0.6.2 (2024-01-17)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"When variables are created with the method variables_nodes, it will lead to an ErrorException when the method tries to create a variable that has already been created. This is ok, and this error should be ignored. This change specifies exactly what error should be ignored, to avoid that other types of errors are also ignored.","category":"page"},{"location":"manual/NEWS/#Version-0.6.1-(2024-01-11)","page":"Release notes","title":"Version 0.6.1 (2024-01-11)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fix: add missing parenthesis in the objective function.","category":"page"},{"location":"manual/NEWS/#Version-0.6.0-(2023-12-14)","page":"Release notes","title":"Version 0.6.0 (2023-12-14)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Switched fields Input and Output of Availability nodes from Dict{Resource, Real} to Array{<:Resource}. The former is still available as a constructor, while a new constructor is introduced which requires the input only once.\nAll fields in composite types are now lower case.\nRenamed Network to NetworkNode. NetworkNode can be considered to be replaced in a later iterations as it is not really needed.\nAdded functions for extracting the fields of Nodes, Resources, and EnergyModels to allow for extensions.\nAdded export of functions that are frequently used in other packages.\nMoved the emissions to a Data type on which we can dispatch, depending on the chosen approach for capture and process emissions.\nRedesigned storage as parametric type to dispatch on the level balance. This includes as well the introduction of a new variable.\nIncluded potential for different durations of operational periods.\nIncluded representative periods. These do only affect a Storage node as these are the only time dependent nodes.\nAdded emission prices to OperationalModel.","category":"page"},{"location":"manual/NEWS/#Version-0.5.2-(2023-11-06)","page":"Release notes","title":"Version 0.5.2 (2023-11-06)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Introduced method create_model that can take a JuMP.Model as input to simplify potential use of other type of models\nFixed the documentation to avoid errors","category":"page"},{"location":"manual/NEWS/#Version-0.5.1-(2023-06-16)","page":"Release notes","title":"Version 0.5.1 (2023-06-16)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Updated the documentation based on the new format","category":"page"},{"location":"manual/NEWS/#Version-0.5.0-(2023-06-01)","page":"Release notes","title":"Version 0.5.0 (2023-06-01)","text":"","category":"section"},{"location":"manual/NEWS/#Switch-to-TimeStruct.jl","page":"Release notes","title":"Switch to TimeStruct.jl","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Switched the time structure representation to TimeStruct.jl\nTimeStruct.jl is implemented with only the basis features that were available in TimesStructures.jl. This implies that neither operational nor strategic uncertainty is included in the model","category":"page"},{"location":"manual/NEWS/#Version-0.4.0-(2023-05-30)","page":"Release notes","title":"Version 0.4.0 (2023-05-30)","text":"","category":"section"},{"location":"manual/NEWS/#Additional-input-data-changes","page":"Release notes","title":"Additional input data changes","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Changed the structure in which the extra field Data is included in the nodes\nIt is changed from Dict{String, Data} to Array{Data}","category":"page"},{"location":"manual/NEWS/#Version-0.3.3-(2023-04-26)","page":"Release notes","title":"Version 0.3.3 (2023-04-26)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Changed where storage variables are declared to avoid potential method ambiguity through new storage variables when using EnergyModelsInvestments","category":"page"},{"location":"manual/NEWS/#Version-0.3.2-(2023-02-07)","page":"Release notes","title":"Version 0.3.2 (2023-02-07)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Generalized the function names for identifying and sorting the individual introduced types.","category":"page"},{"location":"manual/NEWS/#Version-0.3.1-(2023-02-03)","page":"Release notes","title":"Version 0.3.1 (2023-02-03)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Take the examples out to the directory examples","category":"page"},{"location":"manual/NEWS/#Version-0.3.0-(2023-02-02)","page":"Release notes","title":"Version 0.3.0 (2023-02-02)","text":"","category":"section"},{"location":"manual/NEWS/#Fields-of-reference-types-and-new-types","page":"Release notes","title":"Fields of reference types and new types","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Removal of all process emissions and CO₂ capture from reference types to avoid having to include them as well","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"in all subtypes defined later to keep the fallback option. This requires in the future to ***remove*** CO₂ as output when using CO₂ capture as it was previously the case. The original types are retained so that they can still be used","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Introduction of a type RefStorageEmissions to account for a storage unit that can be used for storing ResourceEmit","category":"page"},{"location":"manual/NEWS/#Introduction-of-functions-for-constraints-generation","page":"Release notes","title":"Introduction of functions for constraints generation","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Substitution of variable and fixed OPEX calculations as well as capacity and flow constraints through functions which utilize dispatching on node types","category":"page"},{"location":"manual/NEWS/#Redefinition-of-introduction-of-global-data","page":"Release notes","title":"Redefinition of introduction of global data","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Removal of the type AbstractGlobalData and all subtypes and substitution through EnergyModel and the corresponding subtypes\nAddition of the field CO2_instance in the type OperationalModel\nAddition of ModelType to the function create_node to be able to use different ids for the CO₂ resource","category":"page"},{"location":"manual/NEWS/#Additional-changes","page":"Release notes","title":"Additional changes","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Redefining CO2Int in fields of type Resource to CO2_int to be consistent with the other types\nMinor changes in constraint description that do not break previous code\nChanged the input to the function variables_node to simplify the generation of variables for a specific node type","category":"page"},{"location":"manual/NEWS/#Version-0.2.7-(2022-12-12)","page":"Release notes","title":"Version 0.2.7 (2022-12-12)","text":"","category":"section"},{"location":"manual/NEWS/#Internal-release","page":"Release notes","title":"Internal release","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Renamed packages to use common prefix\nUpdated README","category":"page"},{"location":"manual/NEWS/#Version-0.2.4-(2022-09-07)","page":"Release notes","title":"Version 0.2.4 (2022-09-07)","text":"","category":"section"},{"location":"manual/NEWS/#Feature-update-and-changes-in-export","page":"Release notes","title":"Feature update and changes in export","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Inclusion of time dependent profiles for surplus and deficit of sinks\nInclusion of parameter checks for surplus and deficit of sinks\nExport of all reference nodes for easier identification of the nodes\nChanges in the test structure with improved testing of variables\nChanges in doc strings for individual functions/types","category":"page"},{"location":"manual/NEWS/#Version-0.2.3-(2021-09-07)","page":"Release notes","title":"Version 0.2.3 (2021-09-07)","text":"","category":"section"},{"location":"manual/NEWS/#Changes-in-naming","page":"Release notes","title":"Changes in naming","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Major changes in both variable and parameter naming, check the commit message for an overview","category":"page"},{"location":"manual/NEWS/#Version-0.2.2-(2021-08-20)","page":"Release notes","title":"Version 0.2.2 (2021-08-20)","text":"","category":"section"},{"location":"manual/NEWS/#Feature-updates","page":"Release notes","title":"Feature updates","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Change of Availability to abstract type and introduction of GenAvailability as composite type to be able to use multiple dispatch on the availability nodes\nInclusion of the entry fixed OPEX to the node composite types\nInclusion of the entry data to the node composite types to provide input required for certain additional packages like investments\nNew function for checks of node data so that we have an a priori check of all model data","category":"page"},{"location":"manual/NEWS/#Changes-in-naming-2","page":"Release notes","title":"Changes in naming","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Introduce the optimization variables storlevel and stormax for storages, and use these instead of capusage and capmax for the constraints on Storage.\nUse the new variable cap_storage in Storage nodes for the installed storage capacity.","category":"page"},{"location":"manual/NEWS/#Version-0.2.1-(2021-04-22)","page":"Release notes","title":"Version 0.2.1 (2021-04-22)","text":"","category":"section"},{"location":"manual/NEWS/#Feature-updates-2","page":"Release notes","title":"Feature updates","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Reduction in variables through introduction of input/output (#2)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"dictionaries for all nodes that only include necessary components","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Improvement related to emissions to avoid wrong accounting when other emission carriers than CO₂ are present (#2)\nLink resources generated automatically from input (#2)","category":"page"},{"location":"manual/NEWS/#Changes-in-naming-3","page":"Release notes","title":"Changes in naming","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Removal of prefix \"create\" before \"constraints\" and \"variables\"\n\"createmodule\" switched to \"createnode\"","category":"page"},{"location":"manual/NEWS/#Version-0.2.0-(2021-04-19)","page":"Release notes","title":"Version 0.2.0 (2021-04-19)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Inclusion of abstract type and structures for both resources and (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"differentiation in nodes","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Development of new functions for the given data structures to obtain (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"subsets of the system","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Development of the core structure in model.jl for allowing variations (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"in the different nodes","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Implementation of fallback solutions for source, network, storage,","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"and sink (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Inclusion of availability node for easier distribution of energy in a","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"single geographical node and transfer from one geographical node to the next (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Providing a test case that can be used for playing around with the simple","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"system (#1)","category":"page"},{"location":"manual/NEWS/#Version-0.1.0-(2021-03-19)","page":"Release notes","title":"Version 0.1.0 (2021-03-19)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Initial (skeleton) version","category":"page"},{"location":"#EnergyModelsBase.jl","page":"Home","title":"EnergyModelsBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EnergyModelsBase is an operational, multi nodal energy system model, written in Julia. The model is based on the JuMP optimization framework. It is a multi carrier energy model, where the definition of the carriers are fully up to the user of the model. One of the primary design goals was to develop a model that can easily be extended with new functionalities without the need to understand and remember every variable and constraint in the model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For running a basic energy system model, only the base technology package EnergyModelsBase and the time structure package TimeStruct are needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main package provides simple descriptions for energy sources, sinks, conversion, and storage units. It corresponds to an operational model without geographic features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other packages can the optionally be added if specific functionality or technology nodes are needed. The most important packages are","category":"page"},{"location":"","page":"Home","title":"Home","text":"EnergyModelsGeography:  this package makes it possible to easily extend your energy model with different  geographic areas, where transmission can be set to allow for the transport of  resources between the different areas.\nEnergyModelsInvestments:  this package implements functionality for investments, where the length of the  investment periods are fully flexible and is decided by setting the time  structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Open Packages implementing technology specific nodes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"EnergyModelsRenewableProducers: implements NonDisRES for intermittent (Non-Dispatchable) Renewable Energy Sources and HydroStor modeling a regulated hydro storage plant as well as PumpedHydroStor modelling a pumped hydro storage plant.","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"manual/quick-start.md\",\n    \"manual/philosophy.md\",\n    \"manual/optimization-variables.md\",\n    \"manual/constraint-functions.md\",\n    \"manual/data-functions.md\",\n    \"manual/simple-example.md\",\n]","category":"page"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"library/public.md\",\n    \"library/internals/reference.md\",\n]","category":"page"},{"location":"library/public/#sec_lib_public","page":"Public","title":"Public interface","text":"","category":"section"},{"location":"library/public/#Module","page":"Public","title":"Module","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"EnergyModelsBase","category":"page"},{"location":"library/public/#EnergyModelsBase","page":"Public","title":"EnergyModelsBase","text":"Main module for EnergyModelsBase a framework for building flexible energy system models.\n\nIt exports several types and associated functions for accessing fields. In addition, all required functions for creaeting and running the model are exported.\n\nYou can find the exported types and functions below or on the pages Constraint functions and Data functions.\n\n\n\n\n\n","category":"module"},{"location":"library/public/#Resources","page":"Public","title":"Resources","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Resources correspond to the mass/energy that is converted or transported within an energy system. Resources are discrete, that is they do not have as default additional variables, e.g. pressure or temperature, associated with them. Instead, they are implemented through flows and levels, as explained in Optimization variables.","category":"page"},{"location":"library/public/#Resource-types","page":"Public","title":"Resource types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following resources are implemented in EnergyModelsBase. EnergyModelsBase differentiates between ResourceCarrier and ResourceEmit resources. The key difference between both is that ResourceEmit resources can have emissions, e.g., CO₂ or methane. Emissions are accounted for and can have either a cap and/or a price associated with them.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"One important field for a resource is the CO₂ intensity (co2_int). CO₂ is handled differently than other emissions as the emissions are fundamental properties of a fuel based on the carbon content.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Resource\nResourceCarrier\nResourceEmit","category":"page"},{"location":"library/public/#EnergyModelsBase.Resource","page":"Public","title":"EnergyModelsBase.Resource","text":"General resource supertype to be used for the declaration of subtypes.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.ResourceCarrier","page":"Public","title":"EnergyModelsBase.ResourceCarrier","text":"Resources that can be transported and converted. These resources cannot be included as resources that are emitted, e.g, in the variable textttemissions_strategic.\n\nFields\n\nid is the name/identifyer of the resource.\nco2_int::T is the the CO₂ intensity, e.g., t/MWh.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.ResourceEmit","page":"Public","title":"EnergyModelsBase.ResourceEmit","text":"Resources that can can be emitted (e.g., CO₂, CH₄, NOₓ).\n\nThese resources can be included as resources that are emitted, e.g, in the variable textttemissions_strategic.\n\nFields\n\nid is the name/identifyer of the resource.\nco2_int::T is the the CO₂ intensity, e.g., t/MWh.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Functions-for-accessing-fields-of-Resource-types","page":"Public","title":"Functions for accessing fields of Resource types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following functions are declared for accessing fields from a Resource type. If you want to introduce new Resource types, it is important that this function are either functional for your new types or you have to declare a corresponding function.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"co2_int","category":"page"},{"location":"library/public/#EnergyModelsBase.co2_int","page":"Public","title":"EnergyModelsBase.co2_int","text":"co2_int(p::Resource)\n\nReturns the CO₂ intensity of resource p\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Nodes","page":"Public","title":"Nodes","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Nodes are used in EnergyModelsBase to convert Resources. They are coupled to the rest of the system through the Flow variables. Nodes are the key types for extending EnergyModelsBase through dispatch. You can find an introduction of the different node types on the page Creating a new node","category":"page"},{"location":"library/public/#Abstract-Node-types","page":"Public","title":"Abstract Node types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following abstract node types are implemented in the EnergyModelsBase. These abstract types are relevant for dispatching in individual functions.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Source\nNetworkNode\nSink\nStorage\nAvailability","category":"page"},{"location":"library/public/#EnergyModelsBase.Source","page":"Public","title":"EnergyModelsBase.Source","text":"Source node with only output.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.NetworkNode","page":"Public","title":"EnergyModelsBase.NetworkNode","text":"NetworkNode node with both input and output.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.Sink","page":"Public","title":"EnergyModelsBase.Sink","text":"Sink node with only input.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.Storage","page":"Public","title":"EnergyModelsBase.Storage","text":"Storage node with level.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.Availability","page":"Public","title":"EnergyModelsBase.Availability","text":"Availability node as routing node.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#sec_lib_public_refnodes","page":"Public","title":"Reference node types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following composite types are inmplemented in the EnergyModelsBase. They can be used for describing a simple energy system without any non-linear or binary based expressions. Hence, there are, e.g., no operation point specific efficiencies implemented.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"RefSource\nRefNetworkNode\nRefSink\nRefStorage\nGenAvailability","category":"page"},{"location":"library/public/#EnergyModelsBase.RefSource","page":"Public","title":"EnergyModelsBase.RefSource","text":"A reference Source node.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variational operational costs per energy unit produced.\nopex_fixed::TimeProfile is the fixed operational costs.\noutput::Dict{Resource, Real} are the generated Resources with conversion value Real.\ndata::Array{Data} is the additional data (e.g. for investments).\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.RefNetworkNode","page":"Public","title":"EnergyModelsBase.RefNetworkNode","text":"A reference NetworkNode node.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variational operational costs per energy unit produced.\nopex_fixed::TimeProfile is the fixed operational costs.\ninput::Dict{Resource, Real} are the input Resources with conversion value Real.\noutput::Dict{Resource, Real} are the generated Resources with conversion value Real.\ndata::Array{Data} is the additional data (e.g. for investments).\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.RefSink","page":"Public","title":"EnergyModelsBase.RefSink","text":"A reference Sink node.\n\nThis node corresponds to a demand given by the field cap.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the Demand.\npenalty::Dict{Any, TimeProfile} are penalties for surplus or deficits. Requires the fields :surplus and :deficit.\ninput::Dict{Resource, Real} are the input Resources with conversion value Real.\ndata::Array{Data} is the additional data (e.g. for investments).\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.RefStorage","page":"Public","title":"EnergyModelsBase.RefStorage","text":"A reference Storage node.\n\nThis node is designed to store either a ResourceCarrier or a ResourceEmit. It is designed as a composite type to automatically distinguish between these two.\n\nFields\n\nid is the name/identifier of the node.\nrate_cap::TimeProfile is the installed rate capacity, that is e.g. power or mass flow.\nstor_cap::TimeProfile is the installed storage capacity, that is e.g. energy or mass.\nopex_var::TimeProfile is the variational operational costs per energy unit stored.\nopex_fixed::TimeProfile is the fixed operational costs.\nstor_res::Resource is the stored Resource.\ninput::Dict{Resource, Real} are the input Resources with conversion value Real.\noutput::Dict{Resource, Real} are the generated Resources with conversion value Real. Only relevant for linking and the stored Resource.\ndata::Array{Data} is the additional data (e.g. for investments).\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.GenAvailability","page":"Public","title":"EnergyModelsBase.GenAvailability","text":"A reference Availability node.\n\nFields\n\nid is the name/identifier of the node.\ninputs::Array{Resource} are the input Resources.\noutput::Array{Resource} are the output Resources.\n\nA constructor is provided so that only a single array can be provided with the fields:\n\nid is the name/identifier of the node.\n𝒫::Array{Resource} are the Resources.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#functions_fields_node","page":"Public","title":"Functions for accessing fields of Node types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following functions are declared for accessing fields from a Node type.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"warning: Warning\nIf you want to introduce new Node types, it is important that these functions are either functional for your new types or you have to declare corresponding functions. The first approach can be achieved through using the same name for the respective fields.The functions storage_resource is only required for Storage nodes, when you plan to use the implemented constraint function constraints_flow_in. The functions surplus_penalty and deficit_penalty are only required for Sink nodes if you plan to use the implemented constraint function constraints_opex_var.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"capacity\nopex_var\nopex_fixed\ninputs\noutputs\nnode_data\nstorage_resource\nsurplus_penalty\ndeficit_penalty","category":"page"},{"location":"library/public/#EnergyModelsBase.capacity","page":"Public","title":"EnergyModelsBase.capacity","text":"capacity(n)\n\nReturns the capacity of a node n as TimeProfile. In the case of a Storage node, the capacity is returned as NamedTuple with the fields level and rate.\n\n\n\n\n\ncapacity(n, t)\n\nReturns the capacity of a node n at time period t. In the case of a Storage node, the capacity is returned as NamedTuple with the fields level and rate.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.opex_var","page":"Public","title":"EnergyModelsBase.opex_var","text":"opex_var(n)\n\nReturns the variable OPEX of a node n as TimeProfile.\n\n\n\n\n\nopex_var(n, t)\n\nReturns the variable OPEX of a node n at time period t\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.opex_fixed","page":"Public","title":"EnergyModelsBase.opex_fixed","text":"opex_fixed(n)\n\nReturns the fixed OPEX of a node n as TimeProfile.\n\n\n\n\n\nopex_fixed(n, t)\n\nReturns the fixed OPEX of a node n at time period t\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.inputs","page":"Public","title":"EnergyModelsBase.inputs","text":"inputs(n)\n\nReturns the input resources of a node n. These resources are specified via the field input.\n\n\n\n\n\ninputs(n, p)\n\nReturns the value of an input resource p of a node n.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.outputs","page":"Public","title":"EnergyModelsBase.outputs","text":"outputs(n)\n\nReturns the output resources of a node n. These resources are specified via the field output.\n\n\n\n\n\noutputs(n, p)\n\nReturns the value of an output resource p of a node n.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.node_data","page":"Public","title":"EnergyModelsBase.node_data","text":"node_data(n::Node)\n\nReturns the Data array of node n.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.storage_resource","page":"Public","title":"EnergyModelsBase.storage_resource","text":"storage_resource(n::Storage)\n\nReturns the storage resource of Storage node n.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.surplus_penalty","page":"Public","title":"EnergyModelsBase.surplus_penalty","text":"surplus_penalty(n::Sink)\n\nReturns the surplus penalty of sink n as TimeProfile.\n\n\n\n\n\nsurplus_penalty(n::Sink, t)\n\nReturns the surplus penalty of sink n at time period t\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.deficit_penalty","page":"Public","title":"EnergyModelsBase.deficit_penalty","text":"deficit_penalty(n::Sink)\n\nReturns the deficit penalty of sink n as TimeProfile.\n\n\n\n\n\ndeficit_penalty(n::Sink, t)\n\nReturns the deficit penalty of sink n at time period t\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Functions-for-identifying-Nodes","page":"Public","title":"Functions for identifying Nodes","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following functions are declared for filtering on Node types.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"warning: Warning\nIf you want to introduce new Node types, it is important that the functions has_input, has_output, and has_emissions are either functional for your new types or you have to declare corresponding functions. The first approach can be achieved through using the same name for the respective fields.The functions nodes_input, nodes_output, and nodes_emissions are not used in the model as they are replaced by the build in filter function as, e.g., filter(has_input, 𝒩). In practice, they provide a pre-defined approach for filtering nodes and do not require additional modifications. They can be used in potential extensions.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"nodes_input\nnodes_output\nnodes_emissions\nhas_input\nhas_output\nhas_emissions","category":"page"},{"location":"library/public/#EnergyModelsBase.nodes_input","page":"Public","title":"EnergyModelsBase.nodes_input","text":"nodes_input(𝒩::Array{Node}, sub)\n\nReturn nodes that have an input, i.e., Sink and NetworkNode nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.nodes_output","page":"Public","title":"EnergyModelsBase.nodes_output","text":"nodes_output(𝒩::Array{Node})\n\nReturn nodes that have an output, i.e., Source and NetworkNode nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.nodes_emissions","page":"Public","title":"EnergyModelsBase.nodes_emissions","text":"has_emissions(𝒩::Array{Node})\n\nReturn nodes that have emission data for a given Array ::Array{Node}.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.has_input","page":"Public","title":"EnergyModelsBase.has_input","text":"has_input(n::Node)\n\nReturn logic whether the node is an input node, i.e., Sink and NetworkNode nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.has_output","page":"Public","title":"EnergyModelsBase.has_output","text":"has_output(n::Node)\n\nReturn logic whether the node is an output node, i.e., Source and NetworkNode nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.has_emissions","page":"Public","title":"EnergyModelsBase.has_emissions","text":"has_emissions(n::Node)\n\nChecks whether the Node n has emissions.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Legacy-constructors","page":"Public","title":"Legacy constructors","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following legacy constructors are implemented to avoid changing each individual model after updates in the core structure. It is however uncertain, how long they will remain in the model. To this end, it is suggest to adjust them with the reference nodes described above.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"RefNetwork\nRefNetworkEmissions\nRefStorageEmissions","category":"page"},{"location":"library/public/#EnergyModelsBase.RefNetwork","page":"Public","title":"EnergyModelsBase.RefNetwork","text":"Legacy constructor for a RefNetwork node. This version will be discontinued in the near future. its new name is given by RefNetworkNode.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.RefNetworkEmissions","page":"Public","title":"EnergyModelsBase.RefNetworkEmissions","text":"Legacy constructor for a RefNetworkEmissions node. This version will be discontinued in the near future and replaced with the new implementation of data and the application of RefNetworkNode.\n\nSee the documentation for further information. In this case, the emission data can be implemented by the new EmissionsData type CaptureEnergyEmissions.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.RefStorageEmissions","page":"Public","title":"EnergyModelsBase.RefStorageEmissions","text":"Legacy constructor for a RefStorageEmissions. This version will be discontinued in the near future and replaced with the new version of RefStorage.\n\nSee the documentation for further information. In this case, the key difference is that it uses now a parametric type instead of a standard composite type to differentiate between the storage of ResourceCarrier or ResourceEmit\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Links","page":"Public","title":"Links","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Links are connecting the individual Nodes for the exchange of energy/mass. Links are directional, that is transport of mass/energy is only allowed in a single direction.","category":"page"},{"location":"library/public/#Link-types","page":"Public","title":"Link types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following types for links are implemented in EnergyModelsBase. The thought process is to dispatch on the EMB.Formulation of a link as additional option. This is in the current stage not implemented.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Link\nDirect\nLinear","category":"page"},{"location":"library/public/#EnergyModelsBase.Link","page":"Public","title":"EnergyModelsBase.Link","text":"Declaration of the general type for links connecting nodes.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.Direct","page":"Public","title":"EnergyModelsBase.Direct","text":"Direct <: Link\n\nA direct link between two nodes.\n\nFields\n\nid is the name/identifier of the link.\nfrom::Node is node from which there is flow into the link.\nto::Node is node to which there is flow out of the link.\nformulation::Formulation is the used formulation of links. If not specified, a Linear link is assumed.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.Linear","page":"Public","title":"EnergyModelsBase.Linear","text":"Linear Formulation, that is input equals output.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Functions-for-accessing-fields-of-Link-types","page":"Public","title":"Functions for accessing fields of Link types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following functions are declared for accessing fields from a Link type.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"warning: Warning\nIf you want to introduce new Link types, it is important that the function formulation is either functional for your new types or you have to declare a corresponding function. The first approach can be achieved through using the same name for the respective fields.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"formulation","category":"page"},{"location":"library/public/#EnergyModelsBase.formulation","page":"Public","title":"EnergyModelsBase.formulation","text":"formulation(l::Link)\n\nReturn the formulation of a Link ´l´.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Model-and-data","page":"Public","title":"Model and data","text":"","category":"section"},{"location":"library/public/#EnergyModel-and-Data-types","page":"Public","title":"EnergyModel and Data types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The type EnergyModel is used for creating the global parameters of a model. It can be as well used for extending EnergyModelsBase as described in the section Extensions to the model. EnergyModelsBase only provides an OperationalModel while InvestmentModel is added through the extension EnergyModelsInvestments","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"EnergyModel\nOperationalModel","category":"page"},{"location":"library/public/#EnergyModelsBase.EnergyModel","page":"Public","title":"EnergyModelsBase.EnergyModel","text":"Abstract type for differentation between types of models (investment, operational, ...).\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.OperationalModel","page":"Public","title":"EnergyModelsBase.OperationalModel","text":"Operational Energy Model without investments.\n\nFields\n\nemission_limit is a dictionary with individual emission limits as TimeProfile for each emission resource ResourceEmit.\nemission_price::Dict{ResourceEmit, TimeProfile} are the prices for the different emissions types considered.\nco2_instance is a ResourceEmit and corresponds to the type used for CO₂.\n\n\n\n\n\n","category":"type"},{"location":"library/public/","page":"Public","title":"Public","text":"In addition, the following Data types are introduced for introducing additional parameters, variables, and constraints to the Nodes. The approach of using the data field of Nodes is explained on the page Data functions. EmptyData is no longer relevant for the modelling, but it is retained for avoiding any problems with existing models.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Data\nEmptyData","category":"page"},{"location":"library/public/#EnergyModelsBase.Data","page":"Public","title":"EnergyModelsBase.Data","text":"Abstract type used to define concrete struct containing the package specific elements to add to the composite type defined in this package.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.EmptyData","page":"Public","title":"EnergyModelsBase.EmptyData","text":"Empty composite type for Data\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Functions-for-accessing-fields-of-EnergyModel-types","page":"Public","title":"Functions for accessing fields of EnergyModel types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following functions are declared for accessing fields from a EnergyModel type.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"warning: Warning\nIf you want to introduce new EnergyModel types, it is important that the functions emission_limit, emission_price, and co2_instance are either functional for your new types or you have to declare corresponding functions. The first approach can be achieved through using the same name for the respective fields.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"emission_limit\nemission_price\nco2_instance","category":"page"},{"location":"library/public/#EnergyModelsBase.emission_limit","page":"Public","title":"EnergyModelsBase.emission_limit","text":"emission_limit(model)\n\nReturns the emission limit of EnergyModel model as dictionary with TimeProfiles for each ResourceEmit.\n\n\n\n\n\nemission_limit(model, p)\n\nReturns the emission limit of EnergyModel model and ResourceEmit p as TimeProfile.\n\n\n\n\n\nemission_limit(model, p, t)\n\nReturns the emission limit of EnergyModel model and ResourceEmit p in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.emission_price","page":"Public","title":"EnergyModelsBase.emission_price","text":"emission_price(model)\n\nReturns the emission price of EnergyModel model as dictionary with TimeProfiles for each ResourceEmit.\n\n\n\n\n\nemission_price(model, p)\n\nReturns the emission price of EnergyModel model and ResourceEmit p as TimeProfile. If no emission price is specified for the ResourceEmit p, the function returns 0\n\n\n\n\n\nemission_price(model, p, t)\n\nReturns the emission price of EnergyModel model and ResourceEmit p in operational period t. If no emission price is specified for the ResourceEmit p, the function returns 0\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.co2_instance","page":"Public","title":"EnergyModelsBase.co2_instance","text":"co2_instance(model)\n\nReturns the CO₂ instance used in modelling.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Functions-for-running-the-model","page":"Public","title":"Functions for running the model","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following functions are provided for both creating a model using EnergyModelsBase and solving said model. Both functions have the input case and model. run_model calls create_model in the function, hence, it is not necessary to call the function beforehand.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"The case dictionary has to follow a certain outline. In this case, it is simplest to look at the provided examples.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"note: Note\nWe are currently debating to replace the dictionary used for case as well with a composite type.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"This will lead to breacking changes, but should be simple to adjust for.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"create_model\nrun_model","category":"page"},{"location":"library/public/#EnergyModelsBase.create_model","page":"Public","title":"EnergyModelsBase.create_model","text":"create_model(case, modeltype::EnergyModel)\n\nCreate the model and call all required functions based on provided modeltype and case data.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.run_model","page":"Public","title":"EnergyModelsBase.run_model","text":"run_model(case::Dict, optimizer)\n\nTake the case data as a dictionary and build and optimize the model.\n\nThe dictionary requires the keys:\n\n:nodes::Vector{Node}\n:links::Vector{Link}\n:products::Vector{Resource}\n:T::TimeStructure\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Functions-for-extending-the-model","page":"Public","title":"Functions for extending the model","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following functions are used for developing new nodes. See the page Creating a new node for a detailed explanation on how to create a new node.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"variables_node\ncreate_node","category":"page"},{"location":"library/public/#EnergyModelsBase.variables_node","page":"Public","title":"EnergyModelsBase.variables_node","text":"\"     variables_node(m, 𝒩ˢᵘᵇ::Vector{<:Node}, 𝒯, modeltype::EnergyModel)\n\nDefault fallback method when no function is defined for a node type.\n\n\n\n\n\nvariables_node(m, 𝒩ˢⁱⁿᵏ::Vector{<:Sink}, 𝒯, modeltype::EnergyModel)\n\nDeclaration of both surplus (:sink_surplus) and deficit (:sink_deficit) variables for Sink nodes 𝒩ˢⁱⁿᵏ to quantify when there is too much or too little energy for satisfying the demand.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.create_node","page":"Public","title":"EnergyModelsBase.create_node","text":"create_node(m, n::Source, 𝒯, 𝒫, modeltype::EnergyModel)\n\nSet all constraints for a Source. Can serve as fallback option for all unspecified subtypes of Source.\n\n\n\n\n\ncreate_node(m, n::NetworkNode, 𝒯, 𝒫, modeltype::EnergyModel)\n\nSet all constraints for a NetworkNode. Can serve as fallback option for all unspecified subtypes of NetworkNode.\n\n\n\n\n\ncreate_node(m, n::Storage, 𝒯, 𝒫, modeltype::EnergyModel)\n\nSet all constraints for a Storage. Can serve as fallback option for all unspecified subtypes of Storage.\n\n\n\n\n\ncreate_node(m, n::Sink, 𝒯, 𝒫, modeltype::EnergyModel)\n\nSet all constraints for a Sink. Can serve as fallback option for all unspecified subtypes of Sink.\n\n\n\n\n\ncreate_node(m, n::Availability, 𝒯, 𝒫, modeltype::EnergyModel)\n\nSet all constraints for a Availability. Can serve as fallback option for all unspecified subtypes of Availability.\n\nAvailability nodes can be seen as routing nodes. It is not necessary to have more than one available node except if one wants to include as well transport between different availability nodes with associated costs (not implemented at the moment).\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Constraint-functions","page":"Public","title":"Constraint functions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following functions can be used in new developed nodes to include constraints. See the pages Constraint functions and Data functions for a detailed explanation on their usage.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"warning: Warning\nThe function constraints_capacity_installed should not be changed. It is used for the inclusion of investments through EnergyModelsInvestments. It also has to be called, if you create a new function constraints_capacity.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"constraints_flow_in\nconstraints_flow_out\nconstraints_capacity\nconstraints_capacity_installed\nconstraints_level\nconstraints_opex_var\nconstraints_opex_fixed\nconstraints_data","category":"page"},{"location":"library/public/#EnergyModelsBase.constraints_flow_in","page":"Public","title":"EnergyModelsBase.constraints_flow_in","text":"constraints_flow_in(m, n, 𝒯::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the inlet flow to a generic Node. This function serves as fallback option if no other function is specified for a Node.\n\n\n\n\n\nconstraints_flow_in(m, n::Storage, 𝒯::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the inlet flow to a generic Storage. This function serves as fallback option if no other function is specified for a Storage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.constraints_flow_out","page":"Public","title":"EnergyModelsBase.constraints_flow_out","text":"constraints_flow_out(m, n, 𝒯::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the outlet flow from a generic Node. This function serves as fallback option if no other function is specified for a Node.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.constraints_capacity","page":"Public","title":"EnergyModelsBase.constraints_capacity","text":"constraints_capacity(m, n::Node, 𝒯::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the maximum capacity of a generic Node. This function serves as fallback option if no other function is specified for a Node.\n\n\n\n\n\nconstraints_capacity(m, n::Storage, 𝒯::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the maximum level of a generic Storage. This function serves as fallback option if no other function is specified for a Storage.\n\n\n\n\n\nconstraints_capacity(m, n::Sink, 𝒯::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the maximum capacity of a generic Sink. This function serves as fallback option if no other function is specified for a Sink.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.constraints_capacity_installed","page":"Public","title":"EnergyModelsBase.constraints_capacity_installed","text":"constraints_capacity_installed(m, n, 𝒯::TimeStructure, modeltype::EnergyModel)\n\nIn general, it is prefered to have the capacity as a function of a variable given with a value of 1 in the field n.Cap.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.constraints_level","page":"Public","title":"EnergyModelsBase.constraints_level","text":"constraints_level(m, n::Storage, 𝒯, 𝒫, modeltype::EnergyModel)\n\nFunction for creating the level constraint for a reference storage node with a ResourceCarrier resource.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.constraints_opex_var","page":"Public","title":"EnergyModelsBase.constraints_opex_var","text":"constraints_opex_var(m, n::Node, 𝒯ᴵⁿᵛ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the variable OPEX of a generic Node. This function serves as fallback option if no other function is specified for a Node.\n\n\n\n\n\nconstraints_opex_var(m, n::Storage, 𝒯ᴵⁿᵛ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the variable OPEX of a generic Storage. This function serves as fallback option if no other function is specified for a Storage.\n\n\n\n\n\nconstraints_opex_var(m, n::RefStorage{T}, 𝒯ᴵⁿᵛ, modeltype::EnergyModel) where {T<:ResourceEmit}\n\nFunction for creating the constraint on the variable OPEX of a RefStorage{ResourceEmit}.\n\n\n\n\n\nconstraints_opex_var(m, n::Sink, 𝒯ᴵⁿᵛ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the variable OPEX of a generic Sink. This function serves as fallback option if no other function is specified for a Sink.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.constraints_opex_fixed","page":"Public","title":"EnergyModelsBase.constraints_opex_fixed","text":"constraints_opex_fixed(m, n::Node, 𝒯ᴵⁿᵛ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the fixed OPEX of a generic Node. This function serves as fallback option if no other function is specified for a Node.\n\n\n\n\n\nconstraints_opex_fixed(m, n::Storage, 𝒯ᴵⁿᵛ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the fixed OPEX of a generic Storage. This function serves as fallback option if no other function is specified for a Storage.\n\n\n\n\n\nconstraints_opex_fixed(m, n::Storage, 𝒯ᴵⁿᵛ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the fixed OPEX of a generic Storage. This function serves as fallback option if no other function is specified for a Storage.\n\n\n\n\n\nconstraints_opex_fixed(m, n::Sink, 𝒯ᴵⁿᵛ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the fixed OPEX of a generic Sink. This function serves as fallback option if no other function is specified for a Sink.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.constraints_data","page":"Public","title":"EnergyModelsBase.constraints_data","text":"constraints_data(m, n::Node, 𝒯, 𝒫, modeltype, data::DataEmissions)\n\nConstraints functions for calculating both the emissions and amount of CO₂ captured in the process.\n\nThere exist several configurations:\n\nEmissionsEnergy: Only energy usage related emissions.\nEmissionsProcess: Both process and energy usage related emissions.\nCaptureEnergyEmissions: Capture of energy usage related emissions, can include\n\nprocess emissions.\n\nCaptureProcessEmissions: Capture of process emissions.\nCaptureProcessEnergyEmissions: Capture of both process and energy usage related\n\nemissions.\n\n\n\n\n\nconstraints_data(m, n::Node, 𝒯, 𝒫, modeltype, data::Data)\n\nFallback option when data is specified, but it is not desired to add the constraints through this function. This is, e.g., the case for EnergyModelsInvestments as the capacity constraint has to be replaced\n\n\n\n\n\n","category":"function"},{"location":"library/public/#sec_lib_public_emdata","page":"Public","title":"Emission data","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Emission data are used to provide the individual nodes with potential emissions. The approach is also explained on the page Data functions.","category":"page"},{"location":"library/public/#Emission-types","page":"Public","title":"Emission types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The thought process with EmissionData is to provide the user with options for each individual node to include emissions and potentially capture or not. The individual types can be used for all included reference Nodes, although capture is not possible for Sink nodes due to the lack of an output.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"EmissionsData\nCaptureData\nEmissionsEnergy\nEmissionsProcess\nCaptureEnergyEmissions\nCaptureProcessEmissions\nCaptureProcessEnergyEmissions","category":"page"},{"location":"library/public/#EnergyModelsBase.EmissionsData","page":"Public","title":"EnergyModelsBase.EmissionsData","text":"EmissionsData as supertype for all Data types for emissions.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.CaptureData","page":"Public","title":"EnergyModelsBase.CaptureData","text":"CaptureData as supertype for all EmissionsData that include CO₂ capture.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.EmissionsEnergy","page":"Public","title":"EnergyModelsBase.EmissionsEnergy","text":"No capture, no process emissions are present. Does not require co2_capture or emissions as input, but accepts it and will ignore it, if provided.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.EmissionsProcess","page":"Public","title":"EnergyModelsBase.EmissionsProcess","text":"No capture, but process emissions are present. Does not require co2_capture as input, but accepts it and will ignore it, if provided.\n\nFields\n\nemissions::Dict{ResourceEmit, T}: emissions per unit produced.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.CaptureEnergyEmissions","page":"Public","title":"EnergyModelsBase.CaptureEnergyEmissions","text":"Capture the energy usage related emissions, but not the process emissions. Does not require emissions as input, but can be supplied.\n\nFields\n\nemissions::Dict{ResourceEmit, T}: emissions per unit produced.\nco2_capture::Float64 is the CO₂ capture rate.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.CaptureProcessEmissions","page":"Public","title":"EnergyModelsBase.CaptureProcessEmissions","text":"Capture the process emissions, but not the energy usage related emissions.\n\nFields\n\nemissions::Dict{ResourceEmit, T}: emissions per unit produced.\nco2_capture::Float64 is the CO₂ capture rate.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsBase.CaptureProcessEnergyEmissions","page":"Public","title":"EnergyModelsBase.CaptureProcessEnergyEmissions","text":"Capture both the process emissions and the energy usage related emissions.\n\nFields\n\nemissions::Dict{ResourceEmit, T}: emissions per unit produced.\nco2_capture::Float64 is the CO₂ capture rate.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Functions-for-accessing-fields-of-EmissionsData-types","page":"Public","title":"Functions for accessing fields of EmissionsData types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following functions are declared for accessing fields from a EmissionsData type.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"warning: Warning\nIf you want to introduce new EmissionsData types, it is important that the functions co2_capture and process_emissions are either functional for your new types or you have to declare corresponding functions. The first approach can be achieved through using the same name for the respective fields.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"co2_capture\nprocess_emissions","category":"page"},{"location":"library/public/#EnergyModelsBase.co2_capture","page":"Public","title":"EnergyModelsBase.co2_capture","text":"co2_capture(data::CaptureData)\n\nReturns the CO₂ capture rate of the data.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsBase.process_emissions","page":"Public","title":"EnergyModelsBase.process_emissions","text":"process_emissions(data::EmissionsData)\n\nReturns the ResourceEmits that have process emissions in the data.\n\n\n\n\n\nprocess_emissions(data::EmissionsData, p)\n\nReturns the the process emissions of resource p in the data as TimeProfile. If the process emissions are provided as Float64, it returns a FixedProfile(x). If there are no process emissions, it returns a FixedProfile(0).\n\n\n\n\n\nprocess_emissions(data::EmissionsData, p, t)\n\nReturns the the process emissions of resource p in the data at operational period t. If there are no process emissions, it returns a value of 0.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Miscellaneous-functions/macros","page":"Public","title":"Miscellaneous functions/macros","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"@assert_or_log","category":"page"},{"location":"library/public/#EnergyModelsBase.@assert_or_log","page":"Public","title":"EnergyModelsBase.@assert_or_log","text":"assert_or_log(ex, msg)\n\nMacro that extends the behaviour of the @assert macro. The switch ASSERTS_AS_LOG, controls if the macro should act as a logger or a normal @assert. This macro is designed to be used to check whether the data provided is consistent.\n\n\n\n\n\n","category":"macro"}]
}
