<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Storage ¬∑ EnergyModelsBase</title><meta name="title" content="Storage ¬∑ EnergyModelsBase"/><meta property="og:title" content="Storage ¬∑ EnergyModelsBase"/><meta property="twitter:title" content="Storage ¬∑ EnergyModelsBase"/><meta name="description" content="Documentation for EnergyModelsBase."/><meta property="og:description" content="Documentation for EnergyModelsBase."/><meta property="twitter:description" content="Documentation for EnergyModelsBase."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">EnergyModelsBase</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/quick-start/">Quick Start</a></li><li><a class="tocitem" href="../../manual/philosophy/">Philosophy</a></li><li><a class="tocitem" href="../../manual/optimization-variables/">Optimization variables</a></li><li><a class="tocitem" href="../../manual/constraint-functions/">Constraint functions</a></li><li><a class="tocitem" href="../../manual/data-functions/">ExtensionData functions</a></li><li><a class="tocitem" href="../../manual/simple-example/">Example</a></li><li><a class="tocitem" href="../../manual/investments/">Investment options</a></li><li><a class="tocitem" href="../../manual/NEWS/">Release notes</a></li></ul></li><li><span class="tocitem">Nodes</span><ul><li><a class="tocitem" href="../source/">Source</a></li><li><a class="tocitem" href="../networknode/">NetworkNode</a></li><li class="is-active"><a class="tocitem" href>Storage</a><ul class="internal"><li><a class="tocitem" href="#nodes-storage-phil"><span>Philosophy of Storage nodes</span></a></li><li><a class="tocitem" href="#nodes-storage-fields"><span>Introduced type and its fields</span></a></li><li><a class="tocitem" href="#nodes-storage-math"><span>Mathematical description</span></a></li></ul></li><li><a class="tocitem" href="../sink/">Sink</a></li><li><a class="tocitem" href="../availability/">Availability</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../how-to/create_new_element/">Create a new element</a></li><li><a class="tocitem" href="../../how-to/create-new-node/">Create a new node</a></li><li><a class="tocitem" href="../../how-to/utilize-timestruct/">Utilize TimeStruct</a></li><li><a class="tocitem" href="../../how-to/update-models/">Update models</a></li><li><a class="tocitem" href="../../how-to/contribute/">Contribute to EnergyModelsBase</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/public/resources/">Resources</a></li><li><a class="tocitem" href="../../library/public/model_data/">Modeltype and ExtensionData</a></li><li><a class="tocitem" href="../../library/public/nodes/">Nodes</a></li><li><a class="tocitem" href="../../library/public/links/">Links</a></li><li><a class="tocitem" href="../../library/public/case_element/">Case</a></li><li><a class="tocitem" href="../../library/public/functions/">Functions</a></li><li><a class="tocitem" href="../../library/public/misc/">Miscellaneous</a></li><li><a class="tocitem" href="../../library/public/emi_extension/">EMI extension</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Internal</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/internals/types/">Types</a></li><li><a class="tocitem" href="../../library/internals/functions/">Functions</a></li><li><a class="tocitem" href="../../library/internals/reference_EMIExt/">EMI extension</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Nodes</a></li><li class="is-active"><a href>Storage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Storage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/EnergyModelsX/EnergyModelsBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/EnergyModelsX/EnergyModelsBase.jl/blob/main/docs/src/nodes/storage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="nodes-storage"><a class="docs-heading-anchor" href="#nodes-storage">Storage</a><a id="nodes-storage-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-storage" title="Permalink"></a></h1><p><a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a> nodes are subtypes of <a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a> as they have in general an input and output (except for permanent CO‚ÇÇ storage). Storages require additional variables and parameters. As a consequence, a new abstract type is specified.</p><h2 id="nodes-storage-phil"><a class="docs-heading-anchor" href="#nodes-storage-phil">Philosophy of Storage nodes</a><a id="nodes-storage-phil-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-storage-phil" title="Permalink"></a></h2><p><a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a> nodes differ from the other nodes as they are designed per default as <em><a href="https://docs.julialang.org/en/v1/manual/types/#man-parametric-composite-types">parametric types</a></em> using the concept of <a href="../../library/internals/types/#EnergyModelsBase.StorageBehavior"><code>EnergyModelsBase.StorageBehavior</code></a>. In addition, capacities and operational expenses are not included at the first level of the composite type, but instead on a lower level.</p><h3 id="nodes-storage-phil-parametric"><a class="docs-heading-anchor" href="#nodes-storage-phil-parametric">Parametric implementation</a><a id="nodes-storage-phil-parametric-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-storage-phil-parametric" title="Permalink"></a></h3><p>The parametric input is not applied for any field, but instead for allowing simplified dispatch on the individual storage behavior of a <a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a> node. As <code>TimeStruct</code>, and hence, <code>EnergyModelsBase</code> supports the inclusion of both representative periods and operational scenarios, it was the aim in the design to provide a reusable approach for calculating the level balances. The structure of the level balance calculation is explained on <em><a href="../../manual/constraint-functions/#man-con-stor_level">Storage level constraints</a></em> while you can find the mathematical description in the Section <em><a href="#nodes-storage-math-con-level">Level constraints</a></em>.</p><p>We differentiate between <a href="../../library/public/nodes/#EnergyModelsBase.Accumulating"><code>Accumulating</code></a> and <a href="../../library/public/nodes/#EnergyModelsBase.Cyclic"><code>Cyclic</code></a> storage behaviors. The former allows for a net change of the storage level within an investment period, while the latter requires a cyclic behavior for the level balance.</p><p>A single concrete type is included for <code>Accumulating</code> using <a href="../../library/public/nodes/#EnergyModelsBase.AccumulatingEmissions"><code>AccumulatingEmissions</code></a>. This type was introduced for <a href="../../library/public/resources/#EnergyModelsBase.ResourceEmit"><code>ResourceEmit</code></a> resources to represent a permanent storage node. It was initially utilized for CO‚ÇÇ storage.</p><p>Two concrete types are included for <a href="../../library/public/nodes/#EnergyModelsBase.Cyclic"><code>Cyclic</code></a>, <a href="../../library/public/nodes/#EnergyModelsBase.CyclicRepresentative"><code>CyclicRepresentative</code></a> and <a href="../../library/public/nodes/#EnergyModelsBase.CyclicStrategic"><code>CyclicStrategic</code></a>. These two types differ only if the time structure includes representative periods. If not, they are equivalent. In the case of inclusion of representative periods, <a href="../../library/public/nodes/#EnergyModelsBase.CyclicRepresentative"><code>CyclicRepresentative</code></a> enforces the cyclic constraint within a representative period while <a href="../../library/public/nodes/#EnergyModelsBase.CyclicStrategic"><code>CyclicStrategic</code></a> enforces the cyclic constraint within the investment period. In the case of <a href="../../library/public/nodes/#EnergyModelsBase.CyclicStrategic"><code>CyclicStrategic</code></a>, we hence allow for a net change in the storage level within a representative period. This net change is then used for the scaling.</p><h3 id="nodes-storage-phil-capacities"><a class="docs-heading-anchor" href="#nodes-storage-phil-capacities">Capacities</a><a id="nodes-storage-phil-capacities-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-storage-phil-capacities" title="Permalink"></a></h3><p>Storage nodes can have up to three capacities, <code>charge</code>, storage <code>level</code>, and <code>discharge</code>. In practice, a storage allways requires a level capacity corresponding to the maximum amount of stored energy. However, it is not necessary to include <code>charge</code> and <code>discharge</code> capacities if they are</p><ol><li>not representing an additional cost and</li><li>it is possible to charge/discharge the storage within a single operational period.</li></ol><p>In this case, the <code>Storage</code> implementation allows the user to specify <a href="../../library/internals/types/#EnergyModelsBase.AbstractStorageParameters"><code>EnergyModelsBase.AbstractStorageParameters</code></a> reflecting the required input. We allow for multiple combinations within <a href="../../library/internals/types/#EnergyModelsBase.AbstractStorageParameters"><code>EnergyModelsBase.AbstractStorageParameters</code></a> containing a capacity, a variable OPEX, and/or a fixed OPEX. This is beneficial for ,<em>e.g.</em>, compressed hydrogen storage in which the charge capacity requires investments in compressors, while the discharge capacity is purely limited by the structural limits.</p><p>The individual types are</p><ul><li><a href="../../library/public/nodes/#EnergyModelsBase.StorCapOpex"><code>StorCapOpex</code></a> - the capacity includes a <strong>capacity</strong> as well as a <strong>fixed</strong> and <strong>variable</strong> OPEX,</li><li><a href="../../library/public/nodes/#EnergyModelsBase.StorCap"><code>StorCap</code></a> - the capacity only includes a <strong>capacity</strong>,</li><li><a href="../../library/public/nodes/#EnergyModelsBase.StorCapOpexVar"><code>StorCapOpexVar</code></a> - the capacity includes a <strong>capacity</strong> as well as a <strong>variable</strong> OPEX,</li><li><a href="../../library/public/nodes/#EnergyModelsBase.StorCapOpexFixed"><code>StorCapOpexFixed</code></a> - the capacity includes a <strong>capacity</strong> as well as a <strong>fixed</strong> variable OPEX, and</li><li><a href="../../library/public/nodes/#EnergyModelsBase.StorOpexVar"><code>StorOpexVar</code></a> - the capacity includes only a <strong>variable</strong> OPEX.</li></ul><p><code>EnergyModelsBase</code> provides although union types for simplifying providing new dispatch. These are <a href="../../library/public/nodes/#EnergyModelsBase.UnionOpexFixed"><code>EnergyModelsBase.UnionOpexFixed</code></a>, <a href="../../library/public/nodes/#EnergyModelsBase.UnionOpexVar"><code>EnergyModelsBase.UnionOpexVar</code></a>, and <a href="../../library/public/nodes/#EnergyModelsBase.UnionCapacity"><code>EnergyModelsBase.UnionCapacity</code></a>.</p><h2 id="nodes-storage-fields"><a class="docs-heading-anchor" href="#nodes-storage-fields">Introduced type and its fields</a><a id="nodes-storage-fields-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-storage-fields" title="Permalink"></a></h2><p>The <a href="../../library/public/nodes/#EnergyModelsBase.RefStorage"><code>RefStorage</code></a> node is implemented as a reference node that can be used for a <a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a>. It includes basic functionalities common to most energy system optimization models.</p><p>The fields of a <a href="../../library/public/nodes/#EnergyModelsBase.RefStorage"><code>RefStorage</code></a> are given as:</p><ul><li><strong><code>id</code></strong>:<br/>The field <code>id</code> is only used for providing a name to the node.</li><li><strong><code>charge::AbstractStorageParameters</code></strong>:<br/>More information can be found on <em><a href="../../library/public/nodes/#lib-pub-nodes-stor_par">storage parameters</a></em>.</li><li><strong><code>level::UnionCapacity</code></strong>:<br/>The level storage parameters must include a capacity. More information can be found on <em><a href="../../library/public/nodes/#lib-pub-nodes-stor_par">storage parameters</a></em>.<div class="admonition is-info" id="Permitted-values-for-storage-parameters-in-charge-and-level-f332c49ede4c08b9"><header class="admonition-header">Permitted values for storage parameters in `charge` and `level`<a class="admonition-anchor" href="#Permitted-values-for-storage-parameters-in-charge-and-level-f332c49ede4c08b9" title="Permalink"></a></header><div class="admonition-body"><p>If the node should contain investments through the application of <a href="https://energymodelsx.github.io/EnergyModelsInvestments.jl/"><code>EnergyModelsInvestments</code></a>, it is important to note that you can only use <code>FixedProfile</code> or <code>StrategicProfile</code> for the capacity, but not <code>RepresentativeProfile</code> or <code>OperationalProfile</code>. Similarly, you can only use <code>FixedProfile</code> or <code>StrategicProfile</code> for the fixed OPEX, but not <code>RepresentativeProfile</code> or <code>OperationalProfile</code>. The variable operating expenses can be provided as <code>OperationalProfile</code> as well. In addition, all capacity and fixed OPEX values have to be non-negative.</p></div></div></li><li><strong><code>stor_res::Resource</code></strong>:<br/>The <code>stor_res</code> is the stored <a href="../../library/public/resources/#EnergyModelsBase.Resource"><code>Resource</code></a>.</li><li><strong><code>input::Dict{&lt;:Resource,&lt;:Real}</code></strong> and <strong><code>output::Dict{&lt;:Resource,&lt;:Real}</code></strong>:<br/>Both fields describe the <code>input</code> and <code>output</code> <a href="../../library/public/resources/#EnergyModelsBase.Resource"><code>Resource</code></a>s with their corresponding conversion factors as dictionaries. The stored <a href="../../library/public/resources/#EnergyModelsBase.Resource"><code>Resource</code></a> (outlined above) must be included in both dictionaries to create the linking variables although its conversion factor is not utilized. All values have to be non-negative.<div class="admonition is-warning" id="Ratios-for-Storage-4beb012158b21866"><header class="admonition-header">Ratios for Storage<a class="admonition-anchor" href="#Ratios-for-Storage-4beb012158b21866" title="Permalink"></a></header><div class="admonition-body"><p>In the current implementation, we do not consider <code>output</code> conversion factors for the outflow from the <a href="../../library/public/nodes/#EnergyModelsBase.RefStorage"><code>RefStorage</code></a> node. Similarly, we do not consider the <code>input</code> conversion factor of the stored resource. Instead, it is assumed that there is no loss of the stored resource in the storage.</p></div></div></li><li><strong><code>data::Vector{ExtensionData}</code></strong>:<br/>An entry for providing additional data to the model. In the current version, it is used for both providing <code>EmissionsData</code> and additional investment data when <a href="https://energymodelsx.github.io/EnergyModelsInvestments.jl/"><code>EnergyModelsInvestments</code></a> is used.<div class="admonition is-info" id="Constructor-for-RefStorage-1ebb7eef2c2ad0d8"><header class="admonition-header">Constructor for `RefStorage`<a class="admonition-anchor" href="#Constructor-for-RefStorage-1ebb7eef2c2ad0d8" title="Permalink"></a></header><div class="admonition-body"><p>The field <code>data</code> is not required as we include a constructor when the value is excluded.</p></div></div></li></ul><div class="admonition is-danger" id="Discharge-values-for-RefStorage-acc9e5e3a32a21b4"><header class="admonition-header">Discharge values for `RefStorage`<a class="admonition-anchor" href="#Discharge-values-for-RefStorage-acc9e5e3a32a21b4" title="Permalink"></a></header><div class="admonition-body"><p><a href="../../library/public/nodes/#EnergyModelsBase.RefStorage"><code>RefStorage</code></a> nodes do <strong>not</strong> include a discharge capacity or corresponding operating expenses. Instead, it is possible to empty the storage within a single operational period. If you need to specify a discharge capacity (or want to implement it as a ratio to the charge capacity), you have to create a new <a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a> type. This is explain on <em><a href="../../how-to/create-new-node/#how_to-create_node-adv">Advanced creation of new nodes</a></em>.</p><p>In practice, the key change would be to provide an additional field called <code>discharge</code> to the new <code>Storage</code> type.</p></div></div><h2 id="nodes-storage-math"><a class="docs-heading-anchor" href="#nodes-storage-math">Mathematical description</a><a id="nodes-storage-math-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-storage-math" title="Permalink"></a></h2><p>In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as</p><p><span>$\texttt{var\_example}[index_1, index_2]$</span></p><p>with square brackets, while functions are represented as</p><p><span>$func\_example(index_1, index_2)$</span></p><p>with paranthesis.</p><h3 id="nodes-storage-math-var"><a class="docs-heading-anchor" href="#nodes-storage-math-var">Variables</a><a id="nodes-storage-math-var-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-storage-math-var" title="Permalink"></a></h3><p>The variables of <a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a>s include:</p><ul><li><a href="../../manual/optimization-variables/#man-opt_var-opex"><span>$\texttt{opex\_var}$</span></a></li><li><a href="../../manual/optimization-variables/#man-opt_var-opex"><span>$\texttt{opex\_fixed}$</span></a></li><li><a href="../../manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_level\_inst}$</span></a></li><li><a href="../../manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_level}$</span></a></li><li><a href="../../manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_charge\_inst}$</span></a> if the <code>Storage</code> has the field <code>charge</code> with a capacity</li><li><a href="../../manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_charge\_use}$</span></a></li><li><a href="../../manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_discharge\_inst}$</span></a> if the <code>Storage</code> has the field <code>discharge</code> with a capacity</li><li><a href="../../manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_discharge\_use}$</span></a></li><li><a href="../../manual/optimization-variables/#man-opt_var-flow"><span>$\texttt{flow\_in}$</span></a></li><li><a href="../../manual/optimization-variables/#man-opt_var-flow"><span>$\texttt{flow\_out}$</span></a></li><li><a href="../../manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_level\_Œî\_op}$</span></a></li><li><a href="../../manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{stor\_level\_Œî\_rp}$</span></a> if the <code>TimeStruct</code> includes <code>RepresentativePeriods</code></li><li><a href="../../manual/optimization-variables/#man-opt_var-emissions"><span>$\texttt{emissions\_node}$</span></a> if specified through the function <a href="../../library/public/links/#EnergyModelsBase.has_emissions-Tuple{Link}"><code>has_emissions</code></a> or if you use a <code>RefStorage{AccumulatingEmissions}</code>.</li></ul><h3 id="nodes-storage-math-con"><a class="docs-heading-anchor" href="#nodes-storage-math-con">Constraints</a><a id="nodes-storage-math-con-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-storage-math-con" title="Permalink"></a></h3><p>A qualitative overview of the individual constraints can be found on <em><a href="../../manual/constraint-functions/#man-con">Constraint functions</a></em>. This section focuses instead on the mathematical description of the individual constraints. It omits the direct inclusion of the vector of network nodes (or all nodes, if nothing specific is implemented). Instead, it is implicitly assumed that the constraints are valid <span>$\forall n ‚àà N^{\text{Storage}}$</span> for all <a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a> types if not stated differently. In addition, all constraints are valid <span>$\forall t \in T$</span> (that is in all operational periods) or <span>$\forall t_{inv} \in T^{Inv}$</span> (that is in all investment periods).</p><p>The following standard constraints are implemented for a <a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a> node. <a href="../../manual/optimization-variables/#Storage"><code>Storage</code></a> nodes utilize the declared method for all nodes ùí©. The constraint functions are called within the function <a href="../../library/public/functions/#EnergyModelsBase.create_node"><code>create_node</code></a>. Hence, if you do not have to call additional functions, but only plan to include a method for one of the existing functions, you do not have to specify a new <a href="../../library/public/functions/#EnergyModelsBase.create_node"><code>create_node</code></a> method.</p><ul><li><p><code>constraints_capacity</code>:</p><p class="math-container">\[\begin{aligned}
\texttt{stor\_level\_use}[n, t] &amp; \leq \texttt{stor\_level\_inst}[n, t] \\
\texttt{stor\_charge\_use}[n, t] &amp; \leq \texttt{stor\_charge\_inst}[n, t] \\
\texttt{stor\_discharge\_use}[n, t] &amp; \leq \texttt{stor\_discharge\_inst}[n, t]
\end{aligned}\]</p></li><li><p><code>constraints_capacity_installed</code>:</p><p class="math-container">\[\begin{aligned}
\texttt{stor\_level\_inst}[n, t] &amp; = capacity(level(n), t) \\
\texttt{stor\_charge\_inst}[n, t] &amp; = capacity(charge(n), t) \\
\texttt{stor\_discharge\_inst}[n, t] &amp; = capacity(discharge(n), t)
\end{aligned}\]</p><div class="admonition is-success" id="Using-investments-539167c3ebe32c8a"><header class="admonition-header">Using investments<a class="admonition-anchor" href="#Using-investments-539167c3ebe32c8a" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>constraints_capacity_installed</code> is also used in <a href="https://energymodelsx.github.io/EnergyModelsInvestments.jl/"><code>EnergyModelsInvestments</code></a> to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.</p></div></div></li><li><p><code>constraints_flow_in</code>:<br/>The auxiliary resource constraints are independent of the chosen storage behavior:</p><p class="math-container">\[\texttt{flow\_in}[n, t, p] = inputs(n, p) \times \texttt{flow\_in}[n, stor\_res(n)]
\qquad \forall p \in inputs(n) \setminus \{stor\_res(n)\}\]</p><p>The stored resource constraints are depending on the chosen storage behavior. If no behavior is specified, it is given by</p><p class="math-container">\[\texttt{flow\_in}[n, t, stor\_res(n)] = \texttt{stor\_charge\_use}[n, t]\]</p><p>If the storage behavior is <a href="../../library/public/nodes/#EnergyModelsBase.AccumulatingEmissions"><code>AccumulatingEmissions</code></a>, it is given by</p><p class="math-container">\[\texttt{flow\_in}[n, t, stor\_res(n)] = \texttt{stor\_charge\_use}[n, t] - \texttt{emissions\_node}[n, t, stor\_res(n)]\]</p><p>This allows the storage node to provide a soft constraint for emissions.</p></li><li><p><code>constraints_flow_out</code>:</p><p class="math-container">\[\texttt{flow\_out}[n, t, stor\_res(n)] = \texttt{stor\_discharge\_use}[n, t]\]</p><div class="admonition is-success" id="Behavior-in-the-case-of-AccumulatingEmissions-7fd255a9c019e1e8"><header class="admonition-header">Behavior in the case of `AccumulatingEmissions`<a class="admonition-anchor" href="#Behavior-in-the-case-of-AccumulatingEmissions-7fd255a9c019e1e8" title="Permalink"></a></header><div class="admonition-body"><p>In this case, the constraints are still declared. The variables are however fixed to 0. Hence, it will have no impact.</p></div></div></li><li><p><code>constraints_level</code>:<br/>The level constraints are more complex compared to the standard constraints. They are explained in detail below in <em><a href="#nodes-storage-math-con-level">Level constraints</a></em>.</p></li><li><p><code>constraints_opex_fixed</code>:</p><p class="math-container">\[\begin{aligned}
\texttt{opex\_fixed}&amp;[n, t_{inv}] = \\ &amp;
  opex\_fixed(level(n), t_{inv}) \times \texttt{stor\_level\_inst}[n, first(t_{inv})] + \\ &amp;
  opex\_fixed(charge(n), t_{inv}) \times \texttt{stor\_charge\_inst}[n, first(t_{inv})] + \\ &amp;
  opex\_fixed(discharge(n), t_{inv}) \times \texttt{stor\_discharge\_inst}[n, first(t_{inv})]
\end{aligned}\]</p><div class="admonition is-success" id="Why-do-we-use-first()-137df08ad72f802a"><header class="admonition-header">Why do we use `first()`<a class="admonition-anchor" href="#Why-do-we-use-first()-137df08ad72f802a" title="Permalink"></a></header><div class="admonition-body"><p>The variables <span>$\texttt{stor\_level\_inst}$</span> are declared over all operational periods (see the section on <em><a href="../../manual/optimization-variables/#man-opt_var-cap">Capacity variables</a></em> for further explanations). Hence, we use the function <span>$first(t_{inv})$</span> to retrieve the installed capacities in the first operational period of a given investment period <span>$t_{inv}$</span> in the function <code>constraints_opex_fixed</code>.</p></div></div></li><li><p><code>constraints_opex_var</code>:</p><p class="math-container">\[\begin{aligned}
\texttt{opex\_var}&amp;[n, t_{inv}] = \\ \sum_{t \in t_{inv}}&amp;
  opex\_var(level(n), t) \times \texttt{stor\_level}[n, t] \times scale\_op\_sp(t_{inv}, t) + \\ &amp;
  opex\_var(charge(n), t) \times \texttt{stor\_charge\_use}[n, t] \times scale\_op\_sp(t_{inv}, t) + \\ &amp;
  opex\_var(discharge(n), t) \times \texttt{stor\_discharge\_use}[n, t] \times scale\_op\_sp(t_{inv}, t)
\end{aligned}\]</p><div class="admonition is-success" id="The-function-scale_op_sp-71e0c9c9fa0c9a8"><header class="admonition-header">The function `scale_op_sp`<a class="admonition-anchor" href="#The-function-scale_op_sp-71e0c9c9fa0c9a8" title="Permalink"></a></header><div class="admonition-body"><p>The function <a href="../../library/public/functions/#EnergyModelsBase.scale_op_sp"><span>$scale\_op\_sp(t_{inv}, t)$</span></a> calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.</p></div></div></li><li><p><code>constraints_ext_data</code>:<br/>This function is only called for specified data of the storage node, see above.</p></li></ul><div class="admonition is-info" id="Implementation-of-capacity-and-OPEX-e6a28cf7dfca97f"><header class="admonition-header">Implementation of capacity and OPEX<a class="admonition-anchor" href="#Implementation-of-capacity-and-OPEX-e6a28cf7dfca97f" title="Permalink"></a></header><div class="admonition-body"><p>The capacity constraints, both <code>constraints_capacity</code> and <code>constraints_capacity_installed</code> are only set for capacities that are included through the corresponding field and if the corresponding <em><a href="../../library/public/nodes/#lib-pub-nodes-stor_par">storage parameters</a></em> have a field <code>capacity</code>. Otherwise, they are omitted. The field <code>level</code> is required to have a storage parameter with capacity.</p><p>Even if a <code>Storage</code> node includes the corresponding capacity field (<em>i.e.</em>, <code>charge</code>, <code>level</code>, and <code>discharge</code>), we only include the fixed and variable OPEX constribution for the different capacities if the corresponding <em><a href="../../library/public/nodes/#lib-pub-nodes-stor_par">storage parameters</a></em> have a field <code>opex_fixed</code> and <code>opex_var</code>, respectively. Otherwise, they are omitted.</p></div></div><h4 id="nodes-storage-math-con-level"><a class="docs-heading-anchor" href="#nodes-storage-math-con-level">Level constraints</a><a id="nodes-storage-math-con-level-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-storage-math-con-level" title="Permalink"></a></h4><p>The overall structure is outlined on <em><a href="../../manual/constraint-functions/#man-con-stor_level">Constraint functions</a></em>. The level constraints are called through the function <code>constraints_level</code> which then calls additional functions depending on the chosen time structure (whether it includes representative periods and/or operational scenarios) and the chosen <em><a href="../../library/public/nodes/#lib-pub-nodes-stor_behav">storage behaviour</a></em>.</p><p>The constraints introduced in <code>constraints_level_aux</code> are given by</p><p class="math-container">\[\texttt{stor\_level\_Œî\_op}[n, t] = \texttt{stor\_charge\_use}[n, t] - \texttt{stor\_discharge\_use}[n, t]\]</p><p>corresponding to the change in the storage level in an operational period. If the storage behavior is <a href="../../library/public/nodes/#EnergyModelsBase.AccumulatingEmissions"><code>AccumulatingEmissions</code></a>, it is instead given by</p><p class="math-container">\[\texttt{stor\_level\_Œî\_op}[n, t] = \texttt{stor\_charge\_use}[n, t]\]</p><p>In this case, we also fix variables and provide lower bounds:</p><p class="math-container">\[\begin{aligned}
&amp; \texttt{emissions\_node}[n, t, stor\_res(n)] \geq 0 \\
&amp; \texttt{emissions\_node}[n, t, p_{em}] = 0 \qquad &amp; \forall p_{em} \in P^{em} \setminus \{stor\_res(n)\} \\
&amp; \texttt{stor\_level\_Œî\_op}[n, t] \geq 0 \\
&amp; \texttt{stor\_discharge\_use}[n, t] = 0 \\
&amp; \texttt{flow\_out}[n, t, p] = 0 \qquad &amp; \forall p \in output(n)
\end{aligned}\]</p><p>If the time structure includes representative periods, we calculate the change of the storage level in each representative period within the function <code>constraints_level_iterate</code>:</p><p class="math-container">\[\texttt{stor\_level\_Œî\_rp}[n, t_{rp}] = \sum_{t \in t_{rp}}
\texttt{stor\_level\_Œî\_op}[n, t] \times scale\_op\_sp(t_{rp}, t)\]</p><p>In the case of <a href="../../library/public/nodes/#EnergyModelsBase.CyclicStrategic"><code>CyclicStrategic</code></a>, we add an additional constraint to the change in the function <code>constraints_level_rp</code>:</p><p class="math-container">\[\sum_{t_{rp} \in T^{rp}} \texttt{stor\_level\_Œî\_rp}[n, t_{rp}] = 0\]</p><p>while we fix the value in the case of <a href="../../library/public/nodes/#EnergyModelsBase.CyclicRepresentative"><code>CyclicRepresentative</code></a> to 0:</p><p class="math-container">\[\texttt{stor\_level\_Œî\_rp}[n, t_{rp}] = 0\]</p><p><code>Accumulating</code> storage behaviors do not add any constraint for the variable <span>$\texttt{stor\_level\_Œî\_rp}$</span>.</p><p>If the time structure includes operational scenarios using <a href="../../library/public/nodes/#EnergyModelsBase.CyclicRepresentative"><code>CyclicRepresentative</code></a>, we enforce that the last value in each operational scenario is the same within the function <code>constraints_level_scp</code>.</p><p>The general level constraint is eventually calculated in the function <code>constraints_level_iterate</code>:</p><p class="math-container">\[\texttt{stor\_level}[n, t] = prev\_level +
\texttt{stor\_level\_Œî\_op}[n, t] \times duration(t)\]</p><p>in which the value <span>$prev\_level$</span> is depending on the type of the previous operational (<span>$t_{prev}$</span>) and strategic level (<span>$t_{inv,prev}$</span>) (as well as the previous representative period (<span>$t_{rp,prev}$</span>)). It is calculated through the function <code>previous_level</code>.</p><p>We can distinguish the following cases:</p><ol><li><p>The first operational period (in the first representative period) in an investment period (given by <span>$typeof(t_{prev}) = typeof(t_{rp, prev}) = = nothing$</span>). In this situation, the previous level is dependent on the chosen storage behavior. In the default case of a <a href="../../library/public/nodes/#EnergyModelsBase.Cyclic"><code>Cyclic</code></a> behaviors, it is given by the last operational period of either the strategic or representative period:</p><p class="math-container">\[\begin{aligned}
  prev\_level &amp; = \texttt{stor\_level}[n, last(t_{sp})]
  prev\_level &amp; = \texttt{stor\_level}[n, last(t_{rp})]
\end{aligned}\]</p><p>If the storage behavior is instead given by <a href="../../library/public/nodes/#EnergyModelsBase.CyclicStrategic"><code>CyclicStrategic</code></a> and the time structure includes representative periods, we calculate the previous level instead as:</p><p class="math-container">\[\begin{aligned}
t_{rp,last}  = &amp; last(repr\_periods(t_{sp})) \\
prev\_level = &amp; \texttt{stor\_level}[n, first(t_{rp,last})] - \\ &amp;
  \texttt{stor\_level\_Œî\_op}[n, first(t_{rp,last})] \times duration(first(t_{rp,last})) + \\ &amp;
  \texttt{stor\_level\_Œî\_rp}[n, t_{rp,last}]
\end{aligned}\]</p><p><span>$t_{rp,last}$</span> corresponds in this situation to the last representative period in the current investment period.</p><p>If the storage behavior is instead given by <a href="../../library/public/nodes/#EnergyModelsBase.Accumulating"><code>Accumulating</code></a>, the previous level is set to 0:</p><p class="math-container">\[prev\_level = 0\]</p></li><li><p>The first operational period in subsequent representative periods in any investment period (given by <span>$typeof(t_{prev}) = nothing$</span>). The previous level is again dependent on the chosen storage behavior. The default approach calculates it as:</p><p class="math-container">\[\begin{aligned}
 prev\_level = &amp; \texttt{stor\_level}[n, first(t_{rp,prev})] - \\ &amp;
   \texttt{stor\_level\_Œî\_op}[n, first(t_{rp,prev})] \times duration(first(t_{rp,prev})) + \\ &amp;
   \texttt{stor\_level\_Œî\_rp}[n, t_{rp,prev}]
\end{aligned}\]</p><p>while a <a href="../../library/public/nodes/#EnergyModelsBase.CyclicRepresentative"><code>CyclicRepresentative</code></a> storage behavior calculates it as:</p><p class="math-container">\[prev\_level = \texttt{stor\_level}[n, last(t_{rp})]\]</p><p>This situation only occurs in cases in which the time structure includes representative periods.</p></li><li><p>All other operational periods:<br/></p><p class="math-container">\[ prev\_level = \texttt{stor\_level}[n, t_{prev}]\]</p></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../networknode/">¬´ NetworkNode</a><a class="docs-footer-nextpage" href="../sink/">Sink ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 25 November 2025 08:11">Tuesday 25 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
