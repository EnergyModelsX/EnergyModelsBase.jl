var documenterSearchIndex = {"docs":
[{"location":"how-to/utilize-timestruct/#how_to-utilize_TS","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"EnergyModelsBase uses for the description of time the package TimeStruct. TimeStruct offers a large variety of different options that can appear to be overwhelming, when first exposed to them. Hence, it is important to highlight how it works and which parameters you would want to analyse.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-struct","page":"Utilize TimeStruct","title":"Structures for time description","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"TimeStruct introduces individual structures that are used for describing time. In the following introduction, the most important structures are explained. There are other structures, but these will be added once EnergyModelsbase supports their formulation.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-struct-op","page":"Utilize TimeStruct","title":"Operational periods","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Operational periods correspond to periods in which no investments are allowed. In general, you can imagine operational periods to be the individual hours you want to model, although it is not limited to hours. In each operational period, we have an optimal dispatch problem given the constraints. Operational periods are normally implemented using the type SimpleTimes which has the following structure:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"op_duration = 1  # Each operational period has a duration of 1\nop_number = 24   # There are in total 24 operational periods\noperational_periods = SimpleTimes(op_number, op_duration)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"In above's example, we assume that we have in total 24 operational periods which have the same duration each, i.e., a duration of 1. The unit in itself is not important, but it can be either if you consider that a duration of 1 corresponds to one hour. In this case, the operational periods would correspond to a full day.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"note: Note\nAll operational periods are continuous. This implies that one is not allowed to have jumps in the representative periods. This affects all \"dynamic\" constraints, that is, constraints where the current operational period is dependent on the previous operational period. In EnergyModesBase, this is only the case for the level balance in RefStorage. Representative periods allow for jumps between operational periods, as outlined below.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Note that TimeStruct does not require that each operational period has the same length. Consider the following example:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"op_duration = [4, 2, 1, 1, 2, 4, 2, 1, 1, 2, 4]\nop_number = length(op_duration)\noperational_periods = SimpleTimes(op_number, op_duration)\n\n# output\nSimpleTimes{Int64}(11, [4, 2, 1, 1, 2, 4, 2, 1, 1, 2, 4])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"In this case, we model the day not with hourly resolution, but only have hourly resolution in the morning and afternoon. The night has a reduced time resolution of 4 hours. However, we still model a full 24 hours as can be seen by the command","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"TimeStruct._total_duration(operational_periods)\n\n# output\n24","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"When having an Array as input to SimpleTimes, it is also not necessary to specify op_number. Instead, one can also write","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"operational_periods = SimpleTimes(op_duration)\n\n# output\nSimpleTimes{Int64}(11, [4, 2, 1, 1, 2, 4, 2, 1, 1, 2, 4])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"and a constructor will automatically deduce that there have to be 11 operational periods.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"SimpleTimes is also the lowest TimeStructure that is present in TimeStruct. It is used in all subsequent structures. When iterating over a TimeStructure, e.g., as t ‚àà operational_periods, you obtain the single operational periods that are required for solving the optimal dispatch.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"warning: Warning\nEnergy conversion, production, or emissions of a node as well as all flows are always defined for a duration of length 1 in operational periods. You have to be careful when considering the output from the model. The same holds for capacities provided in the input file.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-struct-rp","page":"Utilize TimeStruct","title":"Representative periods","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Representative periods are introduced through the structure RepresentativePeriods. Representative periods correspond to a repetition of different periods. This is a change from SimpleTimes in which a single period is scaled.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Consider the following example:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"day = SimpleTimes(24, 1)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"This example can represent a single day with hourly resolution. In practice, when including the day into a TwoLevel, it is scaled multiple times. This can lead to an underestimation of storage requirements and makes it impossible to include seasonal storage.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Representative periods can be included through creating multiple instances of SimpleTimes. The following example creates two days with hourly resolution, one winter day and one summer day. These two days are the combined into a RepresentativePeriod with 2 periods. These two periods sum up to a duration of 8760, that is a year. Each representative period is scaled up 365/2=182.5 times.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"winter_day = SimpleTimes(24, 1)\nsummer_day = SimpleTimes(24, 1)\n\nperiods = 2                 # Number of representative periods\ntotal_duration = 8760       # Total duration\nshare = [0.5, 0.5]          # Share of the total duration of the representative periods\n\nrps = RepresentativePeriods(periods, total_duration, share, winter_day, summer_day)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Representative periods only affect the system if storage is included. In the case of storage, this scaling impacts the initial level of the storage in representative periods. Otherwise, the application of SimpleTimes suffices.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-struct-sp","page":"Utilize TimeStruct","title":"Strategic periods","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Strategic periods are introduced through the structure TwoLevel. They correspond to the periods in which changes in capacity, efficiency, or operational expenditures can occur. The general structure is given by","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"day = SimpleTimes(24, 1)\nstrategic_duration = 5  # Each strategic period has a duration of 5\nstrategic_number = 5    # here are in total 5 strategic periods\nT = TwoLevel(strategic_number, strategic_duration, day)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"The example above corresponds to 5 strategic periods with a duration of 5 in each strategic period. Each strategic period includes 24 operational periods. One can choose any reference duration for a strategic period and the corresponding duration of an operational period. In above's example, there is no specified link between the duration of 1 of an operational period and a duration of 1 of a strategic period. TwoLevel assumes in this situation that the link is 1, that is both the strategic periods and the operational periods have the same duration.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"In general, it is easiest to use a duration of 1 of a strategic period to be equivalent to a single year while a duration of 1 of an operational period should correspond to 1 hour. In this case, we have to specifiy TwoLevel slightly differently:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"ùíØ = TwoLevel(strategic_number, strategic_duration, day; op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Note, that we used in this example the optional keyword argument op_per_strat which links the duration 1 of an operational period to the duration 1 of a strategic period. If we would like to have a duration of 1 in an operational period corresponding to an hour and a duration of 1 in a strategic period to a year, we need to use the value op_per_strat = 365*24 = 8760.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"warning: Warning\nIt is important to be certain which value one should use for op_per_strat. When using the wrong value, one obtains wrong operational results that may affect the analysis.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Similar to the SimpleTimes structure, it is possible to also have strategic periods of varying durations. It can be advantageous to, e.g., have a reduced duration in the initial investment periods, while having an increased duration in the latter. This would allow to reflect the higher uncertainty associated with future decisions and improve computational tractability by reducing model instance size.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"You can extract an iterator for the individual strategic periods by using the command:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"ùíØ·¥µ‚Åø·µõ = strategic_periods(ùíØ)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"When iterating through ùíØ·¥µ‚Åø·µõ, you obtain the individual strategic periods. When iterating through a strategic period, you obtain the individual operational periods:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"for t_inv ‚àà ùíØ·¥µ‚Åø·µõ, t ‚àà t_inv end\n# is equivalent to\nfor t ‚àà ùíØ end","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"The advantage of approach 1 is that you can also use the indices of the strategic period. However, it may make the code look more complicated, when this is not required. It does not have any implication on the model building speed and it is up to the user, which approach to choose.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"warning: Warning\nFixed operational expenditures and emission limits provided to a model have to be provided for a duration of 1 in the strategic period.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-struct-sum","page":"Utilize TimeStruct","title":"Summary","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"In the standard case, it is recommended to use hour as duration 1 of operational period and year as duration 1 of a strategic period. This still allows to utilize a higher resolution, like e.g. 15 minutes or less through specifying a duration of 0.25 for these operational periods, but it simplifies the overall design.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"day = SimpleTimes(24, 1)\nstrategic_duration = 5  # Each strategic period has a duration of 5\nstrategic_number = 5    # here are in total 5 strategic periods\nùíØ = TwoLevel(strategic_number, strategic_duration, day; op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"This is especially relevant for capacities and emission limits, as well as anlysing the values obtained from the model.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-profile","page":"Utilize TimeStruct","title":"Profiles","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Profiles are used for providing parameters to the model. There are in general three main profiles, that have to be considered:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"FixedProfile represents using the same value in all periods,\nOperationalProfile represents using the same profile in all strategic periods, although there can be variations in the individual strategic periods,\nRepresentativeProfile represents a profile that differes in the individual representative periods, and\nStrategicProfile represents using different values in the strategic periods.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-profile-fixed","page":"Utilize TimeStruct","title":"FixedProfile","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"FixedProfile is the simplest profile. It represents a constant value over the whole modelling horizon. Its application is given by:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"profile = FixedProfile(10)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"This would provide a value of 10 in all operational periods in all strategic periods.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-profile-operational","page":"Utilize TimeStruct","title":"OperationalProfile","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"OperationalProfile is used when there are operational variations. Consider the following example time structure, corresponding to 5 strategic periods, each with a duration of 5 years, and 24 operational periods, each with a duration of 24 hours.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"ùíØ = TwoLevel(5, 5, SimpleTimes(24, 1); op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"In this case, we would need to define an OperationalProfile as an array with length 24:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"op_profile = OperationalProfile(collect(1:1.0:24))","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"The example has a progressively increasing value going from 1 in the first hour to 24 in the last hour. collect is in this example required to obtain the value as array.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"OperationalProfile is normally used for varying demand or profiles for renewable power generation.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"warning: Warning\nIt is possible to have an OperationalProfile that is shorter or longer than the profile in the time structure. If the profile is shorter, then the last value is repeated. If the profile is longer, then the last values are ommitted. EnergyModelsBase provides the user with a warning if one of above's cases are presentIt is hence strongly advise to use an OperationalProfile with the same length.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-profile-representative","page":"Utilize TimeStruct","title":"RepresentativeProfile","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"RepresentativeProfiles can be included in the case of RepresentativePeriods. Each profile in the structure corresponds to the respective representative period.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"Consider the following time structure,","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"winter_day = SimpleTimes(24, 1)\nsummer_day = SimpleTimes(24, 1)\nop = RepresentativePeriods(2, 8760, [0.5, 0.5], winter_day, summer_day)\nùíØ = TwoLevel(5, 5, ; op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"in which two days with hourly resolution are scaled up 182.5 times each. The corresponding profiles then can look like the following:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"profile_winter = OperationalProfile(collect(range(1, stop=24, length=24)))\nprofile_summer = FixedProfile(0)\ndemand = RepresentativeProfile([profile_winter, profile_summer])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"This implies that we can use both OperationalProfile and FixedProfile combined. The only requirement is that if one is using Integer input, then the other also has to use Integer input.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"warning: Warning\nIt is possible to use RepresentativeProfile without RepresentativePeriods. In this case, the first provided profile is used.EnergyModelsBase provides the user with a warning if this is the case.","category":"page"},{"location":"how-to/utilize-timestruct/#how_to-utilize_TS-profile-strategic","page":"Utilize TimeStruct","title":"StrategicProfile","text":"","category":"section"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"StrategicProfile is used when there are strategic variations. Considering the same example time structure,","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"ùíØ = TwoLevel(5, 5, SimpleTimes(24, 1); op_per_strat=8760)","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"we can define a StrategicProfile as:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"strat_profile = StrategicProfile([1, 2, 3, 4, 5])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"In this case, we have variations between the strategic periods, but use the same value in all operational periods within a strategic period, that is all operational periods in strategic period 1 would use a value of 1, while the once in strategic period 2 a value of 2, and so on. This implementation is frequently used for changing capacities or efficiencies.","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"It is also possible to have both variations on the strategic and operational level. A StrategicProfile then takes an Array of OperationalProfiles as input:","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"op_profile_1 = OperationalProfile(rand(24))\nop_profile_2 = OperationalProfile(rand(24))\nop_profile_3 = OperationalProfile(rand(24))\nop_profile_4 = OperationalProfile(rand(24))\nop_profile_5 = OperationalProfile(rand(24))\nstrat_profile = StrategicProfile([op_profile_1, op_profile_2, op_profile_3, op_profile_4, op_profile_5])","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"This approach is frequently used for demands where there are changes both on the operational level (e.g., hour) and strategic level (e.g., year).","category":"page"},{"location":"how-to/utilize-timestruct/","page":"Utilize TimeStruct","title":"Utilize TimeStruct","text":"It is similarly possible to include RepresentativeProfiles.","category":"page"},{"location":"library/public/emi_extension/#lib-pub-emi_ext","page":"EMI extension","title":"EnergymodelsInvestments extensions","text":"","category":"section"},{"location":"library/public/emi_extension/","page":"EMI extension","title":"EMI extension","text":"The extension introduces new types and functions. These are create within the core structure, as it is not possible to export new types/functions from extensions. In this case, we use constructors within the extension for the abstract types declared within the core structure.","category":"page"},{"location":"library/public/emi_extension/","page":"EMI extension","title":"EMI extension","text":"The following page provides you with an overview of the individual constructors. The described fields are only available if you load EnergyModelsInvestments as well.","category":"page"},{"location":"library/public/emi_extension/#lib-pub-emi_ext-types","page":"EMI extension","title":"AbstractInvestmentModel","text":"","category":"section"},{"location":"library/public/emi_extension/","page":"EMI extension","title":"EMI extension","text":"Including the extension for EnergyModelsInvestments results in the declaration of the types AbstractInvestmentModel and InvestmentModel which can be used for creating models with investments It takes as additional input the discount_rate. The discount_rate is an important element of investment analysis needed to represent the present value of future cash flows. It is provided to the model as a value between 0 and 1 (e.g. a discount rate of 5 % is 0.05).","category":"page"},{"location":"library/public/emi_extension/#EnergyModelsBase.AbstractInvestmentModel","page":"EMI extension","title":"EnergyModelsBase.AbstractInvestmentModel","text":"AbstractInvestmentModel <: EnergyModel\n\nAn abstract investment model type.\n\nThis abstract model type should be used when creating additional EnergyModel types that should utilize investments.\n\nnote: Note\nAlthough it is declared within EnergyModelsBase, its concrete is only accessible if EnergyModelsInvestments is loaded\n\nAn example for additional types is given by the inclusion of, e.g., SDDP.\n\n\n\n\n\n","category":"type"},{"location":"library/public/emi_extension/#EnergyModelsBase.InvestmentModel","page":"EMI extension","title":"EnergyModelsBase.InvestmentModel","text":"InvestmentModel <: AbstractInvestmentModel\n\nA concrete basic investment model type based on the standard OperationalModel. The concrete basic investment model is similar to an OperationalModel, but allows for investments and additional discounting of future years.\n\nnote: Note\nAlthough it is declared within EnergyModelsBase, its concrete is only accessible if EnergyModelsInvestments is loaded\n\nFields\n\nemission_limit::Dict{<:ResourceEmit, <:TimeProfile} is a dictionary with individual emission limits as TimeProfile for each emission resource ResourceEmit.\nemission_price::Dict{<:ResourceEmit, <:TimeProfile} are the emission costs for each emission resources ResourceEmit.\nco2_instance is a ResourceEmit and corresponds to the type used for CO‚ÇÇ.\nr::Float64 is the discount rate in the investment optimization.\n\n\n\n\n\n","category":"type"},{"location":"library/public/emi_extension/#lib-pub-fun_field_model","page":"EMI extension","title":"Functions for accessing fields of AbstractInvestmentModel types","text":"","category":"section"},{"location":"library/public/emi_extension/","page":"EMI extension","title":"EMI extension","text":"The current implementation extracts the discount rate through a function.","category":"page"},{"location":"library/public/emi_extension/","page":"EMI extension","title":"EMI extension","text":"warning: Warning\nIf you want to introduce new AbstractInvestmentModel types, you have to in additional consider the function discount_rate.","category":"page"},{"location":"library/public/emi_extension/#EnergyModelsBase.discount_rate","page":"EMI extension","title":"EnergyModelsBase.discount_rate","text":"discount_rate(modeltype::AbstractInvestmentModel)\n\nReturns the discount rate of AbstractInvestmentModel modeltype.\n\n\n\n\n\n","category":"function"},{"location":"library/public/emi_extension/#lib-pub-emi_ext-inv_data","page":"EMI extension","title":"Investment data","text":"","category":"section"},{"location":"library/public/emi_extension/#lib-pub-emi_ext-inv_data-types","page":"EMI extension","title":"InvestmentData types","text":"","category":"section"},{"location":"library/public/emi_extension/","page":"EMI extension","title":"EMI extension","text":"InvestmentData subtypes are used to provide technologies introduced in EnergyModelsX (nodes and transmission modes) a subtype of Data that can be used for dispatching. Two different types are directly introduced, SingleInvData and StorageInvData.","category":"page"},{"location":"library/public/emi_extension/","page":"EMI extension","title":"EMI extension","text":"SingleInvData is providing a composite type with a single field. It is used for investments in technologies with a single capacity, that is all nodes except for storage nodes as well as transmission modes.","category":"page"},{"location":"library/public/emi_extension/","page":"EMI extension","title":"EMI extension","text":"StorageInvData is required as Storage nodes behave differently compared to the other nodes. In Storage nodes, it is possible to invest both in the charge capacity for storing energy, the storage capacity, that is the level of a Storage node, as well as the discharge capacity, that is how fast energy can be withdrawn. Correspondingly, it is necessary to have individual parameters for the potential investments in each capacity, that is through the fields :charge, :level, and :discharge.","category":"page"},{"location":"library/public/emi_extension/#EnergyModelsBase.InvestmentData","page":"EMI extension","title":"EnergyModelsBase.InvestmentData","text":"InvestmentData <: Data\n\nAbstract type for the extra data for investing in technologies.\n\n\n\n\n\n","category":"type"},{"location":"library/public/emi_extension/#EnergyModelsBase.SingleInvData","page":"EMI extension","title":"EnergyModelsBase.SingleInvData","text":"SingleInvData <: InvestmentData\n\nExtra investment data for type investments. The extra investment data has only a single field in which AbstractInvData has to be added.\n\nThe advantage of separating AbstractInvData from the InvestmentData node is to allow easier separation of EnergyModelsInvestments and EnergyModelsBase and provides the user with the potential of introducing new capacities for types.\n\nFields\n\ncap::AbstractInvData is the investment data for the capacity.\n\nWhen multiple inputs are provided, a constructor directly creates the corresponding AbstractInvData.\n\nFields\n\ncapex::TimeProfile is the capital costs for investing in a capacity. The value is relative to the added capacity.\nmax_inst::TimeProfile is the maximum installed capacity in a strategic period.\ninitial::Real is the initial capacity. This results in the creation of a StartInvData type for the investment data.\ninv_mode::Investment is the chosen investment mode for the technology. The following investment modes are currently available: BinaryInvestment, DiscreteInvestment, ContinuousInvestment, SemiContinuousInvestment, or FixedInvestment.\nlife_mode::LifetimeMode is type of handling the lifetime. Several different alternatives can be used: UnlimitedLife, StudyLife, PeriodLife, or RollingLife. If life_mode is not specified, the model assumes an UnlimitedLife.\n\n\n\n\n\n","category":"type"},{"location":"library/public/emi_extension/#EnergyModelsBase.StorageInvData","page":"EMI extension","title":"EnergyModelsBase.StorageInvData","text":"StorageInvData <: InvestmentData\n\nExtra investment data for storage investments. The extra investment data for storage investments can, but does not require investment data for the charge capacity of the storage (charge), increasing the storage capacity (level), or the discharge capacity of the storage (discharge).\n\nIt utilizes a constructor with keyword arguments for the individual parameters. Hence, the names of the parameters have to be specified.\n\nFields\n\ncharge::Union{AbstractInvData, Nothing} is the investment data for the charge capacity.\nlevel::Union{AbstractInvData, Nothing} is the investment data for the level capacity.\ndischarge::Union{AbstractInvData, Nothing} is the investment data for the discharge capacity.\n\n\n\n\n\n","category":"type"},{"location":"library/public/emi_extension/#lib-pub-emi_ext-inv_data-leg","page":"EMI extension","title":"Legacy constructors","text":"","category":"section"},{"location":"library/public/emi_extension/","page":"EMI extension","title":"EMI extension","text":"We provide a legacy constructor, InvData and InvDataStorage, that use the same input as in version 0.5.x. If you want to adjust your model to the latest changes, please refer to the section Update your model to the latest version of EnergyModelsInvestments.","category":"page"},{"location":"library/public/emi_extension/#EnergyModelsBase.InvData","page":"EMI extension","title":"EnergyModelsBase.InvData","text":"InvData(;\n    capex_cap::TimeProfile,\n    cap_max_inst::TimeProfile,\n    cap_max_add::TimeProfile,\n    cap_min_add::TimeProfile,\n    inv_mode::Investment = ContinuousInvestment(),\n    cap_start::Union{Real, Nothing} = nothing,\n    cap_increment::TimeProfile = FixedProfile(0),\n    life_mode::LifetimeMode = UnlimitedLife(),\n    lifetime::TimeProfile = FixedProfile(0),\n)\n\nLegacy constructor for a InvData.\n\nThe new storage descriptions allows now for a reduction in functions which is used to make EnergModelsInvestments less dependent on EnergyModelsBase.\n\nThe core changes to the existing structure is the move of the required parameters to the type Investment (e.g., the minimum and maximum added capacity is only required for investment modes that require these parameters) as well as moving the lifetime to the type LifetimeMode, when required.\n\nSee the documentation for further information regarding how you can translate your existing model to the new model.\n\nnote: Note\nAlthough it is declared within EnergyModelsBase, its concrete is only accessible if EnergyModelsInvestments is loaded\n\n\n\n\n\n","category":"function"},{"location":"library/public/emi_extension/#EnergyModelsBase.InvDataStorage","page":"EMI extension","title":"EnergyModelsBase.InvDataStorage","text":"InvDataStorage(;\n    #Investment data related to storage power\n    capex_rate::TimeProfile,\n    rate_max_inst::TimeProfile,\n    rate_max_add::TimeProfile,\n    rate_min_add::TimeProfile,\n    capex_stor::TimeProfile,\n    stor_max_inst::TimeProfile,\n    stor_max_add::TimeProfile,\n    stor_min_add::TimeProfile,\n    inv_mode::Investment = ContinuousInvestment(),\n    rate_start::Union{Real, Nothing} = nothing,\n    stor_start::Union{Real, Nothing} = nothing,\n    rate_increment::TimeProfile = FixedProfile(0),\n    stor_increment::TimeProfile = FixedProfile(0),\n    life_mode::LifetimeMode = UnlimitedLife(),\n    lifetime::TimeProfile = FixedProfile(0),\n)\n\nStorage descriptions were changed in EnergyModelsBase v0.7 resulting in the requirement for rewriting the investment options for Storage nodes.\n\nSee the documentation for further information regarding how you can translate your existing model to the new model.\n\nnote: Note\nAlthough it is declared within EnergyModelsBase, its concrete is only accessible if EnergyModelsInvestments is loaded\n\n\n\n\n\n","category":"function"},{"location":"how-to/contribute/#how_to-con","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Contributing to EnergyModelsBase can be achieved in several different ways.","category":"page"},{"location":"how-to/contribute/#how_to-con-ext","page":"Contribute to EnergyModelsBase","title":"Create new extensions","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"The main focus of EnergyModelsBase is to provide an easily extensible energy system optimization modelling framework. Hence, a first approach to contributing to EnergyModelsBase is to create a new package with, e.g., the introduction of new node descriptions.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"This is explained in How to create a new node.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"tip: Tip\nIf you are uncertain how you could incorporate new nodal descriptions, take a look at EnergyModelsRenewableProducers. The package is maintained by the developers of EnergyModelsBase. Hence, it provides you with ideas on how we think it is best to develop new node descriptions.","category":"page"},{"location":"how-to/contribute/#how_to-con-bug_rep","page":"Contribute to EnergyModelsBase","title":"File a bug report","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Another approach to contributing to EnergyModelsBase is through filing a bug report as an issue when unexpected behaviour is occuring.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"When filing a bug report, please follow the following guidelines:","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Be certain that the bug is a bug and originating in EnergyModelsbase:\nIf the problem is within the results of the optimization problem, please check first that the nodes are correctly linked with each other. Frequently, missing links (or wrongly defined links) restrict the transport of energy/mass. If you are certain that all links are set correctly, it is most likely a bug in EnergyModelsBase and should be reported.\nIf the problem occurs in model construction, it is most likely a bug in EnergyModelsBase and should be reported.\nIf the problem is only appearing for specific solvers, it is most likely not a bug in EnergyModelsBase, but instead a problem of the solver wrapper for MathOptInterface. In this case, please contact the developers of the corresponding solver wrapper.\nLabel the issue as bug, and\nProvide a minimum working example of a case in which the bug occurs.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"note: Note\nWe are aware that certain design choices within EnergyModelsBase can lead to method ambiguities. Our aim is to extend the documentation to improve the description on how to best extend the base functionality as well as which caveats can occur.In order to improve the code, we welcome any reports of potential method ambiguities to help us improving the structure of the framework.","category":"page"},{"location":"how-to/contribute/#how_to-con-feat_req","page":"Contribute to EnergyModelsBase","title":"Feature requests","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Although EnergyModelsBase was designed with the aim of flexibility, it sometimes still requires additional features to account for potential extensions. Feature requests can be achieved through two approaches:","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Create an issue describing the aim of the feature request and\nIncorporate the feature request through a fork of the repository.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"note: Note\nEnergyModelsBase should not include everything.The aim of the framework is to be lightweight and extendable by the user. Hence, feature requests should only include basic requirements for the core structure, and not, e.g., the description of new technologies. These should be developed outside of EnergyModelsBase.","category":"page"},{"location":"how-to/contribute/#how_to-con-feat_req-issue","page":"Contribute to EnergyModelsBase","title":"Create an Issue","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Creating a new issue for a feature request is our standard approach for extending EnergyModelsBase. Due to the extendibility of EnergyModelsBase, it is not necessarily straight forward to understand how to best incorporate required features into the framework without breaking other packages.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"When creating a new issue as feature request, please follow the the following guidelines.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Reason for the feature: Please describe the reasoning for the feature request. What functionality do you require in the core structure of EnergyModelsBase?\nRequired outcome: What should be the outcome when including the feature and what should be the minimum requirements of the outcome?\nPotential solutions: Describe alternatives you consider. This step is not necessarily required, but can be helpful for identifying potential solutions.","category":"page"},{"location":"how-to/contribute/#how_to-con-feat_req-fork","page":"Contribute to EnergyModelsBase","title":"Incorporating the feature requests through a fork","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"note: Note\nThe approach used for providing code is based on the excellent description of the JuMP package. We essentially follow the same approach with minor changes.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"If you would like to work directly in EnergyModelsBase, you can also incorporate your changes directly. In this case, it is beneficial to follow the outlined steps:","category":"page"},{"location":"how-to/contribute/#how_to-con-feat_req-fork-step_1","page":"Contribute to EnergyModelsBase","title":"Step 1: Create an issue","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Even if you plan to incorporate the code directly, we advise you to first follow the steps outlined in Create an Issue. This way, it is possible for us to comment on the solution approach(es) and assess potential problems with the other core packages of the EnergyModelsX framework.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Through creating an issue first, it is possible for us to comment directly on the proposed changes and assess, whether we consider the proposed changes to follow the philosophy of the framework.","category":"page"},{"location":"how-to/contribute/#how_to-con-feat_req-fork-step_2","page":"Contribute to EnergyModelsBase","title":"Step 2: Create a fork of EnergyModelsBase","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Contributiing code to EnergyModelsBase should follow the standard approach by creating a fork of the repository. All work on the code should occur within the fork.","category":"page"},{"location":"how-to/contribute/#how_to-con-feat_req-fork-step_3","page":"Contribute to EnergyModelsBase","title":"Step 3: Checkout a new branch in your local fork","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"It is in general preferable to work on a separate branch when developing new components.","category":"page"},{"location":"how-to/contribute/#how_to-con-feat_req-fork-step_4","page":"Contribute to EnergyModelsBase","title":"Step 4: Make changes to the code base","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Incorporate your changes in your new branch. The changes should be commented to understand the thought process behind them. In addition, please provide new tests for the added functionality and be certain that the existing tests run. New tests should be based on a minimum working example in which the new concept is evaluated.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Some existing tests may potentially require changes when incorporating new features (especially within the test set General tests). In this case, it is ok that they are failing and we will comment on the required changes in the pull request.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"tip: Tip\nIt is in our experience easiest to use the package TestEnv for testing the complete package.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"It is not necessary to provide changes directly in the documentation. It can be easier to include these changes after the pull request is accepted in principal. It is however a requirement to update the NEWS.md file under a new subheading titled \"Unversioned\".","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"note: Used style in EnergyModelsBase\nCurrently, we have not written a style guide for the framework. We follow in general the conventions of the Blue style guide with minor modifications.@constraint macros are not following the style guide, as we personally consider the design more difficult to read. Please follow in that respect the used style within the package.","category":"page"},{"location":"how-to/contribute/#how_to-con-feat_req-fork-step_5","page":"Contribute to EnergyModelsBase","title":"Step 5: Create a pull request","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"Once you are satisified with your changes, create a pull request towards the main branch of the EnergyModelsBase repository. We will internally assign the relevant person to the pull request.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsBase","title":"Contribute to EnergyModelsBase","text":"You may receive quite a few comments with respect to the incorporation and how it may potentially affect other parts of the code. Please remain patient as it may take potentially some time before we can respond to the changes, although we try to answer as fast as possible.","category":"page"},{"location":"library/internals/reference_EMIExt/#Internals-EnergyModelsInvestment-extension","page":"EMI extension","title":"Internals - EnergyModelsInvestment extension","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/#Index","page":"EMI extension","title":"Index","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/","page":"EMI extension","title":"EMI extension","text":"Pages = [\"reference_EMIExt.md\"]","category":"page"},{"location":"library/internals/reference_EMIExt/#Extension","page":"EMI extension","title":"Extension","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/#Types","page":"EMI extension","title":"Types","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/#EMIExt.InvestmentModel","page":"EMI extension","title":"EMIExt.InvestmentModel","text":"InvestmentModel <: EMB.InvestmentModel\n\nInternal type for InvestmentModel. The introduction of an internal type is necessary as extensions do not allow to export functions or types.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EMIExt.SingleInvData","page":"EMI extension","title":"EMIExt.SingleInvData","text":"SingleInvData <: EMB.SingleInvData\n\nInternal type for SingleInvData. The introduction of an internal type is necessary as extensions do not allow to export functions or types.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EMIExt.StorageInvData","page":"EMI extension","title":"EMIExt.StorageInvData","text":"StorageInvData <: EMB.StorageInvData\n\nInternal type for StorageInvData. The introduction of an internal type is necessary as extensions do not allow to export functions or types.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#Methods","page":"EMI extension","title":"Methods","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/#EMIExt.check_inv_data","page":"EMI extension","title":"EMIExt.check_inv_data","text":"check_inv_data(\n    inv_data::AbstractInvData,\n    capacity_profile::TimeProfile,\n    ùíØ,\n    message::String,\n    check_timeprofiles::Bool,\n)\n\nPerforms various checks on investment data introduced within EnergyModelsInvestments\n\nChecks\n\nFor each field with TimeProfile:\nIf the TimeProfile is a StrategicProfile, it will check that the profile is in accordance with the TimeStructure\nTimeProfiles in InvestmentData cannot include OperationalProfile, RepresentativeProfile, or ScenarioProfile as this is not allowed through indexing on the TimeProfile.\nThe field :min_add has to be less than :max_add if the investment mode is given by ContinuousInvestment or SemiContiInvestment.\nExisting capacity cannot be larger than :max_inst capacity in the beginning. If NoStartInvData is used, it also checks that the the TimeProfile capacity_profile is not including OperationalProfile, RepresentativeProfile, or ScenarioProfile to avoid indexing problems.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference_EMIExt/#EMIExt.objective_invest","page":"EMI extension","title":"EMIExt.objective_invest","text":"objective_invest(m, elements, ùíØ·¥µ‚Åø·µõ::TS.AbstractStratPers, modeltype::EnergyModel)\n\nCreate JuMP expressions indexed over the investment periods ùíØ·¥µ‚Åø·µõ for different elements. The expressions correspond to the investments into the different elements. They are not discounted and do not take the duration of the investment periods into account.\n\nBy default, objective expressions are included for:\n\nelements = ùí©::Vector{<:Node}. In the case of a vector of nodes, the function returns the sum of the capital expenditures for all nodes whose method of the function has_investment returns true. In the case of Storage nodes, all capacity investments are considired\nelements = ùí©::Vector{<:Link}. In the case of a vector of links, the function returns the sum of the capital expenditures for all links whose method of the function has_investment returns true.\n\nnote: Default function\nIt is also possible to provide a tuple ùí≥ for only operational or only investment objective contributions. In this situation, the expression returns a value of 0 for all investment periods.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference_EMIExt/#EnergyModelsBase","page":"EMI extension","title":"EnergyModelsBase","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/#Methods-2","page":"EMI extension","title":"Methods","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/#EnergyModelsBase.variables_capex-Tuple{Any, Vector{<:EnergyModelsBase.Node}, Any, AbstractInvestmentModel}","page":"EMI extension","title":"EnergyModelsBase.variables_capex","text":"EMB.variables_capex(m, ùí©::Vector{<:EMB.Node}, ùíØ, modeltype::AbstractInvestmentModel)\nEMB.variables_capex(m, ‚Ñí::Vector{<:Link}, ùíØ, modeltype::AbstractInvestmentModel)\n\nDeclaration of different capital expenditures (CAPEX) variables for the element types introduced in EnergyModelsBase. CAPEX variables are only introduced for elements that have in investments as identified through the function EMI.has_investment. All investment variables are declared for all investment periods.\n\nEnergyModelsBase introduces two elements for an energy system, and hence, provides the user with two individual methods for both ùí©::Vector{<:EMB.Node} and ùí©::Vector{<:Link}.\n\nnote: Variables and naming conventions\nThe individual capacities require the same variable although with different names. Hence, **prefix** should be replaced in the following tocap for all nodes with investments except for Storage and Availability nodes,\nstor_level for the storage level capacity of Storage nodes,\nstor_charge for the charge capacity of Storage nodes,\nstor_discharge for the discharge capacity of Storage nodes, and\nlink_cap for [Link]s.The individual variables are then given by:**prefix**_capex are the capital expenditures in node n in investment period t_inv. The CAPEX variable take into account the invested capacity.\n**prefix**_current is the capacity of node n in investment period t_inv. It is introduced in addition to cap_inst to simplify the model design.\n**prefix**_add are the additions in the installed capacity of node n in investment period t_inv. Capacity additions are occuring at the beginning of an investment period.\n**prefix**_rem are the reduction in the installed capacity of node n in investment period t_inv. Capacity reductions are occuring at the end of an investment period.\n**prefix**_invest_b is an auxiliary variable used in some investment modes for the additions in capacities.\n**prefix**_remove_b is an auxiliary variable used in some investment modes for the reduction of capacities.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference_EMIExt/#EnergyModelsBase.objective-Tuple{Any, Any, Any, Any, AbstractInvestmentModel}","page":"EMI extension","title":"EnergyModelsBase.objective","text":"EMB.objective(m, ùí≥, ùí´, ùíØ, modeltype::AbstractInvestmentModel)\n\nCreate objective function overloading the default from EMB for AbstractInvestmentModel.\n\nMaximize Net Present Value from investments (CAPEX) and operations (OPEX and emission costs)\n\nTODO:\n\nConsider adding contributions from\n\nrevenue (as positive variable, adding positive)\nmaintenance based on usage (as positive variable, adding negative)\n\nThese variables would need to be introduced through the package SparsVariables.\n\nBoth are not necessary, as it is possible to include them through the OPEX values, but it would be beneficial for a better separation and simpler calculations from the results.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference_EMIExt/#EnergyModelsBase.constraints_capacity_installed-Tuple{Any, EnergyModelsBase.Node, TimeStructure, AbstractInvestmentModel}","page":"EMI extension","title":"EnergyModelsBase.constraints_capacity_installed","text":"constraints_capacity_installed(m, n::Node, ùíØ::TimeStructure, modeltype::AbstractInvestmentModel)\nconstraints_capacity_installed(m, n::Storage, ùíØ::TimeStructure, modeltype::AbstractInvestmentModel)\nconstraints_capacity_installed(m, l::Link, ùíØ::TimeStructure, modeltype::AbstractInvestmentModel)\n\nWhen the modeltype is an investment model, the function introduces the related constraints for the capacity expansion. The investment mode and lifetime mode are used for adding constraints.\n\nThe default function only accepts nodes with SingleInvData. If you have several capacities for investments, you have to dispatch specifically on the node or link type. This is implemented for Storage nodes where the function introduces the related constraints for the capacity expansions for the fields :charge, :level, and :discharge. This requires the utilization of the StorageInvData investment type, in which the investment mode and lifetime mode are used for adding constraints for each capacity.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference_EMIExt/#EnergyModelsBase.check_node_data-Tuple{EnergyModelsBase.Node, InvestmentData, Any, AbstractInvestmentModel, Bool}","page":"EMI extension","title":"EnergyModelsBase.check_node_data","text":"EMB.check_node_data(n::EMB.Node, data::InvestmentData, ùíØ, modeltype::AbstractInvestmentModel, check_timeprofiles::Bool)\nEMB.check_node_data(n::Storage, data::InvestmentData, ùíØ, modeltype::AbstractInvestmentModel, check_timeprofiles::Bool)\n\nPerforms various checks on investment data for standard and Storage nodes.\n\nChecks for standard nodes\n\nEach node can only have a single InvestmentData.\nAll checks incorporated in the function check_inv_data.\n\nChecks for Storage nodes\n\nEach node can only have a single InvestmentData.\nThe InvestmentData must be StorageInvData.\nFor each individual investment field all checks incorporated in the function check_inv_data.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments","page":"EMI extension","title":"EnergyModelsInvestments","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/#Constructors","page":"EMI extension","title":"Constructors","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/","page":"EMI extension","title":"EMI extension","text":"The following constructors are only relevant for the legacy constructors introduced within the extension. They do not provide any additional information.","category":"page"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.BinaryInvestment","page":"EMI extension","title":"EnergyModelsInvestments.BinaryInvestment","text":"When the field cap is not included, it is assumed that its value is FixedProfile(0). This behavior is only for allowing the legacy constructor to work, while it will be removed in the near future.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.ContinuousInvestment","page":"EMI extension","title":"EnergyModelsInvestments.ContinuousInvestment","text":"When the fields min_add and max_add are not included, it is assumed that their values are FixedProfile(0). This behavior is only for allowing the legacy constructor to work, while it will be removed in the near future.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.DiscreteInvestment","page":"EMI extension","title":"EnergyModelsInvestments.DiscreteInvestment","text":"When the field increment is not included, it is assumed that its value is FixedProfile(0). This behavior is only for allowing the legacy constructor to work, while it will be removed in the near future.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.FixedInvestment","page":"EMI extension","title":"EnergyModelsInvestments.FixedInvestment","text":"When the field cap is not included, it is assumed that its value is FixedProfile(0). This behavior is only for allowing the legacy constructor to work, while it will be removed in the near future.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.PeriodLife","page":"EMI extension","title":"EnergyModelsInvestments.PeriodLife","text":"When the field lifetime is not included, it is assumed that its value is FixedProfile(0). This behavior is only for allowing the legacy constructor to work, while it will be removed in the near future.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.RollingLife","page":"EMI extension","title":"EnergyModelsInvestments.RollingLife","text":"When the field lifetime is not included, it is assumed that its value is FixedProfile(0). This behavior is only for allowing the legacy constructor to work, while it will be removed in the near future.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.SemiContinuousInvestment","page":"EMI extension","title":"EnergyModelsInvestments.SemiContinuousInvestment","text":"When the fields min_add and max_add are not included, it is assumed that their values are FixedProfile(0). This behavior is only for allowing the legacy constructor to work, while it will be removed in the near future.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.SemiContinuousOffsetInvestment","page":"EMI extension","title":"EnergyModelsInvestments.SemiContinuousOffsetInvestment","text":"When the fields min_add, max_add, and capex_offset are not included, it is assumed that their values are FixedProfile(0). This behavior is only for allowing the legacy constructor to work, while it will be removed in the near future.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.StudyLife","page":"EMI extension","title":"EnergyModelsInvestments.StudyLife","text":"When the field lifetime is not included, it is assumed that its value is FixedProfile(0). This behavior is only for allowing the legacy constructor to work, while it will be removed in the near future.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference_EMIExt/#Methods-3","page":"EMI extension","title":"Methods","text":"","category":"section"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.has_investment","page":"EMI extension","title":"EnergyModelsInvestments.has_investment","text":"EMI.has_investment(n::EMB.Node)\n\nFor a given Node n, checks that it contains the required investment data.\n\n\n\n\n\nEMI.has_investment(l::Link)\n\nFor a given Link l, checks that it contains the required investment data.\n\n\n\n\n\nEMI.has_investment(n::Storage, field::Symbol)\n\nFor a given Storage node, checks that it contains investments for the field field, that is :charge, :level, or :discharge.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference_EMIExt/#EnergyModelsInvestments.investment_data","page":"EMI extension","title":"EnergyModelsInvestments.investment_data","text":"EMI.investment_data(inv_data::SingleInvData)\n\nReturn the investment data of the investment data SingleInvData.\n\n\n\n\n\nEMI.investment_data(n::EMB.Node)\nEMI.investment_data(l::Link)\nEMI.investment_data(n::EMB.Node, field::Symbol)\nEMI.investment_data(l::Link, field::Symbol)\n\nReturn the InvestmentData of the Node n or Link l. It will return an error if the if the Node n or Link l does not have investment data.\n\nIf field is specified, it returns the InvData for the corresponding capacity.\n\n\n\n\n\n","category":"function"},{"location":"manual/optimization-variables/#man-opt_var","page":"Optimization variables","title":"Optimization variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"EnergyModelsBase creates a variety of default variables for the individual nodes and edges. These default variables are in general also created when new Nodes or Links are developed. It is not necessary to utilize all of the default variables in the individual nodes. It is however recommended to include in this situation constraints or fixes using either the @constraint macro or alternatively the JuMP function fix(x, value). The latter is the recommended approach.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"note: Note\nThe majority of the variables in EnergyModelsBase are rate variables. This imples that they are calculated for either an operational period duration of 1, when indexed over operational period t or a strategic period duration of 1, when indexed over strategic period t_textttinv. Typical units for rates are MW for energy streams, tonne/hour for mass streams, tonne/year for strategic emissions, and ‚Ç¨/year for operational expenditures. In this example, the duration of an operational period of 1 corresponds to an hour, while the duration of a strategic period of 1 corresponds to a year.Variables that are energy/mass based have that property highlighted in the documentation below. In the standard implementation of EnergyModelsBase, this is only the case for the level of a Storage node, the change of level of the node, and its installed capacity.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Rate variables can as well be translated to mass/energy variables. As an example, the total quantity that flows into a node n during the operational period t can found by","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"m[:flow_in][n, t, p] * duration(t)","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The multiplication then leads to an energy/mass quantity in stead of an energy/mass flow.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The coupling of strategic and operational periods can be achieved through the function scale_op_sp(t, t_inv). This functions allows for considering the scaling of the operational periods within a strategic period.","category":"page"},{"location":"manual/optimization-variables/#man-opt_var-opex","page":"Optimization variables","title":"Operational cost variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Operational cost variables are included to account for operational expenditures (OPEX) of the model. These costs are pure dependent on either the use or the installed capacity of a node n. All nodes n (except Availability-nodes) have the following variables representing the operational costs of the nodes:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_varn t_textttinv: Variable OPEX of node n in strategic period t_textttinv.\ntextttopex_fixedn t_textttinv: Fixed OPEX of node n in strategic period t_textttinv.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The variable OPEX is a cost that derives from using a technology. It is calculated using the function constraints_opex_var. In general, it represents unmodelled feed to a process and the associated costs. Examples are catalyst replacement, cooling water or process water. The variable OPEX can also be utilized to provide values for a profit through using a technology.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The fixed OPEX is a cost that is independent of the usage of a technology. Instead, it is only dependent on the installed capacity. It is calculated using the function constraints_opex_fixed. It represents fixed costs like labour cost, maintenance, as well as insurances and taxes.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"We also introduce the potential for links with operational costs. By default, links do not introduce new variables. Operational cost variables are only created for a link l if the function has_opex(n::Link) returns true. The following link variables are then declared representing the operational costs of the links:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttlink_opex_varl t_textttinv:  Variable OPEX of link l in strategic period t_textttinv.\ntextttlink_opex_foxedl t_textttinv:  Fixed OPEX of link l in strategic period t_textttinv.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"tip: Links with OPEX\nAll links introduced in EnergyModelsBase do not allow for operational costs. If you plan to introduce a link with operational costs, you have to create a new method for the function has_opex for your introduced link.","category":"page"},{"location":"manual/optimization-variables/#man-opt_var-cap","page":"Optimization variables","title":"Capacity variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Capacity variables focus on both the capacity usage and installed capacity. The capacity variables are also created for all nodes except for Availability nodes. Capacity variables are differentiated between Storage nodes and all other Nodes. The implementation of the capacity variables allows for a time-varying capacity during an operational period for inclusion of variations in the demand in Sink nodes. It is however not possible to invest into a time-varying capacity.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The following capacity variables are created for node types other than Storage:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttcap_usen t: Absolute capacity usage of node n at operational period t, and\ntextttcap_instn t: Installed capacity of node n at operational period t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The capacity usage textttcap_use is the utilization of the installed capacity. It is declared in absolute values to avoid bilinearities when investing in capacities. It is normally constrained by the variable textttcap_inst of the individual nodes, except for Sink nodes.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The capacity variables for Storage nodes differentiate between storage capacity (stored energy in the Storage node) and rate of storage (storage rate of a Storage node). The latter is furthermore differentiated between charging and discharging a Storage node. A key reasoning for this approach is that it is in general possible to invest both in the storage rate (e.g., the AC-DC transformer required in battery storage) as well as the storage capacity (e.g. the number of cells in battery storage). The same holds as well for pumped hydro storage and storage of gases where there is a further differentiation between the maximum charging and discharging rates. The differentiation leads to the following variables for Storage nodes:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttstor_leveln t: Absolute level of energy/mass stored in a Storage node n at operational period t with a typical unit of GWh or t,\ntextttstor_level_instn t: Installed storage capacity in a Storage node n at operational period t , that is the upper bound for the variable textttstor_leveln t, with a typical unit of GWh or t,\ntextttstor_charge_usen t: Usage of the charging rate of a Storage node n at operational period t with a typical unit of GW or t/h,\ntextttstor_charge_instn t: Maximum available charging rate of a Storage node n at operational period t, that is the upper bound for the variable textttstor_charge_usen t, with a typical unit of GW or t/h.\ntextttstor_discharge_usen t: Usage of the discharging rate of a Storage node n at operational period t with a typical unit of GW or t/h, and\ntextttstor_discharge_instn t: Maximum available discharging rate of a Storage node n at operational period t, that is the upper bound for the variable textttstor_discharge_usen t, with a typical unit of GW or t/h.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"note: Note\nIt is not necessary that a Storage node has a charge and discharge capacity. It is possible to not specify a capacity for charge and discharge. In this instance, the variables for the intalled capacities are omitted and the charge and discharge usage is unlimited.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The storage level is always defined for the end of the operational period it is indexed over. There are in addition two variables for the storage level that behave slightly different:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttstor_level_Œî_opn t: Change of the absolute level of energy/mass stored in a Storage node n in operational period t with a typical unit of GWh or t, and\ntextttstor_level_Œî_rpn t_rp: Change of the absolute level of energy/mass stored in a Storage node n in representative period t_rp with a typical unit of GWh or t, and\ntextttstor_level_Œî_spn t_textttinv: Change of the absolute level of energy/mass stored in a Storage node n in strategic period t_textttinv with a typical unit of GWh or t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"These variables are introduced to track the change in the storage level in an operational period, a representative period, or an investment period, respectively. They can be considered as helper variables to account for the duration of the operational period as well as the total change within a representative period. textttstor_level_Œî_rp is only declared if the TimeStructure includes RepresentativePeriods while textttstor_level_Œî_sp is introduced as an empty SparseVariables container. The application of RepresentativePeriods is explained in How to use TimeStruct.jl. The utilization of textttstor_level_Œî_sp requires to include in the function variables_node for the given Storage array ùí©À¢·µò·µá::Vector{<:NewStorageNode} as, e.g., the following loop","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"for t_inv ‚àà ùíØ·¥µ‚Åø·µõ, n ‚àà ùí©À¢·µò·µá\n    insertvar!(m[:stor_level_Œî_sp], n, t_inv)\nend","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"We also introduce the potential for links with capacities. By default, links do not introduce new variables. The capacity variable is only created for a link l if the function has_capacity(n::Link) returns true. The following link variable ise then declared representing the capacity of links:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttlink_cap_instl t: Installed capacity of link l at operational period t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"tip: Links with a capacity\nAll links introduced in EnergyModelsBase do not allow for a capacity limiting the transfer. If you plan to introduce a link with a capacity, you have to create a new method for the function has_capacity for your introduced link.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"note: Inclusions of investments\nThe variables textttcap_inst, textttstor_charge_inst, textttstor_level_inst, textttstor_discharge_inst, and textttlink_cap_inst are used in EnergyModelsInvestment to allow for investments in capacity of individual nodes.","category":"page"},{"location":"manual/optimization-variables/#man-opt_var-flow","page":"Optimization variables","title":"Flow variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Flow variables correspond to the input to and output from both technology nodes and links. They are always positive to avoid backflow.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The following flow variables are defined for the nodes:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttflow_inn t p represents the flow rate of resource p into node n at operational period t. It is created for subtypes of the types NetworkNode and Sink based on the field input in the composite type.\ntextttflow_outn t p represents the flow rate of resource p out of node n at operational period t. It is created for subtypes of the types Source and NetworkNode based on the field output in the composite type.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Links also have corresponding flow variables given by:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttlink_inn t p represents the flow rate of resource p into link l at operational period t, and\ntextttlink_outn t p represents the flow rate of resource p out of link l at operational period t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The resource index p is created based on the intersection of the output of the input node n_in and the input of the output node n_out through the function EMB.link_res(l::Link). Mathematically, this is given as","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"mathcalP^link = mathcalP^n^out_in cap mathcalP^n^in_out","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"It is also possible to create a new method for this function to limit the resources a link can transport.","category":"page"},{"location":"manual/optimization-variables/#man-opt_var-emissions","page":"Optimization variables","title":"Emission variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Emission variables are used for accounting for emissions of the individual technologies. Resources that can be emitted are defined through the type ResourceEmit. Nodes do not necessarily have associated emission variables. Emission variables are only created for a node n if the function has_emissions(n::EMB.Node) returns true. This is the case for all nodes that have EmissionsData within their field data as well as for a RefStorage node if a ResourceEmit is stored. The following node variable is then declared for all emission resource ùí´·µâ·µê:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttemissions_noden t p_textttem:  Emissions of node n at operational period t of emission resource p_textttem.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Similarly, it is not necessary that links have associated emission variables. Emission variables are only created for a link l if the function has_emissions(n::Link) returns true. The following link variable is then declared for all emission resource ùí´·µâ·µê:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttemissions_linkn t p_textttem:  Emissions of link l at operational period t of emission resource p_textttem.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"tip: Links with emissions\nAll links introduced in EnergyModelsBase do not allow for emissions. If you plan to introduce a link with emissions, you have to create a new method for the function has_emissions for your introduced link.We have not implemented a similar approach as for nodes. It is however planned to allow for transmission emissions in the near future, similar to the concept employed for process emissions for nodes.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"In addition, EnergyModelsBase declares the following variables for the global emissions:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttemissions_totalt p_textttem: Total emissions of ResourceEmit p_textttem in operational period t, and\ntextttemissions_strategict_textttinv p_textttem: Total emissions of ResourceEmit p_textttem in strategic period t_textttinv.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"These emission variables introduce limits on the total emissions of a resource through the field emission_limit of an EnergyModel in the function EMB.variables_emission.","category":"page"},{"location":"manual/optimization-variables/#man-opt_var-sink","page":"Optimization variables","title":"Sink variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"Sink nodes are somehow different to the other nodes as they have additional variables associated with them. A key point here is to keep the overall mass balance intact while allowing for both overfulfilling and not meeting the demand. These variables are:","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttsink_surplusn t: Surplus of energy/mass to Sink n at operational period t, and\ntextttsink_deficitn t: Deficit of energy/mass to Sink n at operational period t.","category":"page"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"The surplus in a sink corresponds to the energy/mass that is supplied to the sink in addition to the demand. The deficit in a sink corresponds to the energy/mass that is not supplied to the sink although the demand is specified. Both variables correspond to slack variables of the optimization problem. They simplify the problem and can make certain types of formulations feasible. It is possible to provide penalties for both surplus and deficits. This is implemented through the field penalty in the RefSource node.","category":"page"},{"location":"manual/optimization-variables/#man-opt_var-node","page":"Optimization variables","title":"Node types and respective variables","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"As outlined in the introduction, EnergyModelsBase declares different variables for each Node. These variables are for the individual nodes given in the subsections below.","category":"page"},{"location":"manual/optimization-variables/#Source","page":"Optimization variables","title":"Source","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data","category":"page"},{"location":"manual/optimization-variables/#NetworkNode,-except-for-Storage","page":"Optimization variables","title":"NetworkNode, except for Storage","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data","category":"page"},{"location":"manual/optimization-variables/#Storage","page":"Optimization variables","title":"Storage","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_var\ntextttopex_fixed\ntextttstor_level\ntextttstor_level_inst\ntextttstor_charge_use\ntextttstor_charge_inst, if the Storage node has a field :charge with the StorageParameters corresponding to capacity storage parameters\ntextttstor_discharge_use\ntextttstor_discharge_inst, if the Storage node has a field :discharge with the StorageParameters corresponding to capacity storage parameters\ntextttstor_level_Œî_op\ntextttstor_level_Œî_rp if the TimeStruct includes RepresentativePeriods\ntextttstor_level_Œî_sp if the function variables_node is declared for the new Storage type\ntextttflow_in\ntextttflow_out\ntextttemissions_node if ResourceEmit is stored","category":"page"},{"location":"manual/optimization-variables/#Sink","page":"Optimization variables","title":"Sink","text":"","category":"section"},{"location":"manual/optimization-variables/","page":"Optimization variables","title":"Optimization variables","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttsink_surplus\ntextttsink_deficit\ntextttemissions_node if EmissionsData is added to the field data","category":"page"},{"location":"manual/data-functions/#man-data_fun","page":"Data functions","title":"Data functions","text":"","category":"section"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"The package provides the wildcard Data type as outlined in the Extensions to the model section of the philosophy page. Data can be utilized to extend the functionality of the model through dispatching on its type. The following function is included in all reference create_node functions, except for Storage types","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"# Iterate through all data and set up the constraints corresponding to the data\nfor data ‚àà node_data(n)\n    constraints_data(m, n, ùíØ, ùí´, modeltype, data)\nend","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"There is always a fallback option if a Data is specified, but no functions are provided:","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"constraints_data(m, n::Node, ùíØ, ùí´, modeltype::EnergyModel, data::Data) = nothing","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"Its application is best explained by the implemented functionality for emissions.","category":"page"},{"location":"manual/data-functions/#man-data_fun-emissions","page":"Data functions","title":"Emissions data","text":"","category":"section"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"Emissions data is an application of extensions via the application of the wildcard data field in the nodes. It allows to consider:","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"no emissions of a node (no EmissionsData type has to be provided),\nenergy usage related emissions of a node, that is emissions through the utilization of an energy carrier (EmissionsEnergy) given as input,\nthe combination of process emissions and energy usage related emissions (EmissionsProcess),\nCO‚ÇÇ capture of energy usage related emissions (CaptureEnergyEmissions),\nCO‚ÇÇ capture of process emissions (CaptureProcessEmissions), and\nCO‚ÇÇ capture of both process and energy usage related emissions (CaptureProcessEnergyEmissions).","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"The individual fields of the different types are described in the Public interface.","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"The extension is then implemented through the functions","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"function constraints_data(m, n::Node, ùíØ, ùí´, modeltype, data::EmissionsEnergy)\nfunction constraints_data(m, n::Node, ùíØ, ùí´, modeltype, data::EmissionsProcess)\nfunction constraints_data(m, n::Node, ùíØ, ùí´, modeltype, data::CaptureEnergyEmissions)\nfunction constraints_data(m, n::Node, ùíØ, ùí´, modeltype::EnergyModel, data::CaptureProcessEmissions)\nfunction constraints_data(m, n::Node, ùíØ, ùí´, modeltype::EnergyModel, data::CaptureProcessEnergyEmissions)","category":"page"},{"location":"manual/data-functions/","page":"Data functions","title":"Data functions","text":"in the file data_functions.jl. Correspondingly, we require only a single implementation of a Node to investigate multiple different emission scenarios, depending on the chosen EmissionsData. Both EmissionsEnergy and EmissionsProcess can handle input similar to the other EmissionsData types, allowing for a fast switch between individual emission configurations.","category":"page"},{"location":"nodes/availability/#nodes-availability","page":"Availability","title":"Availability node","text":"","category":"section"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"Availability nodes are routing technologies. The aim of incorporating this type of nodes is to reduce the required number of links if you have multiple conversion technologies for a single energy carrier. Consider, e.g., a system in which you have 10 electricity generation technologies having electricity as output. This could be a combination of Source and NetworkNode. You have furthermore 10 technologies requiring electricity as input as combination of NetworkNode and Sink.","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"If you plan to allow for electricity transfer from all gebeneration to demand nodes, you would require in total 10 times 10 = 100 links. If you use the Availability instead, this would reduce to 10 + 10 = 20 links. significantly reducing the pre-processing requirement. In the latter case, all nodes are connected to the Availability node.","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"tip: Usage of `Availability`\nIt is still possible to have direct connection between individual nodes for given resources. This allows, e.g., to investigate the trade-off between off-grid and on-grid electrolysis. In this case, the electrolysis node should not have an input connection with the Availability node, but with the electricity source node. Similarly, the electricity source node should not be connection to the Availability node.The Links are only transferring a Resource if it is specified as the output of the origin node and the input of the destination node. This implies you can even have multiple connections from a node and avoid transfer via the Availability node. This is especially relevant for retrofit CO‚ÇÇ capture.","category":"page"},{"location":"nodes/availability/#nodes-availability-fields","page":"Availability","title":"Introduced type and its fields","text":"","category":"section"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"The GenAvailability node is implemented as a reference node that can be used for an Availability. It includes basic functionalities common to most energy system optimization models.","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"The fields of a GenAvailability node are given as:","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"id:\nThe field id is only used for providing a name to the node.\ninput::Vector{<:Resource} and output::Vector{<:Resource}:\nBoth fields describe the input and output Resources as vectors. This approach is different to all other nodes, but simplifies the overall design. It is necessary to specify the same Resources to allow for capacity usage in connected nodes.","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"tip: Constructor `GenAvailability`\nWe require at the time being the specification of the fields input and output due to the way we identify the required flow and link variables. In practice, both fields should include the same Resources. To this end, we provide a simplified constructor in which you only have to specify one vector using the functionGenAvailability(id, ùí´::Vector{<:Resource})","category":"page"},{"location":"nodes/availability/#nodes-availability-math","page":"Availability","title":"Mathematical description","text":"","category":"section"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"textttvar_exampleindex_1 index_2","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"with square brackets, while functions are represented as","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"func_example(index_1 index_2)","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"with paranthesis.","category":"page"},{"location":"nodes/availability/#nodes-availability-math-var","page":"Availability","title":"Variables","text":"","category":"section"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"The variables of Availability nodes include:","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"textttflow_in\ntextttflow_out","category":"page"},{"location":"nodes/availability/#nodes-availability-math-con","page":"Availability","title":"Constraints","text":"","category":"section"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"Availability nodes do not add by default any constraints, except for the constraints introduced in the function create_node(@ref). This constraint is given by:","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"textttflow_outn t p = textttflow_inn t p qquad forall p in inputs(n)","category":"page"},{"location":"nodes/availability/","page":"Availability","title":"Availability","text":"This implies that standard availability nodes serve only as energy balance nodes for all other nodes.","category":"page"},{"location":"library/internals/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"library/internals/types/#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"library/internals/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"library/internals/types/#Nodal-and-link-supertypes","page":"Types","title":"Nodal and link supertypes","text":"","category":"section"},{"location":"library/internals/types/#EnergyModelsBase.Node","page":"Types","title":"EnergyModelsBase.Node","text":"Node as supertype for all technologies.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types/#EnergyModelsBase.Formulation","page":"Types","title":"EnergyModelsBase.Formulation","text":"Declaration of the general type for formulation of links.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types/#Parameter-supertypes","page":"Types","title":"Parameter supertypes","text":"","category":"section"},{"location":"library/internals/types/#EnergyModelsBase.StorageBehavior","page":"Types","title":"EnergyModelsBase.StorageBehavior","text":"StorageBehavior as supertype for individual storage behaviours.\n\nStorage behaviour is used to identify how a storage node should behave within the individual TimeStructures of a strategic period.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types/#EnergyModelsBase.AbstractStorageParameters","page":"Types","title":"EnergyModelsBase.AbstractStorageParameters","text":"AbstractStorageParameters as supertype for individual parameters for Storage nodes.\n\nStorage parameters are used to provide the user the flexibility to include or not include capacities and variable and fixed OPEX parameters for charging, the storage level, and discharging.\n\n\n\n\n\n","category":"type"},{"location":"library/public/misc/#lib-pub-misc_type","page":"Miscellaneous","title":"Miscellaneous types/functions/macros","text":"","category":"section"},{"location":"library/public/misc/#Index","page":"Miscellaneous","title":"Index","text":"","category":"section"},{"location":"library/public/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Pages = [\"misc.md\"]","category":"page"},{"location":"library/public/misc/#Module","page":"Miscellaneous","title":"Module","text":"","category":"section"},{"location":"library/public/misc/#EnergyModelsBase","page":"Miscellaneous","title":"EnergyModelsBase","text":"Main module for EnergyModelsBase a framework for building flexible energy system models.\n\nIt exports several types and associated functions for accessing fields. In addition, all required functions for creaeting and running the model are exported.\n\nYou can find the exported types and functions below or on the pages Constraint functions and Data functions.\n\n\n\n\n\n","category":"module"},{"location":"library/public/misc/#lib-pub-misc_type-prev_cyclic","page":"Miscellaneous","title":"PreviousPeriods and CyclicPeriods","text":"","category":"section"},{"location":"library/public/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"PreviousPeriods is a type used to store information from the previous periods in an iteration loop through the application of the iterator withprev of TimeStruct.","category":"page"},{"location":"library/public/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"CyclicPeriods is used for storing the current and the last period. The periods can either be AbstractStrategicPeriod or AbstractRepresentativePeriod. In the former case, it is however not fully used as the last strategic period is not relevant for the level balances.","category":"page"},{"location":"library/public/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Both composite types allow only EMB.NothingPeriod types as input to the individual fields.","category":"page"},{"location":"library/public/misc/#EnergyModelsBase.PreviousPeriods","page":"Miscellaneous","title":"EnergyModelsBase.PreviousPeriods","text":"PreviousPeriods{S<:NothingPeriod, T<:NothingPeriod, U<:NothingPeriod}\n\nContains the previous strategic, representative, and operational period used through the application of the with_prev iterator developed in TimeStruct.\n\nFields\n\nsp::S is the previous strategic period.\nrp::T is the previous representative period.\nop::U is the previous operational period.\n\n\n\n\n\n","category":"type"},{"location":"library/public/misc/#EnergyModelsBase.CyclicPeriods","page":"Miscellaneous","title":"EnergyModelsBase.CyclicPeriods","text":"CyclicPeriods{S<:NothingPeriod}\n\nContains information for calculating the cyclic constraints. The parameter S should be either an AbstractStrategicPeriod or AbstractRepresentativePeriod.\n\nFields\n\nlast_per::S is the last period in the case of S<:AbstractRepresentativePeriod or the current period in the case of S<:AbstractStrategicPeriod as the last strategic period is not relevant.\ncurrent_per::S is the current period in both the case of S<:AbstractRepresentativePeriod and S<:AbstractStrategicPeriod.\n\n\n\n\n\n","category":"type"},{"location":"library/public/misc/#EnergyModelsBase.NothingPeriod","page":"Miscellaneous","title":"EnergyModelsBase.NothingPeriod","text":"Union of Nothing, TS.TimePeriod, and TS.TimeStructure{T} where {T} to be used for limiting the potential entries to the fields of PreviousPeriods and CyclicPeriods types.\n\n\n\n\n\n","category":"type"},{"location":"library/public/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"The individual fields can be accessed through the following functions:","category":"page"},{"location":"library/public/misc/#EnergyModelsBase.strat_per","page":"Miscellaneous","title":"EnergyModelsBase.strat_per","text":"strat_per(prev_periods::PreviousPeriods)\n\nExtracts the previous strategic period (field sp) from a PreviousPeriods type.\n\n\n\n\n\n","category":"function"},{"location":"library/public/misc/#EnergyModelsBase.rep_per","page":"Miscellaneous","title":"EnergyModelsBase.rep_per","text":"rep_per(prev_periods::PreviousPeriods)\n\nExtracts the previous representative period (field rp) from a PreviousPeriods type.\n\n\n\n\n\n","category":"function"},{"location":"library/public/misc/#EnergyModelsBase.op_per","page":"Miscellaneous","title":"EnergyModelsBase.op_per","text":"op_per(prev_periods::PreviousPeriods)\n\nExtracts the previous operational period (field op) from a PreviousPeriods type.\n\n\n\n\n\n","category":"function"},{"location":"library/public/misc/#EnergyModelsBase.last_per","page":"Miscellaneous","title":"EnergyModelsBase.last_per","text":"last_per(cyclic_pers::CyclicPeriods)\n\nExtracts the last period (field last_per) from a CyclicPeriods type.\n\n\n\n\n\n","category":"function"},{"location":"library/public/misc/#EnergyModelsBase.current_per","page":"Miscellaneous","title":"EnergyModelsBase.current_per","text":"current_per(cyclic_pers::CyclicPeriods)\n\nExtracts the current period (field current_per) from a CyclicPeriods type.\n\n\n\n\n\n","category":"function"},{"location":"library/public/misc/#lib-pub-misc_type-macros","page":"Miscellaneous","title":"Macros for checking the input data","text":"","category":"section"},{"location":"library/public/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"The macro @assert_or_log is an extension to the @assert macro to allow either for asserting the input data directly, or logging the errors in the input data.","category":"page"},{"location":"library/public/misc/#EnergyModelsBase.@assert_or_log","page":"Miscellaneous","title":"EnergyModelsBase.@assert_or_log","text":"assert_or_log(ex, msg)\n\nMacro that extends the behaviour of the @assert macro. The switch ASSERTS_AS_LOG, controls if the macro should act as a logger or a normal @assert. This macro is designed to be used to check whether the data provided is consistent.\n\n\n\n\n\n","category":"macro"},{"location":"library/internals/functions/#Internal-functions","page":"Functions","title":"Internal functions","text":"","category":"section"},{"location":"library/internals/functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"library/internals/functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"library/internals/functions/#Extension-functions","page":"Functions","title":"Extension functions","text":"","category":"section"},{"location":"library/internals/functions/#EnergyModelsBase.create_link","page":"Functions","title":"EnergyModelsBase.create_link","text":"create_link(m, ùíØ, ùí´, l::Link, formulation::Formulation)\n\nSet the constraints for a simple Link (input = output). Can serve as fallback option for all unspecified subtypes of Link.\n\nAll links with capacity, as indicated through the function has_capacity call furthermore the function constraints_capacity_installed for limiting the capacity to the installed capacity.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.objective-Tuple{Any, Any, Any, Any, EnergyModel}","page":"Functions","title":"EnergyModelsBase.objective","text":"objective(m, ùí≥, ùí´, ùíØ, modeltype::EnergyModel)\n\nCreate the objective for the optimization problem for a given modeltype.\n\nThe default option includes to the objective function:\n\nthe variable and fixed operating expenses for the individual nodes,\nthe variable and fixed operating expenses for the individual links, and\nthe cost for the emissions.\n\nThe values are not discounted.\n\nThis function serve as fallback option if no other method is specified for a specific modeltype.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/functions/#EnergyModelsBase.objective_operational","page":"Functions","title":"EnergyModelsBase.objective_operational","text":"objective_operational(m, elements, ùíØ·¥µ‚Åø·µõ::TS.AbstractStratPers, modeltype::EnergyModel)\n\nCreate JuMP expressions indexed over the investment periods ùíØ·¥µ‚Åø·µõ for different elements. The expressions correspond to the operational expenses of the different elements. The expressions are not discounted and do not take the duration of the investment periods into account.\n\nBy default, objective expressions are included for:\n\nelements = ùí©::Vector{<:Node}. In the case of a vector of nodes, the function returns the sum of the variable and fixed OPEX for all nodes whose method of the function has_opex returns true.\nelements = ùí©::Vector{<:Link}. In the case of a vector of links, the function returns the sum of the variable and fixed OPEX for all links whose method of the function has_opex returns true.\nelements = ùí©::Vector{<:Resource}. In the case of a vector of resources, the function returns the costs associated to the emissions using the function emission_price.\n\nnote: Default function\nIt is also possible to provide a tuple ùí≥ for only operational or only investment objective contributions. In this situation, the expression returns a value of 0 for all investment periods.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.emissions_operational","page":"Functions","title":"EnergyModelsBase.emissions_operational","text":"emissions_operational(m, elements, ùí´·µâ·µê, ùíØ, modeltype::EnergyModel)\n\nCreate JuMP expressions indexed over the operational periods ùíØ for different elements. The expressions correspond to the total emissions of a given type.\n\nBy default, objective expressions are included for:\n\nelements = ùí©::Vector{<:Node}. In the case of a vector of nodes, the function returns the sum of the emissions of all nodes whose method of the function has_emissions returns true. These nodes should be automatically identified without user intervention.\nelements = ùí©::Vector{<:Link}. In the case of a vector of links, the function returns the sum of the emissions of all links whose method of the function has_emissions returns true.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#Constraint-functions","page":"Functions","title":"Constraint functions","text":"","category":"section"},{"location":"library/internals/functions/#EnergyModelsBase.constraints_emissions","page":"Functions","title":"EnergyModelsBase.constraints_emissions","text":"constraints_emissions(m, ùí≥, ùí´, ùíØ, modeltype::EnergyModel)\n\nCreate constraints for the emissions accounting for both operational and strategic periods.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.constraints_links","page":"Functions","title":"EnergyModelsBase.constraints_links","text":"constraints_links(m, ùí©, ùíØ, ùí´, ‚Ñí, modeltype::EnergyModel)\n\nCall the function create_link for link formulation.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.constraints_node","page":"Functions","title":"EnergyModelsBase.constraints_node","text":"constraints_node(m, ùí©, ùíØ, ùí´, ‚Ñí, modeltype::EnergyModel)\n\nCreate link constraints for each n ‚àà ùí© depending on its type and calling the function create_node(m, n, ùíØ, ùí´) for the individual node constraints.\n\nCreate constraints for fixed OPEX.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.constraints_level_iterate","page":"Functions","title":"EnergyModelsBase.constraints_level_iterate","text":"constraints_level_iterate(\n    m,\n    n::Storage,\n    prev_pers::PreviousPeriods,\n    cyclic_pers::CyclicPeriods,\n    per,\n    ts::RepresentativePeriods,\n    modeltype::EnergyModel,\n)\n\nIterate through the individual time structures of a Storage node. This iteration function should in general allow for all necessary functionality for incorporating modifications.\n\nIn the case of RepresentativePeriods, this is achieved through calling the function constraints_level_rp to introduce, e.g., cyclic constraints as it is in the default case.\n\n\n\n\n\nconstraints_level_iterate(\n    m,\n    n::Storage,\n    prev_pers::PreviousPeriods,\n    per,\n    ts::OperationalScenarios,\n    modeltype::EnergyModel,\n)\n\nIn the case of OperationalScenarios, this is achieved through calling the function constraints_level_scp. In the default case, no constraints are added.\n\n\n\n\n\nconstraints_level_iterate(\n    m,\n    n::Storage,\n    prev_pers::PreviousPeriods,\n    per,\n    ts::SimpleTimes,\n    modeltype::EnergyModel,\n)\n\nIn the case of SimpleTimes, the iterator function is at its lowest level. In this situation,the previous level is calculated using the function previous_level and used for the storage balance. The the approach for calculating the  previous_level is depending on the types in the parameteric type PreviousPeriods.\n\nIn addition, additional bounds can be included on the initial level within an operational period.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.constraints_level_rp","page":"Functions","title":"EnergyModelsBase.constraints_level_rp","text":"constraints_level_rp(m, n::Storage, per, modeltype::EnergyModel)\n\nProvides additional contraints for representative periods.\n\nThe default approach is to set the total change in all representative periods within a strategic period to 0. This implies that the Storage node cannot accumulate energy between individual strategic periods.\n\n\n\n\n\nconstraints_level_rp(m, n::Storage{<:Accumulating}, per, modeltype::EnergyModel)\n\nWhen a Storage{<:Accumulating} is used, the cyclic constraint for restricting the level change within a strategic period to 0 (through setting the sum of :stor_level_Œî_rp within a strategic period to 0) is not implemented as accumulation within a strategic period is desirable.\n\nThis implies that Accumulating behaviours require the developer to introduce the function previous_level in the case of prev_pers = PreviousPeriods{<:NothingPeriod, Nothing, Nothing}.\n\n\n\n\n\nconstraints_level_rp(m, n::Storage{CyclicRepresentative}, per, modeltype::EnergyModel)\n\nWhen a Storage{CyclicRepresentative} is used, the change in the representative period is constrained to 0.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.constraints_level_scp","page":"Functions","title":"EnergyModelsBase.constraints_level_scp","text":"constraints_level_scp(m, n::Storage, per, modeltype::EnergyModel)\n\nProvides additional constraints for scenario periods.\n\nThe default approach is to not provide any constraints.\n\n\n\n\n\nconstraints_level_scp(m, n::Storage{<:Cyclic}, per::TS.AbstractStrategicPeriod, modeltype::EnergyModel)\n\nWhen a Storage{<:Cyclic} is used in a time structure without RepresentativeProfile, the final level in an operational scenario is constrained to be the same in all operational scenarios for the cyclic constraints.\n\n\n\n\n\nconstraints_level_scp(m, n::Storage{CyclicRepresentative}, per::TS.AbstractRepresentativePeriod, modeltype::EnergyModel)\n\nWhen a Storage{CyclicRepresentative} is used, the final level in an operational scenario is constrained to be the same in all operational scenarios.\n\nThis function is required in addition to enforce the CyclicRepresentative constraint.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.constraints_level_bounds","page":"Functions","title":"EnergyModelsBase.constraints_level_bounds","text":"constraints_level_bounds(\n    m,\n    n::Storage,\n    t::TS.TimePeriod,\n    prev_pers::TS.TimePeriod,\n    modeltype::EnergyModel,\n)\n\nProvides bounds on the initial storage level in an operational period to account for the level being modelled at the end of the operational periods.\n\nThe default approach is to not provide bounds.\n\n\n\n\n\nconstraints_level_bounds(\n    m,\n    n::Storage,\n    t::TS.TimePeriod,\n    cyclic_pers::CyclicPeriods{<:TS.AbstractRepresentativePeriod},\n    modeltype::EnergyModel,\n)\n\nWhen representative periods are used and the previous operational  period is nothing, then bounds are incorporated to avoid that the initial level storage level is violating the maximum and minimum level.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#Variable-creation-functions","page":"Functions","title":"Variable creation functions","text":"","category":"section"},{"location":"library/internals/functions/#EnergyModelsBase.variables_capacity","page":"Functions","title":"EnergyModelsBase.variables_capacity","text":"variables_capacity(m, ùí©::Vector{<:Node}, ùíØ, modeltype::EnergyModel)\nvariables_capacity(m, ‚Ñí::Vector{<:Link}, ùíØ, modeltype::EnergyModel)\n\nDeclaration of different capacity variables for the element types introduced in EnergyModelsBase. EnergyModelsBase introduces two elements for an energy system, and hence, provides the user with two individual methods:\n\nnote: Node variables\nAll nodes, excluding Storage and Availability nodes have the following capacity variables:cap_use[n, t] is the capacity utilization of node n in operational period t.\ncap_inst[n, t] is the installed capacity of node n in operational period t.Storage nodes have multiple capacities. The storage level (the amount of mass/energy) stored is described through the followign variablesstor_level[n, t] is the storage level of storage n at the end of operational period t.\nstor_level_Œî_op[n, t] is the storage level change of storage n in operational period t.\nstor_level_Œî_rp[n, t_rp] is the storage level change of storage n in representative period t_rp. These variables are only created if the time structure includes representative periods.\nstor_level_Œî_sp[n, t_inv] is storage level change of storage n in investment period t_inv. These variables are optional and created through SparseVariables. This implies you have to create a method for the function variables_node for your node type that should use these variables.\nstor_level_inst[n, t] is the installed storage capacity for storage n in operational period t, constrained in the operational case to the provided capacity in the storage parameters used in the field :level.The charge capacity variables are describing the charging of a Storage:stor_charge_use[n, t] is the charging rate of storage n in operational period t.\nstor_charge_inst[n, t] is the installed charging capacity, e.g., power, of storage n in operational period t, constrained in the operational case to the provided capacity in the storage parameters used in the field :charge. This variable is only declared if the Storage node has a field charge and the storage parameters include a capacity.The discharge capacity variables are describing the discharging of a Storage:stor_discharge_use[n, t] is the discharging rate of storage n in operational period t.\nstor_discharge_inst[n, t] is the installed discharging capacity, e.g., power, of storage n in operational period t, constrained in the operational case to the provided capacity in the storage parameters used in the field :discharge. This variable is only declared if the Storage node has a field discharge and the storage parameters include a capacity.\n\ntip: Link variables\nThe capacity variables are only created for links, if the function has_capacity has received an additional method for a given link l returning the value true.link_cap_inst[l, t] is the installed capacity of link l in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.variables_flow","page":"Functions","title":"EnergyModelsBase.variables_flow","text":"variables_flow(m, ùí©::Vector{<:Node}, ùíØ, modeltype::EnergyModel)\nvariables_flow(m, ‚Ñí::Vector{<:Link}, ùíØ, modeltype::EnergyModel)\n\nDeclaration of flow OPEX variables for the element types introduced in EnergyModelsBase. EnergyModelsBase introduces two elements for an energy system, and hence, provides the user with two individual methods:\n\nnote: Node variables\nflow_in[n, t, p] is the flow into node n in operational period t for resource p. The inflow resources of node n are extracted using the function inputs.\nflow_out[n, t, p] is the flow from node n in operational period t for resource p. The outflow resources of node n are extracted using the function outputs.\n\ntip: Link variables\nlink_in[n, t] is the flow into link l in operational period t for resource p. The inflow resources of link l are extracted using the function inputs.\nlink_out[n, t, p] is the flow from link l in operational period t for resource p. The outflow resources of link l are extracted using the function outputs.\n\nBy default, all nodes ùí© and links ‚Ñí only allow for unidirectional flow. You can specify bidirection flow through providing a method to the function is_unidirectional for new link/node types.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.variables_opex","page":"Functions","title":"EnergyModelsBase.variables_opex","text":"variables_opex(m, ùí©::Vector{<:Node}, ùíØ, modeltype::EnergyModel)\nvariables_opex(m, ‚Ñí::Vector{<:Link}, ùíØ, modeltype::EnergyModel)\n\nDeclaration of different OPEX variables for the element types introduced in EnergyModelsBase. EnergyModelsBase introduces two elements for an energy system, and hence, provides the user with two individual methods:\n\nnote: Node variables\nopex_var[n, t_inv] are the variable operating expenses of node n in investment period t_inv. The values can be negative to account for revenue streams\nopex_fixed[n, t_inv] are the fixed operating expenses of node n in investment period t_inv.\n\ntip: Link variables\nThe OPEX variables are only created for links, if the function has_opex has received an additional method for a given link l returning the value true.link_opex_var[n, t_inv] are the variable operating expenses of link l in investment period t_inv. The values can be negative to account for revenue streams\nlink_opex_fixed[n, t_inv] are the fixed operating expenses of node n in investment period t_inv.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.variables_capex-Tuple{Any, Vector{<:EnergyModelsBase.Node}, Any, EnergyModel}","page":"Functions","title":"EnergyModelsBase.variables_capex","text":"variables_capex(m, ùí©::Vector{<:Node}, ùíØ, modeltype::EnergyModel)\nvariables_capex(m, ‚Ñí::Vector{<:Link}, ùíØ, modeltype::EnergyModel)\n\nDeclaration of different capital expenditures variables for the element types introduced in EnergyModelsBase. EnergyModelsBase introduces two elements for an energy system, and hence, provides the user with two individual methods:\n\nThe default method is empty but it is required for multiple dispatch in investment models.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/functions/#EnergyModelsBase.variables_emission","page":"Functions","title":"EnergyModelsBase.variables_emission","text":"variables_emission(m, ‚Ñí::Vector{<:Node}, ùí´, ùíØ, modeltype::EnergyModel)\nvariables_emission(m, ‚Ñí::Vector{<:Link}, ùí´, ùíØ, modeltype::EnergyModel)\nvariables_emission(m, ùíØ, ùí´, modeltype::EnergyModel)\n\nDeclaration of emissions variables for the element types introduced in EnergyModelsBase as well as global emission variables. EnergyModelsBase introduces two elements for an energy system, and hence, provides the user with in total three individual methods, including the global variables:\n\nnote: Node variables\nemissions_node[n_em, t, p_em] are the emissions of node n_em with emissions in operational period t of emission resource p_em. The values can be negative to account for removal of emissions resources from the environment, through, e.g., direct air capture.\n\ntip: Link variables\nemissions_node[n_em, t, p_em] are the emissions of link l_em with emissions in operational period t of emission resource p_em. The values can only be positive as links should not allow for removal.\n\nwarning: Global variables\nemissions_total[t, p_em] are the total emissions of in operational period t of emission resource p_em. The values can be negative to account for removal of emissions resources from the environment, through, e.g., direct air capture.\nemissions_strategic[t_inv, p_em] are the total emissions of in operational period t of emission resource p_em. The values can be negative to account for removal of emissions resources from the environment, through, e.g., direct air capture. The variable has an upper bound introduced through the function emission_limit of the EnergyModel.\n\nThe inclusion of node and link emissions require that the function has_emissions returns true for the given node or link. This is by default achieved for nodes through inclusion of EmissionData in nodes while links require you to explicitly provide a method for your link type.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.variables_elements","page":"Functions","title":"EnergyModelsBase.variables_elements","text":"variables_elements(m, ùí©::Vector{<:Node}, ùíØ, modeltype::EnergyModel)\nvariables_elements(m, ‚Ñí::Vector{<:Link}, ùíØ, modeltype::EnergyModel)\n\nLoop through all element types and create variables specific to each type. It starts at the top level and subsequently move through the branches until it reaches a leave. That is, node nodes, variables_node will be called on a  Node before it is called on NetworkNode-nodes.\n\nEnergyModelsBase provides the user with two element types, Link and Node:\n\nNode - the subfunction is variables_node.\nLink - the subfunction is variables_link.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#Check-functions","page":"Functions","title":"Check functions","text":"","category":"section"},{"location":"library/internals/functions/#EnergyModelsBase.check_data","page":"Functions","title":"EnergyModelsBase.check_data","text":"check_data(case, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nCheck if the case data is consistent. Use the @assert_or_log macro when testing. Currently only checking node data.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_case_data","page":"Functions","title":"EnergyModelsBase.check_case_data","text":"check_case_data(case)\n\nChecks the case dictionary is in the correct format.\n\nChecks\n\nThe dictionary requires the keys :T, :nodes, :links, and :products.\nThe individual keys are of the correct type, that is\n:T::TimeStructure,\n:nodes::Vector{<:Node},\n:links::Vector{<:Link}, and\n:products::Vector{<:Resource}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_model","page":"Functions","title":"EnergyModelsBase.check_model","text":"check_model(case, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nChecks the modeltype .\n\nChecks\n\nAll ResourceEmits require a corresponding value in the field emission_limit.\nThe emission_limit time profiles cannot have a finer granulation than StrategicProfile.\nThe emission_price time profiles cannot have a finer granulation than StrategicProfile.\n\nConditional checks (if check_timeprofiles=true)\n\nThe profiles in emission_limit have to have the same length as the number of strategic periods.\nThe profiles in emission_price have to have the same length as the number of strategic periods.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_node","page":"Functions","title":"EnergyModelsBase.check_node","text":"check_node(n::Node, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nCheck that the fields of a Node corresponds to required structure.\n\nThe default approach calls the subroutine check_node_default which provides the user with default checks for Source, NetworkNode, Availability, Storage, and Sink nodes.\n\ntip: Creating a new node type\nWhen developing a new node with new checks, it is important to create a new method for check_node. You can then call within this function the default tests for the corresponding supertype through calling the function check_node_default.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_node_default","page":"Functions","title":"EnergyModelsBase.check_node_default","text":"check_node_default(n::Node, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that a Node node is valid. By default, that does not include any checks.\n\n\n\n\n\ncheck_node_default(n::Availability, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that an Availability node is valid. By default, that does not include any checks.\n\n\n\n\n\ncheck_node_default(n::Source, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nSubroutine that can be utilized in other packages for incorporating the standard tests for a Source node.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe values of the dictionary output are required to be non-negative.\nThe value of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function check_fixed_opex(n, ùíØ·¥µ‚Åø·µõ, check_timeprofiles).\n\n\n\n\n\ncheck_node_default(n::NetworkNode, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nSubroutine that can be utilized in other packages for incorporating the standard tests for a NetworkNode node.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe values of the dictionary input are required to be non-negative.\nThe values of the dictionary output are required to be non-negative.\nThe value of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function check_fixed_opex(n, ùíØ·¥µ‚Åø·µõ, check_timeprofiles).\n\n\n\n\n\ncheck_node_default(n::Storage, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nSubroutine that can be utilized in other packages for incorporating the standard tests for a Storage node.\n\nChecks\n\nThe TimeProfile of the field capacity in the type in the field charge is required to be non-negative if the chosen composite type has the field capacity.\nThe TimeProfile of the field capacity in the type in the field level is required to be non-negative`.\nThe TimeProfile of the field capacity in the type in the field discharge is required to be non-negative if the chosen composite type has the field capacity.\nThe TimeProfile of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function check_fixed_opex(n, ùíØ·¥µ‚Åø·µõ, check_timeprofiles) for the chosen composite type .\nThe values of the dictionary input are required to be non-negative.\nThe values of the dictionary output are required to be non-negative.\n\n\n\n\n\ncheck_node_default(n::Sink, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nSubroutine that can be utilized in other packages for incorporating the standard tests for a Sink node.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe values of the dictionary input are required to be non-negative.\nThe dictionary penalty is required to have the keys :deficit and :surplus.\nThe sum of the values :deficit and :surplus in the dictionary penalty has to be   non-negative to avoid an infeasible model.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_fixed_opex","page":"Functions","title":"EnergyModelsBase.check_fixed_opex","text":"check_fixed_opex(n, ùíØ·¥µ‚Åø·µõ, check_timeprofiles::Bool)\n\nChecks that the fixed opex value follows the given TimeStructure. This check requires that a function opex_fixed(n) is defined for the input n which returns a TimeProfile.\n\nChecks\n\nThe opex_fixed time profile cannot have a finer granulation than StrategicProfile.\n\nConditional checks (if check_timeprofiles=true)\n\nThe profiles in opex_fixed have to have the same length as the number of strategic periods.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_node_data-Tuple{EnergyModelsBase.Node, EmissionsData, Any, EnergyModel, Bool}","page":"Functions","title":"EnergyModelsBase.check_node_data","text":"check_node_data(n::Node, data::Data, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\ncheck_node_data(n::Node, data::EmissionsData, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nCheck that the included Data types of a Node corresponds to required structure. This function will always result in a multiple error message, if several instances of the same supertype is loaded.\n\nChecks EmissionsData\n\nEach node can only have a single EmissionsData.\nTime profiles for process emissions, if present.\nThe value of the field co2_capture is required to be in the range 0 1, if CaptureData is used.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/functions/#EnergyModelsBase.check_time_structure","page":"Functions","title":"EnergyModelsBase.check_time_structure","text":"check_time_structure(n::Node, ùíØ)\n\nCheck that all fields of a Node that are of type TimeProfile correspond to the time structure ùíØ.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_profile","page":"Functions","title":"EnergyModelsBase.check_profile","text":"check_profile(fieldname, value::TimeProfile, ùíØ)\n\nCheck that an individual TimeProfile corresponds to the time structure ùíØ. It currently does not include support for identifying OperationalScenarios.\n\n\n\n\n\ncheck_profile(fieldname, value::TimeProfile, ts::TimeStructure, sp)\n\nCheck that an individual TimeProfile corresponds to the time structure ts in strategic period sp. The function flow is designed to provide errors in all situations in which the the TimeProfile does not correspond to the chosen TimeStructure through the application of the @assert_or_log macro.\n\nExamples for inconsistent combinations:\n\nts = SimpleTimes(3, 1)\n\n# A too long OperationalProfile resulting in omitting the last 2 values\nvalue = OperationalProfile([1, 2, 3, 4, 5])\n\n# A too short OperationalProfile resulting in repetition of the last value once\nvalue = OperationalProfile([1, 2])\n\nIf you use a more detailed TimeProfile than the TimeStructure, it will you provide you with a warning, e.g., using RepresentativeProfile without RepresentativePeriods.\n\nIt currently does not include support for identifying OperationalProfiles.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_strategic_profile","page":"Functions","title":"EnergyModelsBase.check_strategic_profile","text":"check_strategic_profile(time_profile::TimeProfile, message::String)\n\nFunction for checking that an individual TimeProfile does not include the wrong type for strategic indexing.\n\nChecks\n\nTimeProfiles accessed in StrategicPeriods cannot include OperationalProfile, ScenarioProfile, or RepresentativeProfile as this is not allowed through indexing on the TimeProfile.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_representative_profile","page":"Functions","title":"EnergyModelsBase.check_representative_profile","text":"check_representative_profile(time_profile::TimeProfile, message::String)\n\nFunction for checking that an individual TimeProfile does not include the wrong type for representative periods indexing.\n\nInput\n\ntime_profile - The time profile that should be checked.\nmessage - A message that should be printed after the type of profile.\n\nChecks\n\nTimeProfiles accessed in RepresentativePeriods cannot include OperationalProfile or ScenarioProfile as this is not allowed through indexing on the TimeProfile.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.check_scenario_profile","page":"Functions","title":"EnergyModelsBase.check_scenario_profile","text":"check_scenario_profile(time_profile::TimeProfile, message::String)\n\nFunction for checking that an individual TimeProfile does not include the wrong type for scenario indexing.\n\nChecks\n\nTimeProfiles accessed in RepresentativePeriods cannot include OperationalProfile or ScenarioProfile as this is not allowed through indexing on the TimeProfile.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.compile_logs","page":"Functions","title":"EnergyModelsBase.compile_logs","text":"compile_logs(case, log_by_element)\n\nSimple method for showing all log messages.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#Identification-functions","page":"Functions","title":"Identification functions","text":"","category":"section"},{"location":"library/internals/functions/#EnergyModelsBase.is_network_node","page":"Functions","title":"EnergyModelsBase.is_network_node","text":"is_network_node(n::Node)\n\nChecks whether node n is a NetworkNode node.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.is_sink","page":"Functions","title":"EnergyModelsBase.is_sink","text":"is_sink(n::Node)\n\nChecks whether node n is a Sink node.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.is_source","page":"Functions","title":"EnergyModelsBase.is_source","text":"is_source(n::Node)\n\nChecks whether node n is a Source node.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.is_storage","page":"Functions","title":"EnergyModelsBase.is_storage","text":"is_storage(n::Node)\n\nChecks whether node n is a Storage node.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.is_resource_emit","page":"Functions","title":"EnergyModelsBase.is_resource_emit","text":"is_resource_emit(p::Resource)\n\nChecks whether the Resource p is of type ResourceEmit.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.has_charge_OPEX_fixed","page":"Functions","title":"EnergyModelsBase.has_charge_OPEX_fixed","text":"has_charge_OPEX_fixed(n::Storage)\n\nReturns logic whether the node has a charge fixed OPEX contribution.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.has_charge_OPEX_var","page":"Functions","title":"EnergyModelsBase.has_charge_OPEX_var","text":"has_charge_OPEX_var(n::Storage)\n\nReturns logic whether the node has a charge variable OPEX contribution.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.has_charge_cap","page":"Functions","title":"EnergyModelsBase.has_charge_cap","text":"has_charge_cap(n::Storage)\n\nReturns logic whether the node has a charge capacity.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.has_discharge_OPEX_fixed","page":"Functions","title":"EnergyModelsBase.has_discharge_OPEX_fixed","text":"has_discharge_OPEX_fixed(n::Storage)\n\nReturns logic whether the node has a discharge fixed OPEX contribution.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.has_discharge_OPEX_var","page":"Functions","title":"EnergyModelsBase.has_discharge_OPEX_var","text":"has_discharge_OPEX_var(n::Storage)\n\nReturns logic whether the node has a discharge variable OPEX contribution.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.has_discharge_cap","page":"Functions","title":"EnergyModelsBase.has_discharge_cap","text":"has_discharge_cap(n::Storage)\n\nReturns logic whether the node has a discharge capacity.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.has_level_OPEX_fixed","page":"Functions","title":"EnergyModelsBase.has_level_OPEX_fixed","text":"has_level_OPEX_fixed(n::Storage)\n\nReturns logic whether the node has a level fixed OPEX contribution.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.has_level_OPEX_var","page":"Functions","title":"EnergyModelsBase.has_level_OPEX_var","text":"has_level_OPEX_var(n::Storage)\n\nReturns logic whether the node has a level variable OPEX contribution.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.nodes_not_av","page":"Functions","title":"EnergyModelsBase.nodes_not_av","text":"nodes_not_av(ùí©::Array{<:Node})\n\nReturns nodes that are not Availability nodes for a given Array ùí©::Array{<:Node}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.nodes_not_sub","page":"Functions","title":"EnergyModelsBase.nodes_not_sub","text":"nodes_not_sub(ùí©::Array{<:Node}, sub)\n\nReturns nodes that are not of type sub for a given Array ùí©::Array{<:Node}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.nodes_sub","page":"Functions","title":"EnergyModelsBase.nodes_sub","text":"nodes_sub(ùí©::Array{<:Node}, sub)\n\nReturns nodes that are of type sub for a given Array ùí©::Array{<:Node}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.link_res","page":"Functions","title":"EnergyModelsBase.link_res","text":"link_res(l::Link)\n\nReturn the resources transported for a given link l.\n\nThe default approach is to use the intersection of the inputs of the to node and the outputs of the from node.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.link_sub","page":"Functions","title":"EnergyModelsBase.link_sub","text":"link_sub(‚Ñí::Vector{<:Link}, n::Node)\n\nReturn connected links from the vector ‚Ñí for a given node n as array. The first subarray corresponds to the from field, while the second to the to field.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.res_em","page":"Functions","title":"EnergyModelsBase.res_em","text":"res_em(ùí´::Array{<:Resource})\nres_em(ùí´::Dict)\n\nReturns all emission resources for a\n\na given array ::Array{<:Resource}. The output is in this case an Array{<:Resource}\na given dictionary ::Dict. The output is in this case a dictionary Dict with the correct fields\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.res_not","page":"Functions","title":"EnergyModelsBase.res_not","text":"res_not(ùí©::Array{<:Resource}, res_inst)\nres_not(ùí´::Dict, res_inst::Resource)\n\nReturn all resources that are not res_inst for\n\na given array ::Array{<:Resource}. The output is in this case an Array{<:Resource}\na given dictionary ::Dict. The output is in this case a dictionary Dict with the correct fields\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.res_sub","page":"Functions","title":"EnergyModelsBase.res_sub","text":"res_sub(ùí´::Array{<:Resource}, sub = ResourceEmit)\n\nReturn resources that are of type sub for a given Array ::Array{Resource}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#Miscellaneous-functions","page":"Functions","title":"Miscellaneous functions","text":"","category":"section"},{"location":"library/internals/functions/#EnergyModelsBase.collect_types","page":"Functions","title":"EnergyModelsBase.collect_types","text":"collect_types(types_list)\n\nReturn a Dict of all the give types_list and their supertypes. The keys in the dictionary are the types, and their corresponding value is the number in the type hierarchy.\n\nAs an example, Node is at the top and will thus have the value 1. Types just below Node will have value 2, and so on.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/functions/#EnergyModelsBase.sort_types","page":"Functions","title":"EnergyModelsBase.sort_types","text":"sort_types(types_list::Dict)\n\nSort the result of collect_types and return a vector where a supertype comes before all its subtypes.\n\n\n\n\n\n","category":"function"},{"location":"nodes/source/#nodes-source","page":"Source","title":"Source node","text":"","category":"section"},{"location":"nodes/source/","page":"Source","title":"Source","text":"Source nodes are technologies that only have an output connection.","category":"page"},{"location":"nodes/source/#nodes-source-fields","page":"Source","title":"Introduced type and its fields","text":"","category":"section"},{"location":"nodes/source/","page":"Source","title":"Source","text":"The RefSource node is implemented as a reference node that can be used for a Source. It includes basic functionalities common to most energy system optimization models.","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"The fields of a RefSource node are given as:","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"id:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal capacity of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of an investment period as outlined on Utilize TimeStruct.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\noutput::Dict{<:Resource,<:Real}:\nThe field output includes Resources with their corresponding conversion factors as dictionaries. CO‚ÇÇ cannot be directly specified, i.e., you cannot specify a ratio. If you would like to use a Source node with CO‚ÇÇ as output with a given ratio, it is necessary to utilize the package EnergyModelsCO2. If you use CaptureData, it is however necessary to specify CO‚ÇÇ as output, although the ratio is not important.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used. When using EmissionsData, only process emissions can be considered, that is the types EmissionsProcess and that is the types EmissionsProcess and CaptureProcessEmissions. Specifying energy related emissions will not have an impact as there is no energy conversion within a Source node.\nnote: Note\nThe field data is not required as we include a constructor when the value is excluded.","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"warning: Using `CaptureData`\nIf you plan to use CaptureData for a RefSource node, it is crucial that you specify your CO‚ÇÇ resource in the output dictionary. The chosen value is however not important as the CO‚ÇÇ flow is automatically calculated based on the process utilization and the provided process emission value. The reason for this necessity is that flow variables are declared through the keys of the output dictionary. Hence, not specifying CO‚ÇÇ as output resource results in not creating the corresponding flow variable and subsequent problems in the design.We plan to remove this necessity in the future. As it would most likely correspond to breaking changes, we have to be careful to avoid requiring major changes in other packages.","category":"page"},{"location":"nodes/source/#nodes-source-math","page":"Source","title":"Mathematical description","text":"","category":"section"},{"location":"nodes/source/","page":"Source","title":"Source","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"textttvar_exampleindex_1 index_2","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"with square brackets, while functions are represented as","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"func_example(index_1 index_2)","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"with paranthesis.","category":"page"},{"location":"nodes/source/#nodes-source-math-var","page":"Source","title":"Variables","text":"","category":"section"},{"location":"nodes/source/","page":"Source","title":"Source","text":"The variables of Source nodes include:","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data Note that Source nodes are not compatible with CaptureData except for CaptureProcessEmissions. Hence, you can only provide EmissionsProcess to the node.","category":"page"},{"location":"nodes/source/#nodes-source-math-con","page":"Source","title":"Constraints","text":"","category":"section"},{"location":"nodes/source/","page":"Source","title":"Source","text":"A qualitative overview of the individual constraints can be found on Constraint functions. This section focuses instead on the mathematical description of the individual constraints. It omits the direction inclusion of the vector of source nodes (or all nodes, if nothing specific is implemented). Instead, it is implicitly assumed that the constraints are valid forall n  N^textSource for all Source types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"The following standard constraints are implemented for a Source node. Source nodes utilize the declared method for all nodes ùí©. The constraint functions are called within the function create_node. Hence, if you do not have to call additional functions, but only plan to include a method for one of the existing functions, you do not have to specify a new create_node method.","category":"page"},{"location":"nodes/source/","page":"Source","title":"Source","text":"constraints_capacity:\ntextttcap_usen t leq textttcap_instn t\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_out:\ntextttflow_outn t p =\noutputs(n p) times textttcap_usen t\nqquad forall p in outputs(n) setminus textCO_2\nconstraints_opex_fixed:\ntextttopex_fixedn t_inv = opex_fixed(n t_inv) times textttcap_instn first(t_inv)\ntip: Why do we use `first()`\nThe variable textttcap_inst is declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacity in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\ntextttopex_varn t_inv = sum_t in t_inv opex_var(n t) times textttcap_usen t times scale_op_sp(t_inv t)\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified additional data, see above.","category":"page"},{"location":"manual/simple-example/#man-exampl","page":"Example","title":"Examples","text":"","category":"section"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"For the content of the individual examples, see the examples directory in the project repository.","category":"page"},{"location":"manual/simple-example/#The-package-is-installed-with-]-add","page":"Example","title":"The package is installed with ]¬†add","text":"","category":"section"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"From the Julia REPL, run","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"# Starts the Julia REPL\njulia> using EnergyModelsBase\n# Get the path of the examples directory\njulia> exdir = joinpath(pkgdir(EnergyModelsBase), \"examples\")\n# Include the code into the Julia REPL to run the examples\njulia> include(joinpath(exdir, \"sink_source.jl\"))","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"The second example can be run using","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"# Starts the Julia REPL\njulia> using EnergyModelsBase\n# Get the path of the examples directory\njulia> exdir = joinpath(pkgdir(EnergyModelsBase), \"examples\")\n# Include the code into the Julia REPL to run the examples\njulia> include(joinpath(exdir, \"network.jl\"))","category":"page"},{"location":"manual/simple-example/#The-code-was-downloaded-with-git-clone","page":"Example","title":"The code was downloaded with git clone","text":"","category":"section"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"The examples can be run from the terminal with","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"/path/to/EnergyModelsBase.jl/examples $ julia sink_source.jl","category":"page"},{"location":"how-to/create-new-node/#how_to-create_node","page":"Create a new node","title":"Create a new node","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"The energy system model is based on the JuMP optimization framework, so some basic knowledge on this Julia package is needed to implement a new technology node.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"To create a new technology node named NewTechNode, we need toImplement a new struct (composite type), that is a subtypes of Node, Source, Sink, etc. Here, a central choice is to decide on what abstract node type to subtype to.\nOptional: implement the method\nvariables_node(m, ùí©À¢·µò·µá::Vector{<:NewTechNode}, ùíØ, modeltype::EnergyModel)\nImplement this method if you want to create additional optimization variables for the new node. See how to create JuMP variables in the JuMP documentation.\nImplement the method\ncreate_node(m, n::NewTechNode, ùíØ, ùí´, modeltype::EnergyModel)\nIn this method the constraints for the new node are created. See how to create JuMP constraints in the JuMP documentation.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"While step 1 is always required, it is possible to omit step 2 if no new variables are required. It is also possible to create unregistered variables for each instance of the node. This is however only advised if you do not need to access the value of the variables after the optimization.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"danger: Variable names\nBy default, it is not possible to use the same variable name twice within JuMP. I found some weird behavior in which it is possible to register the same variable name with a different node set, but it should not be possible to count on it. If you require variables, it is crucial to check whether the variable names are already utilized by other nodes you are using! The individual variables are shown on the description of individual nodes.It is hence in general advisable to provide a specific name including the node type as prefix, e.g., node_test_flow_in if you want to create a variable for aNodeTest`.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"warning: Field names\nWhen creating a new node type, you are free to change the field names to whatever name you desire. However, if you change the  field names, there are several things to consider:Certain functions are used within the core structure of the code for accessing the fields. These functions can be found in the Public Interface.\nThe function EMB.check_node conducts some checks on the individual node data. If the fields and structure from the reference nodes are not present, you also have to create a new function for your node.","category":"page"},{"location":"how-to/create-new-node/#how_to-create_node-tips","page":"Create a new node","title":"Additional tips for creating new nodes","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"If the NewNodeType should be able to include investments, it is necessary to i) call the function constraints_capacity_installed. and ii) have the field data. The function is used for dispatching on the constraints for investments while the field data is used for providing the InvestmentData.\nEmissions can be included in any way. It is however beneficial to reutilize the EmissionsData type to improve usability with other packages. This requries again the inclusion of the field data in NewNodeType. It is possible to also create new subtypes for EmissionsData as well as dispatch on the function constraints_data(m, n::Node, ùíØ, ùí´, modeltype, data::Data).\nIt is in a first stage not important to include functions for handling all possible TimeStructures, that is, e.g., RepresentativePeriods. Instead, and error can be provided if an unsupported TimeStructure is chosen.\nThe existing reference nodes and their respective constraint functions can serve as idea generators.\nIt is possible to include constraints that are coupled to another Node by introduing a field with the Node as type in the NewNodeType, e.g., a field node::Storage when you plan to include additional constraints including a Storage node.\nEnergyModelsBase utilize functions for accessing the fields of the individual nodes. These functions can be found in Functions for accessing fields of Node types. In general, these functions dispatch on abstract types.\nIt is beneficial to include the fields input and output for the NewTechNode. This is not strictly required, but otherwise one has to provide new methods for the functions inputs() and  outputs().","category":"page"},{"location":"how-to/create-new-node/#how_to-create_node-adv","page":"Create a new node","title":"Advanced creation of new nodes","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Step 3 in the procedure is not necessarily required. It is also possible to use the available constraint functions for the new node type. In this case, we have to first obtain an overview over the constraint functions called in","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"create_node(m, n::ParentNode, ùíØ, ùí´, modeltype::EnergyModel)","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"in which ParentNode corresponds to the abstract type that is used as parent for the new NewTechNode. Subsequently, we can add a method to the existing constraint function which is called by the ParentNode. This constraint function has to dispatch on the created NewTechNode type.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"warning: Warning\nIt is in general advised to create a new function create_node(m, n::NewTechNode, ùíØ, ùí´, modeltype::EnergyModel). The advantage here is that the user requires less understanding of the individual constraint functions. This may lead to repetetive code, but is the safer choice.","category":"page"},{"location":"how-to/create-new-node/#how_to-create_node-subtype","page":"Create a new node","title":"What abstract node type should you subtype to?","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"The choice of node supertype depends on what optimization variables you need for the constraints describing the functionality of the new node.","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"A new node is defined as a composite type (struct) and subtype of one of the standard node types,","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Source\nNetworkNode\nSink","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Furthermore, we have the types","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Availability <: NetworkNode\nStorage <: NetworkNode","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"which correspond to a routing node (Availability) and a storage node (Storage).","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"The overall structure of the individual nodes can be printed to the REPL using the following code:","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"julia> using EnergyModelsBase\njulia> const EMB = EnergyModelsBase\njulia> using AbstractTrees\njulia> AbstractTrees.children(x::Type) = subtypes(x)\n\njulia> print_tree(EMB.Node)","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"Node\n‚îú‚îÄ NetworkNode\n‚îÇ  ‚îú‚îÄ Availability\n‚îÇ  ‚îÇ  ‚îî‚îÄ GenAvailability\n‚îÇ  ‚îú‚îÄ RefNetworkNode\n‚îÇ  ‚îî‚îÄ Storage\n‚îÇ     ‚îî‚îÄ RefStorage\n‚îú‚îÄ Sink\n‚îÇ  ‚îî‚îÄ RefSink\n‚îî‚îÄ Source\n   ‚îî‚îÄ RefSource","category":"page"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"The leaf nodes of the above type hierarchy tree are composite types, while the inner vertices are abstract types. The chosen parent type of the NewNodeType node decides what optimization variables are created for use by default. You can find the created default optimization variables in Optimization Variables and Node types and respective variables. The main difference between the individual parent types is whether they have only an energy/mass output (Source), input and output (NetworkNode), or input (Sink). A more detailed explanation of the different abstract types can be found in Description of Technologies","category":"page"},{"location":"how-to/create-new-node/#how_to-create_node-example","page":"Create a new node","title":"Example","text":"","category":"section"},{"location":"how-to/create-new-node/","page":"Create a new node","title":"Create a new node","text":"As an example, you can check out how EnergyModelsRenewableProducers introduces two new technology types, a Source and a Storage.","category":"page"},{"location":"nodes/sink/#nodes-sink","page":"Sink","title":"Sink node","text":"","category":"section"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"Sink nodes are technologies that only have an input connection. In the context of EnergyModelsBase, they correspond to a demand.","category":"page"},{"location":"nodes/sink/#nodes-sink-fields","page":"Sink","title":"Introduced type and its fields","text":"","category":"section"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"The RefSink node is implemented as a reference node that can be used for a Sink. It includes basic functionalities common to most energy system optimization models.","category":"page"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"The fields of a RefSink node are given as:","category":"page"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"id:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal demand of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\npenalty::Dict{Symbol,<:TimeProfile}:\nThe penalty dictionary is used for providing penalties for soft constraints to allow for both over and under delivering the demand.\nIt must include the fields :surplus and :deficit. In addition, it is crucial that the sum of both values is larger than 0 to avoid an unconstrained model.\ninput::Dict{<:Resource,<:Real}:\nThe field input includes Resources with their corresponding conversion factors as dictionaries.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used.\nnote: Note\nThe field data is not required as we include a constructor when the value is excluded.\ndanger: Using `CaptureData`\nAs a Sink node does not have any output, it is not possible to utilize CaptureData. If you still plan to specify it, you will receive an error in the model building.","category":"page"},{"location":"nodes/sink/#nodes-sink-math","page":"Sink","title":"Mathematical description","text":"","category":"section"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as","category":"page"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"textttvar_exampleindex_1 index_2","category":"page"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"with square brackets, while functions are represented as","category":"page"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"func_example(index_1 index_2)","category":"page"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"with paranthesis.","category":"page"},{"location":"nodes/sink/#nodes-sink-math-var","page":"Sink","title":"Variables","text":"","category":"section"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"The variables of Sink nodes include:","category":"page"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttsink_surplus\ntextttsink_deficit\ntextttemissions_node if EmissionsData is added to the field data","category":"page"},{"location":"nodes/sink/#nodes-sink-math-con","page":"Sink","title":"Constraints","text":"","category":"section"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"A qualitative overview of the individual constraints can be found on Constraint functions. This section focuses instead on the mathematical description of the individual constraints. It omits the direction inclusion of the vector of sink nodes (or all nodes, if nothing specific is implemented). Instead, it is implicitly assumed that the constraints are valid forall n  N^textSink for all Sink types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"page"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"The following standard constraints are implemented for a Sink node. Sink nodes utilize the declared method for all nodes ùí©. The constraint functions are called within the function create_node. Hence, if you do not have to call additional functions, but only plan to include a method for one of the existing functions, you do not have to specify a new create_node method.","category":"page"},{"location":"nodes/sink/","page":"Sink","title":"Sink","text":"constraints_capacity:\ntextttcap_usen t + textttsink_deficitn t = textttcap_instn t + textttsink_surplusn t\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_in:\ntextttflow_inn t p =\ninputs(n p) times textttcap_usen t\nqquad forall p in inputs(n)\ntip: Multiple inputs\nThe constrained above allows for the utilization of multiple inputs with varying ratios. it is however necessary to deliver the fixed ratio of all inputs.\nconstraints_opex_fixed:\nThe current implementation fixes the fixed operating expenses of a sink to 0.\ntextttopex_fixedn t_inv = 0\nconstraints_opex_var:\nbeginaligned\ntextttopex_varn t_inv =  \n  sum_t in t_inv  surplus_penalty(n t) times textttsink_surplusn t +  \n  deficit_penalty(n t) times textttsink_deficitn t times  \n  scale_op_sp(t_inv t)\nendaligned\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified additional data, see above.","category":"page"},{"location":"nodes/networknode/#nodes-network_node","page":"NetworkNode","title":"NetworkNode","text":"","category":"section"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"NetworkNodes are technologies that have both an input and an output connection.","category":"page"},{"location":"nodes/networknode/#nodes-network_node-fields","page":"NetworkNode","title":"Introduced type and its fields","text":"","category":"section"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"The RefNetworkNode is implemented as a reference node that can be used for a NetworkNode. It includes basic functionalities common to most energy system optimization models.","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"The fields of a RefNetworkNode are given as:","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"id:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal capacity of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified input and output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of an investment period as outlined on Utilize TimeStruct.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\ninput::Dict{<:Resource,<:Real} and output::Dict{<:Resource,<:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries.\nCO‚ÇÇ cannot be directly specified, i.e., you cannot specify a ratio. If you use CaptureData, it is however necessary to specify CO‚ÇÇ as output, although the ratio is not important.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used.\nnote: Note\nThe field data is not required as we include a constructor when the value is excluded.","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"warning: Using `CaptureData`\nIf you plan to use CaptureData for a RefNetworkNode node, it is crucial that you specify your CO‚ÇÇ resource in the output dictionary. The chosen value is however not important as the CO‚ÇÇ flow is automatically calculated based on the process utilization and the provided process emission value. The reason for this necessity is that flow variables are declared through the keys of the output dictionary. Hence, not specifying CO‚ÇÇ as output resource results in not creating the corresponding flow variable and subsequent problems in the design.We plan to remove this necessity in the future. As it would most likely correspond to breaking changes, we have to be careful to avoid requiring major changes in other packages.","category":"page"},{"location":"nodes/networknode/#nodes-network_node-math","page":"NetworkNode","title":"Mathematical description","text":"","category":"section"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"textttvar_exampleindex_1 index_2","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"with square brackets, while functions are represented as","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"func_example(index_1 index_2)","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"with paranthesis.","category":"page"},{"location":"nodes/networknode/#nodes-network_node-math-var","page":"NetworkNode","title":"Variables","text":"","category":"section"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"The variables of NetworkNodes include:","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data","category":"page"},{"location":"nodes/networknode/#nodes-network_node-math-con","page":"NetworkNode","title":"Constraints","text":"","category":"section"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"A qualitative overview of the individual constraints can be found on Constraint functions. This section focuses instead on the mathematical description of the individual constraints. It omits the direction inclusion of the vector of network nodes (or all nodes, if nothing specific is implemented). Instead, it is implicitly assumed that the constraints are valid forall n  N^textNetworkNode (for all NetworkNode types) if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"The following standard constraints are implemented for a NetworkNode node. NetworkNode nodes utilize the declared method for all nodes ùí©. The constraint functions are called within the function create_node. Hence, if you do not have to call additional functions, but only plan to include a method for one of the existing functions, you do not have to specify a new create_node method.","category":"page"},{"location":"nodes/networknode/","page":"NetworkNode","title":"NetworkNode","text":"constraints_capacity:\ntextttcap_usen t leq textttcap_instn t\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_in:\ntextttflow_inn t p = inputs(n p) times textttcap_usen t\nqquad forall p in inputs(n)\nconstraints_flow_out:\ntextttflow_outn t p =\noutputs(n p) times textttcap_usen t\nqquad forall p in outputs(n) setminus textCO_2\nconstraints_opex_fixed:\ntextttopex_fixedn t_inv = opex_fixed(n t_inv) times textttcap_instn first(t_inv)\ntip: Why do we use `first()`\nThe variable textttcap_inst is declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacity in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\ntextttopex_varn t_inv = sum_t in t_inv opex_var(n t) times textttcap_usen t times scale_op_sp(t_inv t)\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified data of the nodes, see above.","category":"page"},{"location":"library/public/nodes/#lib-pub-nodes","page":"Nodes","title":"Nodes","text":"","category":"section"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"Nodes are used in EnergyModelsBase to convert Resources. They are coupled to the rest of the system through the Flow variables. Nodes are the key types for extending EnergyModelsBase through dispatch. You can find an introduction of the different node types on the page Creating a new node","category":"page"},{"location":"library/public/nodes/#Index","page":"Nodes","title":"Index","text":"","category":"section"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"Pages = [\"nodes.md\"]","category":"page"},{"location":"library/public/nodes/#lib-pub-nodes-abstract","page":"Nodes","title":"Abstract Node types","text":"","category":"section"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"The following abstract node types are implemented in the EnergyModelsBase. These abstract types are relevant for dispatching in individual functions.","category":"page"},{"location":"library/public/nodes/#EnergyModelsBase.Source","page":"Nodes","title":"EnergyModelsBase.Source","text":"Source node with only output.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.NetworkNode","page":"Nodes","title":"EnergyModelsBase.NetworkNode","text":"NetworkNode node with both input and output.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.Sink","page":"Nodes","title":"EnergyModelsBase.Sink","text":"Sink node with only input.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.Storage","page":"Nodes","title":"EnergyModelsBase.Storage","text":"Storage node with level.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.Availability","page":"Nodes","title":"EnergyModelsBase.Availability","text":"Availability node as routing node.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#lib-pub-nodes-ref","page":"Nodes","title":"Reference node types","text":"","category":"section"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"The following composite types are implemented in the EnergyModelsBase. They can be used for describing a simple energy system without any non-linear or binary based expressions. Hence, there are, e.g., no operation point specific efficiencies implemented.","category":"page"},{"location":"library/public/nodes/#EnergyModelsBase.RefSource","page":"Nodes","title":"EnergyModelsBase.RefSource","text":"RefSource <: Source\n\nA reference Source node. The reference Source node allows for a time varying capacity which is normalized to a conversion value of 1 in the field input. Note, that if you include investments, you can only use as TimeProfile a FixedProfile or StrategicProfile.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per per capacity usage through the variable :cap_use.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\noutput::Dict{<:Resource,<:Real} are the generated Resources with conversion value Real.\ndata::Vector{<:Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.RefNetworkNode","page":"Nodes","title":"EnergyModelsBase.RefNetworkNode","text":"RefNetworkNode <: NetworkNode\n\nA reference NetworkNode node. The RefNetworkNode utilizes a linear, time independent conversion rate of the input Resources to the output Resources, subject to the available capacity. The capacity is hereby normalized to a conversion value of 1 in the fields input and output.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per per capacity usage through the variable :cap_use.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource,<:Real} are the generated Resources with conversion value Real.\ndata::Vector{Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.RefSink","page":"Nodes","title":"EnergyModelsBase.RefSink","text":"RefSink <: Sink\n\nA reference Sink node. This node corresponds to a demand given by the field cap. The penalties introduced in the field penalty affect the variable OPEX for both a surplus and deficit.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the demand.\npenalty::Dict{Symbol,<:TimeProfile} are penalties for surplus or deficits. The dictionary requires the  fields :surplus and :deficit.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\ndata::Vector{<:Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.RefStorage","page":"Nodes","title":"EnergyModelsBase.RefStorage","text":"RefStorage{T} <: Storage{T}\n\nA reference Storage node.\n\nThis node is designed to store either a ResourceCarrier or a ResourceEmit. It is designed as a parametric type through the type parameter T to differentiate between different cyclic behaviours. Note that the parameter T is only used for dispatching, but does not carry any other information. Hence, it is simple to fast switch between different StorageBehaviors.\n\nThe current implemented cyclic behaviours are CyclicRepresentative, CyclicStrategic, and AccumulatingEmissions.\n\nFields\n\nid is the name/identifier of the node.\ncharge::AbstractStorageParameters are the charging parameters of the Storage node. Depending on the chosen type, the charge parameters can include variable OPEX, fixed OPEX, and/or a capacity.\nlevel::AbstractStorageParameters are the level parameters of the Storage node. Depending on the chosen type, the charge parameters can include variable OPEX and/or fixed OPEX.\nstor_res::Resource is the stored Resource.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource,<:Real} are the generated Resources with conversion value Real. Only relevant for linking and the stored Resource as the output value is not utilized in the calculations.\ndata::Vector{<:Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.GenAvailability","page":"Nodes","title":"EnergyModelsBase.GenAvailability","text":"GenAvailability <: Availability\n\nA reference Availability node. The reference Availability node solves the energy balance for all connected flows.\n\nFields\n\nid is the name/identifier of the node.\ninputs::Vector{<:Resource} are the input Resources.\noutput::Vector{<:Resource} are the output Resources.\n\nA constructor is provided so that only a single array can be provided with the fields:\n\nid is the name/identifier of the node.\nùí´::Vector{<:Resource} are the [Resource`](@ref)s.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#lib-pub-nodes-stor_behav","page":"Nodes","title":"Storage behaviours","text":"","category":"section"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"EnergyModelsBase provides several different storage behaviours for calculating the level balance of a Storage node. In general, the concrete storage behaviours are ready to use and should account for all eventualities.","category":"page"},{"location":"library/public/nodes/#EnergyModelsBase.Accumulating","page":"Nodes","title":"EnergyModelsBase.Accumulating","text":"Accumulating <: StorageBehavior\n\nAccumulating as supertype for an accumulating storage level.\n\nAccumulating storage behaviour implies that the change in the overall storage level in a strategic period can be both positive or negative.\n\nExamples for potential usage of Accumulating are CO‚ÇÇ storages in which the CO‚ÇÇ is permanently stored or multi year hydropower magazines.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.AccumulatingEmissions","page":"Nodes","title":"EnergyModelsBase.AccumulatingEmissions","text":"AccumulatingEmissions <: Accumulating\n\nStorageBehavior which accumulates all inflow witin a strategic period. AccumulatingEmissions allows as well to serve as a ResourceEmit emission point to represent a soft constraint on storing the captured emissions.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.Cyclic","page":"Nodes","title":"EnergyModelsBase.Cyclic","text":"Cyclic <: StorageBehavior\n\nCyclic as supertype for a cyclic storage level.\n\nCyclic storage behaviour implies that the change in the overall storage level in a strategic period behaves cyclic.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.CyclicRepresentative","page":"Nodes","title":"EnergyModelsBase.CyclicRepresentative","text":"CyclicRepresentative <: Cyclic\n\nStorageBehavior in which cyclic behaviour is achieved within the lowest time structure excluding operational times.\n\nIn the case of TwoLevel{SimpleTimes}, this approach is similar to CyclicStrategic. In the case of TwoLevel{RepresentativePeriods{SimpleTimes}}, this approach differs from CyclicStrategic as the cyclic constraint is enforeced within each representative period.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.CyclicStrategic","page":"Nodes","title":"EnergyModelsBase.CyclicStrategic","text":"CyclicStrategic <: Cyclic\n\nStorageBehavior in which the the cyclic behaviour is achieved within a strategic period. This implies that the initial level in individual representative periods can be different when using RepresentativePeriods.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"note: Note\nWe have not yet supported upper and lower bound constraints in the case of using OperationalScenarios. While the calculation of the overall level balance and the operational costs is consistent, it can happen that the upper and lower bound of the storage level is violated.This impacts specifically CyclicStrategic.","category":"page"},{"location":"library/public/nodes/#lib-pub-nodes-stor_par","page":"Nodes","title":"Storage parameters","text":"","category":"section"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"Storage parameters are used for describing different parameters for the individual capacities of a Storage node. In practice, Storage nodes can have three different capacities:","category":"page"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"charge, that is a capacity for charging the Storage node,\nlevel, that is the amount of energy/mass that can be stored, and\ndischarge, that is a capacity for discharging the Storage node.","category":"page"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"In general, each of the individual capacities can have an assigned capacity, variable OPEX, and fixed OPEX. Furthermore, it is possible to only have a variable OPEX. To this end, multiple composite types are defined.","category":"page"},{"location":"library/public/nodes/#EnergyModelsBase.StorCapOpex","page":"Nodes","title":"EnergyModelsBase.StorCapOpex","text":"StorCapOpex <: AbstractStorageParameters\n\nA storage parameter type for including a capacity as well as variable and fixed operational expenditures.\n\nFields\n\ncapacity::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per capacity usage through the variable :cap_use.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.StorCap","page":"Nodes","title":"EnergyModelsBase.StorCap","text":"StorCap <: AbstractStorageParameters\n\nA storage parameter type for including only a capacity. This implies that neither the usage of the Storage, nor the installed capacity have a direct impact on the objective function.\n\nFields\n\ncapacity::TimeProfile is the installed capacity.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.StorCapOpexVar","page":"Nodes","title":"EnergyModelsBase.StorCapOpexVar","text":"StorCap <: AbstractStorageParameters\n\nA storage parameter type for including a capacity and variable operational expenditures. This implies that the installed capacity has no direct impact on the objective function.\n\nFields\n\ncapacity::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per capacity usage through the variable :cap_use.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.StorCapOpexFixed","page":"Nodes","title":"EnergyModelsBase.StorCapOpexFixed","text":"StorCapOpexFixed <: AbstractStorageParameters\n\nA storage parameter type for including a capacity and fixed operational expenditures. This implies that the installed capacity has no direct impact on the objective function.\n\nFields\n\ncapacity::TimeProfile is the installed capacity.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.StorOpexVar","page":"Nodes","title":"EnergyModelsBase.StorOpexVar","text":"StorCap <: AbstractStorageParameters\n\nA storage parameter type for including variable operational expenditures. This implies that the charge or discharge rate do not have a capacity and the Storage level can be used within a single TimePeriod.\n\nThis type can only be used for the fields charge and discharge.\n\nFields\n\nopex_var::TimeProfile is the variable operating expense per capacity usage through the variable :cap_use.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"When dispatching on the individual type, it is also possible to use the following unions:","category":"page"},{"location":"library/public/nodes/#EnergyModelsBase.UnionOpexFixed","page":"Nodes","title":"EnergyModelsBase.UnionOpexFixed","text":"UnionOpexFixed\n\nUnion for simpler dispatching for storage parameters that include fixed OPEX.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.UnionOpexVar","page":"Nodes","title":"EnergyModelsBase.UnionOpexVar","text":"UnionOpexVar\n\nUnion for simpler dispatching for storage parameters that include variable OPEX.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#EnergyModelsBase.UnionCapacity","page":"Nodes","title":"EnergyModelsBase.UnionCapacity","text":"UnionCapacity\n\nUnion for simpler dispatching for storage parameters that include a capacity.\n\n\n\n\n\n","category":"type"},{"location":"library/public/nodes/#lib-pub-nodes-fun_field","page":"Nodes","title":"Functions for accessing fields of Node types","text":"","category":"section"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"The following functions are declared for accessing fields from a Node type.","category":"page"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"warning: Warning\nIf you want to introduce new Node types, it is important that these functions are either functional for your new types or you have to declare corresponding functions. The first approach can be achieved through using the same name for the respective fields.The functions storage_resource is only required for Storage nodes, when you plan to use the implemented constraint function constraints_flow_in. The functions surplus_penalty and deficit_penalty are only required for Sink nodes if you plan to use the implemented constraint function constraints_opex_var.","category":"page"},{"location":"library/public/nodes/#EnergyModelsBase.capacity","page":"Nodes","title":"EnergyModelsBase.capacity","text":"capacity(n::Node)\ncapacity(n::Node, t)\n\nReturns the capacity of a node n as TimeProfile or in operational period t.\n\nwarning: Storage nodes\nThe capacity is not directly defined for Storage nodes. Instead, it is necessary to call the function on the respective field, see capacity(stor_par::AbstractStorageParameters).\n\n\n\n\n\ncapacity(stor_par::AbstractStorageParameters)\ncapacity(stor_par::AbstractStorageParameters, t)\n\nReturns the capacity of storage parameter stor_par as TimeProfile or in operational period t.\n\nnote: Accessing storage parameters\nThe individual storage parameters of a Storage node can be accessed through the functions charge(n), level(n), and discharge(n).\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.opex_var","page":"Nodes","title":"EnergyModelsBase.opex_var","text":"opex_var(n::Node)\nopex_var(n::Node, t)\n\nReturns the variable OPEX of a node n as TimeProfile or in operational period t.\n\nwarning: Storage nodes\nThe variable OPEX is not directly defined for Storage nodes. Instead, it is necessary to call the function on the respective field, see opex_var(stor_par::AbstractStorageParameters).\n\n\n\n\n\nopex_var(stor_par::UnionOpexVar)\nopex_var(stor_par::UnionOpexVar, t)\n\nReturns the variable OPEX of storage parameter stor_par as TimeProfile or in operational period t.\n\nnote: Accessing storage parameters\nThe individual storage parameters of a Storage node can be accessed through the functions charge(n), level(n), and discharge(n).\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.opex_fixed","page":"Nodes","title":"EnergyModelsBase.opex_fixed","text":"opex_fixed(n::Node)\nopex_fixed(n::Node, t_inv)\n\nReturns the fixed OPEX of a node node n as TimeProfile or in strategic period t_inv.\n\nwarning: Storage nodes\nThe fixed OPEX is not directly defined for Storage nodes. Instead, it is necessary to call the function on the respective field, see opex_fixed(stor_par::AbstractStorageParameters).\n\n\n\n\n\nopex_fixed(stor_par::UnionOpexFixed)\nopex_fixed(stor_par::UnionOpexFixed, t_inv)\n\nReturns the fixed OPEX of storage parameter stor_par as TimeProfile or in strategic period t_inv.\n\nnote: Accessing storage parameters\nThe individual storage parameters of a Storage node can be accessed through the functions charge(n), level(n), and discharge(n).\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.inputs-Tuple{EnergyModelsBase.Node}","page":"Nodes","title":"EnergyModelsBase.inputs","text":"inputs(n::Node)\ninputs(n::Node, p::Resource)\n\nReturns the input resources of a node n, specified via the field input.\n\nIf the resource p is specified, it returns the value (1 in the case of Availability, nothing in the case of a Source)\n\n\n\n\n\n","category":"method"},{"location":"library/public/nodes/#EnergyModelsBase.outputs-Tuple{EnergyModelsBase.Node}","page":"Nodes","title":"EnergyModelsBase.outputs","text":"outputs(n::Node)\noutputs(n::Node, p::Resource)\n\nReturns the output resources of a node n, specified via the field output.\n\nIf the resource p is specified, it returns the value (1 in the case of Availability, nothing in the case of a Sink)\n\n\n\n\n\n","category":"method"},{"location":"library/public/nodes/#EnergyModelsBase.node_data","page":"Nodes","title":"EnergyModelsBase.node_data","text":"node_data(n::Node)\n\nReturns the Data array of node n.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.charge","page":"Nodes","title":"EnergyModelsBase.charge","text":"charge(n::Storage)\n\nReturns the parameter type of the charge field of the node. If the node has no field charge, it returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.level","page":"Nodes","title":"EnergyModelsBase.level","text":"level(n::Storage)\n\nReturns the parameter type of the level field of the node.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.discharge","page":"Nodes","title":"EnergyModelsBase.discharge","text":"discharge(n::Storage)\n\nReturns the parameter type of the discharge field of the node. If the node has no field discharge, it returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.storage_resource","page":"Nodes","title":"EnergyModelsBase.storage_resource","text":"storage_resource(n::Storage)\n\nReturns the storage resource of Storage node n.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.surplus_penalty","page":"Nodes","title":"EnergyModelsBase.surplus_penalty","text":"surplus_penalty(n::Sink)\nsurplus_penalty(n::Sink, t)\n\nReturns the surplus penalty of sink n as TimeProfile or in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.deficit_penalty","page":"Nodes","title":"EnergyModelsBase.deficit_penalty","text":"deficit_penalty(n::Sink)\ndeficit_penalty(n::Sink, t)\n\nReturns the deficit penalty of sink n as TimeProfile or in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#lib-pub-nodes-fun_identify","page":"Nodes","title":"Functions for identifying Nodes","text":"","category":"section"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"The following functions are declared for filtering on Node types.","category":"page"},{"location":"library/public/nodes/","page":"Nodes","title":"Nodes","text":"warning: Warning\nIf you want to introduce new Node types, it is important that the functions has_input, has_output, and has_emissions are either functional for your new types or you have to declare corresponding functions. The first approach can be achieved through using the same name for the respective fields.The functions nodes_input, nodes_output, and nodes_emissions are not used in the model as they are replaced by the build in filter function as, e.g., filter(has_input, ùí©). In practice, they provide a pre-defined approach for filtering nodes and do not require additional modifications. They can be used in potential extensions.","category":"page"},{"location":"library/public/nodes/#EnergyModelsBase.nodes_input","page":"Nodes","title":"EnergyModelsBase.nodes_input","text":"nodes_input(ùí©::Array{<:Node}, sub)\n\nReturns nodes that have an input, i.e., Sink and NetworkNode nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.nodes_output","page":"Nodes","title":"EnergyModelsBase.nodes_output","text":"nodes_output(ùí©::Array{<:Node})\n\nReturns nodes that have an output, i.e., Source and NetworkNode nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.nodes_emissions","page":"Nodes","title":"EnergyModelsBase.nodes_emissions","text":"has_emissions(ùí©::Array{<:Node})\n\nReturns nodes that have emission data for a given Array ::Array{<:Node}.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.has_input","page":"Nodes","title":"EnergyModelsBase.has_input","text":"has_input(n::Node)\n\nReturns logic whether the node is an input node, i.e., Sink and NetworkNode nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.has_output","page":"Nodes","title":"EnergyModelsBase.has_output","text":"has_output(n::Node)\n\nReturns logic whether the node is an output node, i.e., Source and NetworkNode nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.has_emissions-Tuple{EnergyModelsBase.Node}","page":"Nodes","title":"EnergyModelsBase.has_emissions","text":"has_emissions(n::Node)\n\nChecks whether node n has emissions.\n\n\n\n\n\n","category":"method"},{"location":"library/public/nodes/#EnergyModelsBase.has_charge","page":"Nodes","title":"EnergyModelsBase.has_charge","text":"has_charge(n::Storage)\n\nReturns logic whether the node has a charge field allowing for restrictions and/or costs on the (installed) charging rate.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.has_discharge","page":"Nodes","title":"EnergyModelsBase.has_discharge","text":"has_discharge(n::Storage)\n\nReturns logic whether the node has a discharge field allowing for restrictions and/or costs on the (installed) discharging rate.\n\n\n\n\n\n","category":"function"},{"location":"library/public/nodes/#EnergyModelsBase.is_unidirectional-Tuple{EnergyModelsBase.Node}","page":"Nodes","title":"EnergyModelsBase.is_unidirectional","text":"is_unidirectional(n::Node)\n\nReturns logic whether the node n can be used bidirectional or only unidirectional.\n\nnote: Bidirectional flow in nodes\nIn the current stage, EnergyModelsBase does not include any nodes which can be used bidirectional, that is with flow reversal.If you plan to use bidirectional flow, you have to declare your own nodes and links that support this. You can then dispatch on this function for the incorporation.\n\n\n\n\n\n","category":"method"},{"location":"manual/quick-start/#man-quick","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"Install the most recent version of Julia\nInstall the package EnergyModelsBase and the time package TimeStruct, by running:\n] add TimeStruct\n] add EnergyModelsBase","category":"page"},{"location":"library/public/functions/#lib-pub-fun","page":"Functions","title":"General functions of EnergyModelsBase","text":"","category":"section"},{"location":"library/public/functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"library/public/functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"library/public/functions/#lib-pub-fun-run","page":"Functions","title":"Functions for running the model","text":"","category":"section"},{"location":"library/public/functions/","page":"Functions","title":"Functions","text":"The following functions are provided for both creating a model using EnergyModelsBase and solving said model. Both functions have the input case and model. run_model calls create_model in the function, hence, it is not necessary to call the function beforehand.","category":"page"},{"location":"library/public/functions/","page":"Functions","title":"Functions","text":"The case dictionary has to follow a certain outline. In this case, it is simplest to look at the provided examples.","category":"page"},{"location":"library/public/functions/","page":"Functions","title":"Functions","text":"note: Note\nWe are currently debating to replace the dictionary used for case as well with a composite type. This will lead to breacking changes, but should be simple to adjust for.","category":"page"},{"location":"library/public/functions/#EnergyModelsBase.create_model","page":"Functions","title":"EnergyModelsBase.create_model","text":"create_model(\n    case,\n    modeltype::EnergyModel,\n    m::JuMP.Model;\n    check_timeprofiles::Bool = true,\n    check_any_data::Bool = true,\n)\n\nCreate the model and call all required functions.\n\nArguments\n\ncase - The case dictionary requiring the keys :T, :nodes, :links, and products. If the input is not provided in the correct form, the checks will identify the problem.\nmodeltype - Used modeltype, that is a subtype of the type EnergyModel.\nm - the empty JuMP.Model instance. If it is not provided, then it is assumed that the input is a standard JuMP.Model.\n\nKeyword arguments\n\ncheck_timeprofiles=true - A boolean indicator whether the time profiles of the individual nodes should be checked or not. It is advised to not deactivate the check, except if you are testing new components. It may lead to unexpected behaviour and potential inconsistencies in the input data, if the time profiles are not checked.\ncheck_any_data::Bool=true - A boolean indicator whether the input data is checked or not. It is advised to not deactivate the check, except if you are testing new features. It may lead to unexpected behaviour and even infeasible models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.run_model","page":"Functions","title":"EnergyModelsBase.run_model","text":"run_model(case::Dict, model::EnergyModel, optimizer)\n\nTake the case data as a dictionary and the model and build and optimize the model. Returns the solved JuMP model.\n\nThe dictionary requires the keys:\n\n:nodes::Vector{Node}\n:links::Vector{Link}\n:products::Vector{Resource}\n:T::TimeStructure\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#lib-pub-fun-ext","page":"Functions","title":"Functions for extending the model","text":"","category":"section"},{"location":"library/public/functions/","page":"Functions","title":"Functions","text":"The following functions are used for developing new nodes. See the page Creating a new node for a detailed explanation on how to create a new node.","category":"page"},{"location":"library/public/functions/#EnergyModelsBase.variables_node","page":"Functions","title":"EnergyModelsBase.variables_node","text":"variables_node(m, ùí©À¢·µò·µá::Vector{<:Node}, ùíØ, modeltype::EnergyModel)\n\nDefault fallback method when no method is defined for a node type. No variables are created in this case.\n\n\n\n\n\nvariables_node(m, ùí©À¢‚Å±‚Åø·µè::Vector{<:Sink}, ùíØ, modeltype::EnergyModel)\n\nWhen the node vector is a Vector{<:Sink}, both surplus (:sink_surplus) and deficit (:sink_deficit) variables are created to quantify when there is too much or too little energy for satisfying the demand.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.create_node","page":"Functions","title":"EnergyModelsBase.create_node","text":"create_node(m, n::Source, ùíØ, ùí´, modeltype::EnergyModel)\n\nSet all constraints for a Source. Can serve as fallback option for all unspecified subtypes of Source.\n\nCalled constraint functions\n\nconstraints_data for all node_data(n),\nconstraints_flow_out,\nconstraints_capacity,\nconstraints_opex_fixed, and\nconstraints_opex_var.\n\n\n\n\n\ncreate_node(m, n::NetworkNode, ùíØ, ùí´, modeltype::EnergyModel)\n\nSet all constraints for a NetworkNode. Can serve as fallback option for all unspecified subtypes of NetworkNode.\n\nCalled constraint functions\n\nconstraints_data for all node_data(n),\nconstraints_flow_in,\nconstraints_flow_out,\nconstraints_capacity,\nconstraints_opex_fixed, and\nconstraints_opex_var.\n\n\n\n\n\ncreate_node(m, n::Storage, ùíØ, ùí´, modeltype::EnergyModel)\n\nSet all constraints for a Storage. Can serve as fallback option for all unspecified subtypes of Storage.\n\nCalled constraint functions\n\nconstraints_level\nconstraints_data for all node_data(n),\nconstraints_flow_in,\nconstraints_flow_out,\nconstraints_capacity,\nconstraints_opex_fixed, and\nconstraints_opex_var.\n\n\n\n\n\ncreate_node(m, n::Sink, ùíØ, ùí´, modeltype::EnergyModel)\n\nSet all constraints for a Sink. Can serve as fallback option for all unspecified subtypes of Sink.\n\nCalled constraint functions\n\nconstraints_data for all node_data(n),\nconstraints_flow_in,\nconstraints_capacity,\nconstraints_opex_fixed, and\nconstraints_opex_var.\n\n\n\n\n\ncreate_node(m, n::Availability, ùíØ, ùí´, modeltype::EnergyModel)\n\nSet all constraints for a Availability. Can serve as fallback option for all unspecified subtypes of Availability.\n\nAvailability nodes can be seen as routing nodes. It is not necessary to have more than one available node except if one wants to include as well transport between different Availability nodes with associated costs (not implemented at the moment).\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.variables_link","page":"Functions","title":"EnergyModelsBase.variables_link","text":"variables_link(m, ‚ÑíÀ¢·µò·µá::Vector{<:Link}, ùíØ, modeltype::EnergyModel)\n\nDefault fallback method when no method is defined for a Link type.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#lib-pub-fun-con","page":"Functions","title":"Constraint functions","text":"","category":"section"},{"location":"library/public/functions/","page":"Functions","title":"Functions","text":"The following functions can be used in newly developed nodes to include constraints. See the pages Constraint functions and Data functions for a detailed explanation on their usage.","category":"page"},{"location":"library/public/functions/","page":"Functions","title":"Functions","text":"warning: Warning\nThe function constraints_capacity_installed should not be changed. It is used for the inclusion of investments through EnergyModelsInvestments in the extension. It also has to be called, if you create a new function constraints_capacity.","category":"page"},{"location":"library/public/functions/#EnergyModelsBase.constraints_flow_in","page":"Functions","title":"EnergyModelsBase.constraints_flow_in","text":"constraints_flow_in(m, n, ùíØ::TimeStructure, modeltype::EnergyModel)\nconstraints_flow_in(m, n::Storage, ùíØ::TimeStructure, modeltype::EnergyModel)\nconstraints_flow_in(m, n::Storage{AccumulatingEmissions}, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the outlet flow from a generic Node or Storage.\n\nThese functions serve as fallback option if no other method is specified for a specific Node.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.constraints_flow_out","page":"Functions","title":"EnergyModelsBase.constraints_flow_out","text":"constraints_flow_out(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)\nconstraints_flow_out(m, n::Storage, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the outlet flow from a generic Node. This function serves as fallback option if no other function is specified for a Node.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.constraints_capacity","page":"Functions","title":"EnergyModelsBase.constraints_capacity","text":"constraints_capacity(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)\nconstraints_capacity(m, n::Storage, ùíØ::TimeStructure, modeltype::EnergyModel)\nconstraints_capacity(m, n::Sink, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraints on the maximum capacity of a generic Node, Storage, and Sink.\n\nThese functions serve as fallback option if no other method is specified for a specific Node.\n\nwarning: Dispatching on this function\nIf you create a new method for this function, it is crucial to call within said function the function constraints_capacity_installed(m, n, ùíØ, modeltype) if you want to include investment options.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.constraints_capacity_installed-Tuple{Any, EnergyModelsBase.Node, TimeStructure, EnergyModel}","page":"Functions","title":"EnergyModelsBase.constraints_capacity_installed","text":"constraints_capacity_installed(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)\nconstraints_capacity_installed(m, n::Storage, ùíØ::TimeStructure, modeltype::EnergyModel)\nconstraints_capacity_installed(m, l::Link, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the installed capacity to the available capacity.\n\nThese functions serve as fallback option if no other method is specified for a specific Node or Link.\n\ndanger: Dispatching on this function\nThis function should only be used to dispatch on the modeltype for providing investments. If you create new capacity variables (as it is the case for storage nodes), it is beneficial to include as well a method for this function and the corresponding node types.\n\n\n\n\n\n","category":"method"},{"location":"library/public/functions/#EnergyModelsBase.constraints_level","page":"Functions","title":"EnergyModelsBase.constraints_level","text":"constraints_level(m, n::Storage, ùíØ, ùí´, modeltype::EnergyModel)\n\nFunction for creating the level constraints of a Storage node. If you create a new Storage node, you should include this function in your calls. It provides all information required for the various StorageBehaviors.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.constraints_level_aux","page":"Functions","title":"EnergyModelsBase.constraints_level_aux","text":"constraints_level_aux(m, n::Storage, ùíØ, ùí´, modeltype::EnergyModel)\nconstraints_level_aux(m, n::RefStorage{AccumulatingEmissions}, ùíØ, ùí´, modeltype::EnergyModel)\n\nFunction for creating the Œî constraint for the level of a generic Storage node. EnergyModelsBase provides as well a method for a RefStorage{AccumulatingEmissions}.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.constraints_opex_var","page":"Functions","title":"EnergyModelsBase.constraints_opex_var","text":"constraints_opex_var(m, n::Node, ùíØ·¥µ‚Åø·µõ, modeltype::EnergyModel)\nconstraints_opex_var(m, n::Storage, ùíØ·¥µ‚Åø·µõ, modeltype::EnergyModel)\nconstraints_opex_var(m, n::Sink, ùíØ·¥µ‚Åø·µõ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the variable OPEX of a generic Node, Storage, and Sink.\n\nThis function serves as fallback option if no other method is specified for a Node.\n\nIn the case of a Storage node, the fallback option includes variable OPEX for charge, level, and discharge if the node has the corresponding storage parameter. The individual contributions are in all situations calculated based on the installed capacities.\n\nIn the case of a Sink node, the variable OPEX is calculate through the penalties for both surplus and deficit.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.constraints_opex_fixed","page":"Functions","title":"EnergyModelsBase.constraints_opex_fixed","text":"constraints_opex_fixed(m, n::Node, ùíØ·¥µ‚Åø·µõ, modeltype::EnergyModel)\nconstraints_opex_fixed(m, n::Storage, ùíØ·¥µ‚Åø·µõ, modeltype::EnergyModel)\nconstraints_opex_fixed(m, n::Sink, ùíØ·¥µ‚Åø·µõ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the fixed OPEX of a generic Node, Storage, and Sink.\n\nThis function serves as fallback option if no other method is specified for a Node.\n\nThe fallback option for Storage nodes includes fixed OPEX for charge, level, and discharge if the node has the corresponding storage parameter. The individual contributions are in all situations calculated based on the installed capacities.\n\nIn the case of a Storage node, the fallback option includes fixed OPEX for charge, level, and discharge if the node has the corresponding storage parameter. The individual contributions are in all situations calculated based on the installed capacities.\n\nIn the case of a Sink node, the fallback option fixes the value of the variable :opex_fixed to 0.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.constraints_data","page":"Functions","title":"EnergyModelsBase.constraints_data","text":"constraints_data(m, n::Node, ùíØ, ùí´, modeltype::EnergyModel, data::EmissionsEnergy)\nconstraints_data(m, n::Node, ùíØ, ùí´, modeltype::EnergyModel, data::EmissionsProcess)\nconstraints_data(m, n::Node, ùíØ, ùí´, modeltype::EnergyModel, data::CaptureEnergyEmissions)\nconstraints_data(m, n::Node, ùíØ, ùí´, modeltype::EnergyModel, data::CaptureProcessEmissions)\nconstraints_data(m, n::Node, ùíØ, ùí´, modeltype::EnergyModel, data::CaptureProcessEnergyEmissions)\n\nConstraints functions for calculating both the emissions and amount of CO‚ÇÇ captured in the process. If the data ia a CaptureData, it provides the constraint for the variable :flow_out of CO‚ÇÇ.\n\nThere exist several configurations:\n\nEmissionsEnergy corresponds to only energy usage related emissions.\nEmissionsProcess corresponds to both process and energy usage related emissions.\nCaptureEnergyEmissions corresponds to capture of energy usage related emissions, can include process emissions.\nCaptureProcessEmissions corresponds to capture of process emissions while energy usage related emissions are not captured.\nCaptureProcessEnergyEmissions corresponds to capture of both process and energy  usage related emissions.\n\n\n\n\n\nconstraints_data(m, n::Node, ùíØ, ùí´, modeltype::EnergyModel, data::Data)\n\nFallback option when data is specified, but it is not desired to add the constraints through this function. This is, e.g., the case for EnergyModelsInvestments as the capacity constraint has to be replaced.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/","page":"Functions","title":"Functions","text":"In addition, auxiliary functions are introduced for the calculation of the previous level of storage nodes. These auxiliary functions provide the user with simple approaches for calculating the level balances.","category":"page"},{"location":"library/public/functions/#EnergyModelsBase.previous_level","page":"Functions","title":"EnergyModelsBase.previous_level","text":"previous_level(\n    m,\n    n::Storage,\n    prev_pers::PreviousPeriods,\n    cyclic_pers::CyclicPeriods,\n    modeltype::EnergyModel,\n)\n\nReturns the level used as previous level of a Storage node depending on the type of PreviousPeriods.\n\nThe basic functionality is used in the case when the previous operational period is a TimePeriod, in which case it just returns the previous operational period.\n\n\n\n\n\nprevious_level(\n    m,\n    n::Storage,\n    prev_pers::PreviousPeriods{<:NothingPeriod, Nothing, Nothing},\n    cyclic_pers::CyclicPeriods,\n    modeltype::EnergyModel,\n)\n\nWhen the previous operational and representative period are Nothing, the function returns the cyclic constraints within a strategic period. This is achieved through calling a subfunction previous_level_sp to avoid method ambiguities.\n\n\n\n\n\nprevious_level(\n    m,\n    n::Storage,\n    prev_pers::PreviousPeriods{<:NothingPeriod, Nothing, Nothing},\n    cyclic_pers::CyclicPeriods,\n    modeltype::EnergyModel,\n)\n\nWhen the previous operational and representative period are Nothing and the storage node is an AccumulatingEmissions storage node, the function returns a value of 0.\n\n\n\n\n\nprevious_level(\n    m,\n    n::Storage,\n    prev_pers::PreviousPeriods{<:NothingPeriod, <:TS.AbstractRepresentativePeriod, Nothing},\n    cyclic_pers::CyclicPeriods,\n    modeltype::EnergyModel,\n)\n\nWhen the previous operational period is Nothing, the previous representative period an AbstractRepresentativePeriod and the last period is an AbstractRepresentativePeriod, then the time structure does include RepresentativePeriods.\n\nThe cyclic default constraints returns the value at the end of the previous representative period while accounting for the number of  repetitions of the representative period.\n\n\n\n\n\nprevious_level(\n    m,\n    n::Storage{CyclicRepresentative},\n    prev_pers::PreviousPeriods{<:NothingPeriod, <:TS.AbstractRepresentativePeriod, Nothing},\n    cyclic_pers::CyclicPeriods,\n    modeltype::EnergyModel,\n)\n\nWhen the previous operational period is Nothing and the previous representative period an AbstractRepresentativePeriod then the time structure does include RepresentativePeriods.\n\nThe cyclic constraint for a CyclicRepresentative storage nodereturns the value at the end of the current representative period.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#EnergyModelsBase.previous_level_sp","page":"Functions","title":"EnergyModelsBase.previous_level_sp","text":"previous_level_sp(\n    m,\n    n::Storage{<:Cyclic},\n    cyclic_pers::CyclicPeriods,\n    modeltype\n)\n\nReturns the previous period in the case of the first operational period (in the first representative period) of a strategic period.\n\nThe default functionality in the case of a Cyclic storage node in a TimeStructure without RepresentativePeriods returns the last operational period in the strategic period.\n\n\n\n\n\nprevious_level_sp(\n    m,\n    n::Storage{CyclicStrategic},\n    cyclic_pers::CyclicPeriods{<:TS.AbstractRepresentativePeriod},\n    modeltype::EnergyModel,\n)\n\nWhen a CyclicStrategic Storage node is coupled with a TimeStructure containing RepresentativePeriods, then the function calculates the level at the beginning of the first representative period through the changes in the level in the last representative period.\n\n\n\n\n\nprevious_level_sp(\n    m,\n    n::Storage{CyclicRepresentative},\n    cyclic_pers::CyclicPeriods{<:TS.AbstractRepresentativePeriod},\n    modeltype::EnergyModel,\n)\n\nWhen a CyclicRepresentative Storage node is coupled with a TimeStructure containing RepresentativePeriods, then the function returns the previous level as the level at the end of the current representative period.\n\n\n\n\n\n","category":"function"},{"location":"library/public/functions/#lib-pub-fun-util","page":"Functions","title":"Utility functions","text":"","category":"section"},{"location":"library/public/functions/","page":"Functions","title":"Functions","text":"The following function can be used in newly developed nodes to scale from operational to strategic periods. The function replaced the previously used function [EMB.multiple] which is still available with a deprecation warning.","category":"page"},{"location":"library/public/functions/#EnergyModelsBase.scale_op_sp","page":"Functions","title":"EnergyModelsBase.scale_op_sp","text":"scale_op_sp(t_inv::TS.AbstractStrategicPeriod, t::TS.TimePeriod)\n\nProvides a simplified function for returning the multiplication\n\nduration(t) * multiple_strat(t_inv t) * probability(t)\n\nwhen operational periods are coupled with strategic periods. It is used to scale the value provided for operational periods to a duration of 1 of a strategic period.\n\nExample\n\n# Time structure representing to strategic periods with a duration of 4 years each and\n# including a single week with hourly resolution\nts = TwoLevel(2, 4, SimpleTimes(168,1); op_per_strat=8760.0);\n\n# Extracting the first strategic period and its first operational period\nt_inv = first(strat_periods(ts))\nt = first(t_inv)\n\n# Calculating the value as 52.14 (number of weeks in a year)\nscale_op_sp(t_inv, t)\n\n\n\n\n\n","category":"function"},{"location":"how-to/update-models/#how_to-update","page":"Update models","title":"Update your model to the latest versions","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"EnergyModelsBase is still in a pre-release version. Hence, there are frequently breaking changes occuring, although we plan to keep backwards compatibility. This document is designed to provide users with information regarding how they have to adjust their models to keep compatibility to the latest changes. We will as well implement information regarding the adjustment of extension packages, although this is more difficult due to the vast majority of potential changes.","category":"page"},{"location":"how-to/update-models/#how_to-update-06","page":"Update models","title":"Adjustments from 0.6.x","text":"","category":"section"},{"location":"how-to/update-models/#how_to-update-06-nodes","page":"Update models","title":"Key changes for nodal descriptions","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"Version 0.7 introduced both storage behaviours resulting in a rework of the individual approach for calculating the level balance as well as the potential to have charge and discharge capacities through storage parameters.","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"note: Note\nThe legacy constructors for calls of the composite type of version 0.6 will be included at least until version 0.8.","category":"page"},{"location":"how-to/update-models/#[RefStorage](@ref)","page":"Update models","title":"RefStorage","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"RefStorage was significantly reworked since version 0.6. The total rework is provided below.","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"If you are previously using the functions capacity, opex_var, and opex_fixed directly on the nodal type, you have to adjust as well your call of the function as they now require the call on the StorageParameter type.","category":"page"},{"location":"how-to/update-models/#RefStorage{:ResourceCarrier}-translates-to-RefStorage{CyclicStrategic}","page":"Update models","title":"RefStorage{<:ResourceCarrier} translates to RefStorage{CyclicStrategic}","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous nodal description for a storage node storing a `ResourceCarrier` was given by:\nRefStorage(\n    id,\n    rate_cap::TimeProfile,\n    stor_cap::TimeProfile,\n    opex_var::TimeProfile,\n    opex_fixed::TimeProfile,\n    stor_res::ResourceCarrier,\n    input::Dict{<:Resource,<:Real},\n    output::Dict{<:Resource,<:Real},\n    data::Array,\n)\n\n# This translates to the following new version\nRefStorage{CyclicStrategic}(\n    id,\n    StorCapOpexVar(rate_cap, opex_var),\n    StorCapOpexFixed(stor_cap, opex_fixed),\n    stor_res,\n    input,\n    output,\n    data,\n)","category":"page"},{"location":"how-to/update-models/#RefStorage{:ResourceEmit}-translates-to-RefStorage{AccumulatingEmissions}","page":"Update models","title":"RefStorage{<:ResourceEmit} translates to RefStorage{AccumulatingEmissions}","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous nodal description for a storage node storing a `ResourceEmit` was given by:\nRefStorageEmissions(\n    id,\n    rate_cap::TimeProfile,\n    stor_cap::TimeProfile,\n    opex_var::TimeProfile,\n    opex_fixed::TimeProfile,\n    stor_res::ResourceEmit,\n    input::Dict{<:Resource,<:Real},\n    output::Dict{<:Resource,<:Real},\n    data::Array,\n)\n\n# This translates to the following new version\nRefStorage{AccumulatingEmissions}(\n    id,\n    StorCapOpex(rate_cap, opex_var, opex_fixed),\n    StorCap(stor_cap),\n    stor_res,\n    input,\n    output,\n    data,\n)","category":"page"},{"location":"how-to/update-models/#how_to-update-05","page":"Update models","title":"Adjustments from 0.5.x to 0.7.x","text":"","category":"section"},{"location":"how-to/update-models/#how_to-update-05-nodes","page":"Update models","title":"Key changes for nodal descriptions","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"Version 0.6 introduced EmissionsData for providing the user with more flexibility (and less input demand) for incorporating different types of emissions to the model. Hence, the Node types were adjusted. In addition, version 0.6 simplified the GenAvailability node and added emissions prices to the OperationalModel.","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"Version 0.7 introduced both storage behaviours resulting in a rework of the individual approach for calculating the level balance as well as the potential to have charge and discharge capacities through storage parameters.","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"warning: Warning\nThe legacy constructors for calls of the composite type of version 0.5 were removed in version 0.7. In addition, the adjustments will not be updated in release 0.8 as the models will be at that time most likely more than 1 year old.","category":"page"},{"location":"how-to/update-models/#[RefSource](@ref)","page":"Update models","title":"RefSource","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous nodal description was given by:\nRefSource(\n    id,\n    cap::TimeProfile,\n    opex_var::TimeProfile,\n    opex_fixed::TimeProfile,\n    output::Dict{<:Resource,<:Real},\n    data::Array,\n    emissions::Dict{<:ResourceEmit,<:Real},\n)\n\n# This translates to the following new version\nem_data = EmissionsProcess(emissions)\nappend!(data, [em_data])\nRefSource(id, cap, opex_var, opex_fixed, output, data)","category":"page"},{"location":"how-to/update-models/#RefNetwork-and-RefNetworkEmissions-to-[RefNetworkNode](@ref)","page":"Update models","title":"RefNetwork and RefNetworkEmissions to RefNetworkNode","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"The introduction of EmissionsData allowed to condense both previous types into a single new type. This new type was renamed to RefNetworkNode.","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous nodal description for a network node without emissions was given by:\nRefNetwork(\n    id,\n    cap::TimeProfile,\n    opex_var::TimeProfile,\n    opex_fixed::TimeProfile,\n    input::Dict{<:Resource,<:Real},\n    output::Dict{<:Resource,<:Real},\n    data::Array,\n)\n\n# This translates to the following new version\nRefNetworkNode(id, cap, opex_var, opex_fixed, input, output, data)","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous nodal description for a network node without emissions was given by:\nRefNetworkEmissions(\n    id,\n    cap::TimeProfile,\n    opex_var::TimeProfile,\n    opex_fixed::TimeProfile,\n    input::Dict{<:Resource,<:Real},\n    output::Dict{<:Resource,<:Real},\n    emissions::Dict{<:ResourceEmit,<:Real},\n    co2_capture::Real,\n    data::Array,\n)\n\n# This translates to the following new version\nem_data = CaptureEnergyEmissions(emissions, co2_capture)\nappend!(data, [em_data])\nRefNetworkNode(id, cap, opex_var, opex_fixed, input, output, data)","category":"page"},{"location":"how-to/update-models/#[RefStorage](@ref)-2","page":"Update models","title":"RefStorage","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"RefStorage was significantly reworked since version 0.5. The total rework is provided below.","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"If you are previously using the functions capacity, opex_var, and opex_fixed directly on the nodal type, you have to adjust as well your call of the function as they now require the call on the StorageParameter type.","category":"page"},{"location":"how-to/update-models/#RefStorage-translated-to-RefStorage{CyclicStrategic}","page":"Update models","title":"RefStorage translated to RefStorage{CyclicStrategic}","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous nodal description for a storage node storing a `ResourceCarrier` was given by:\nRefStorage(\n    id,\n    rate_cap::TimeProfile,\n    stor_cap::TimeProfile,\n    opex_var::TimeProfile,\n    opex_fixed::TimeProfile,\n    stor_res::ResourceCarrier,\n    input::Dict{<:Resource,<:Real},\n    output::Dict{<:Resource,<:Real},\n    data::Array,\n)\n\n# This translates to the following new version\nRefStorage{CyclicStrategic}(\n    id,\n    StorCapOpexVar(rate_cap, opex_var),\n    StorCapOpexFixed(stor_cap, opex_fixed),\n    stor_res,\n    input,\n    output,\n    data,\n)","category":"page"},{"location":"how-to/update-models/#RefStorageEmissions-translated-to-RefStorage{AccumulatingEmissions}","page":"Update models","title":"RefStorageEmissions translated to RefStorage{AccumulatingEmissions}","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous nodal description for a storage node storing a `ResourceEmit` was given by:\nRefStorageEmissions(\n    id,\n    rate_cap::TimeProfile,\n    stor_cap::TimeProfile,\n    opex_var::TimeProfile,\n    opex_fixed::TimeProfile,\n    stor_res::ResourceEmit,\n    input::Dict{<:Resource,<:Real},\n    output::Dict{<:Resource,<:Real},\n    data::Array,\n)\n\n# This translates to the following new version\nRefStorage{AccumulatingEmissions}(\n    id,\n    StorCapOpex(rate_cap, opex_var, opex_fixed),\n    StorCap(stor_cap),\n    stor_res,\n    input,\n    output,\n    data,\n)","category":"page"},{"location":"how-to/update-models/#[RefSink](@ref)","page":"Update models","title":"RefSink","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"RefSink has now as well the potential for investments although this would require a new type as the current operational cost calculated would incentivize retiring the demand directly.","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous nodal description was given by:\nRefSink(\n    id,\n    cap::TimeProfile,\n    penalty::Dict{<:Any,<:TimeProfile},\n    input::Dict{<:Resource,<:Real},\n    emissions::Dict{<:ResourceEmit,<:Real},\n)\n\n# This translates to the following new version\nem_data = EmissionsProcess(emissions)\nRefSink(id, cap, penalty, input, [em_data])","category":"page"},{"location":"how-to/update-models/#[GenAvailability](@ref)","page":"Update models","title":"GenAvailability","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"GenAvailability nodes do not require any longer the data for input and output, as they utilize a constructor, if only a single array is given.","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous nodal description was given by:\nGenAvailability(\n    id,\n    input::Dict{<:Resource,<:Real},\n    output::Dict{<:Resource,<:Real},\n)\n\n# This translates to the following new version\nGenAvailability(id, collect(keys(input)), collect(keys(output)))","category":"page"},{"location":"how-to/update-models/#[OperationalModel](@ref)","page":"Update models","title":"OperationalModel","text":"","category":"section"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"OperationalModel incorporated the concept of emission prices as initially introduced in EnergyModelsInvestments.","category":"page"},{"location":"how-to/update-models/","page":"Update models","title":"Update models","text":"# The previous model description was given by:\nOperationalModel(\n    emission_limit::Dict{<:ResourceEmit, <:TimeProfile},\n    co2_instance::ResourceEmit,\n)\n\n# This translates to the following new version\nemission_price = Dict(k => FixedProfile(0) for k ‚àà keys(emission_limit))\nOperationalModel(emission_limit, emission_price, co2_instance)","category":"page"},{"location":"library/public/model_data/#lib-pub-mod_data","page":"Modeltype and Data","title":"Model and data","text":"","category":"section"},{"location":"library/public/model_data/#lib-pub-mod_data-types","page":"Modeltype and Data","title":"EnergyModel","text":"","category":"section"},{"location":"library/public/model_data/","page":"Modeltype and Data","title":"Modeltype and Data","text":"The type EnergyModel is used for creating the global parameters of a model. It can be as well used for extending EnergyModelsBase as described in the section Extensions to the model. EnergyModelsBase provides an OperationalModel for analyses with given capacities. OperationalModel contains some key information for the model such as the emissions limits and penalties for each ResourceEmit, as well as the ResourceEmit instance of CO‚ÇÇ.","category":"page"},{"location":"library/public/model_data/#EnergyModelsBase.EnergyModel","page":"Modeltype and Data","title":"EnergyModelsBase.EnergyModel","text":"Abstract type for differentation between types of models (investment, operational, ...).\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#EnergyModelsBase.OperationalModel","page":"Modeltype and Data","title":"EnergyModelsBase.OperationalModel","text":"OperationalModel <: EnergyModel\n\nOperational Energy Model without investments.\n\nFields\n\nemission_limit::Dict{<:ResourceEmit, <:TimeProfile} is a dictionary with individual emission limits as TimeProfile for each emission resource ResourceEmit.\nemission_price::Dict{<:ResourceEmit, <:TimeProfile} are the emission costs for each emission resources ResourceEmit.\nco2_instance is a ResourceEmit and corresponds to the type used for CO‚ÇÇ.\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#lib-pub-mod_data-fun_field_model","page":"Modeltype and Data","title":"Functions for accessing fields of EnergyModel types","text":"","category":"section"},{"location":"library/public/model_data/","page":"Modeltype and Data","title":"Modeltype and Data","text":"The following functions are declared for accessing fields from an EnergyModel type.","category":"page"},{"location":"library/public/model_data/","page":"Modeltype and Data","title":"Modeltype and Data","text":"warning: Warning\nIf you want to introduce new EnergyModel types, it is important that the functions emission_limit, emission_price, and co2_instance are either functional for your new types or you have to declare corresponding functions. The first approach can be achieved through using the same name for the respective fields.","category":"page"},{"location":"library/public/model_data/#EnergyModelsBase.emission_limit","page":"Modeltype and Data","title":"EnergyModelsBase.emission_limit","text":"emission_limit(modeltype::EnergyModel)\nemission_limit(modeltype, p::ResourceEmit)\nemission_limit(modeltype, p::ResourceEmit, t_inv::TS.AbstractStrategicPeriod)\n\nReturns the emission limit of EnergyModel model as dictionary with TimeProfiles for each ResourceEmit, as TimeProfile for ResourceEmit p or, in strategic period t_inv for ResourceEmit p.\n\n\n\n\n\n","category":"function"},{"location":"library/public/model_data/#EnergyModelsBase.emission_price","page":"Modeltype and Data","title":"EnergyModelsBase.emission_price","text":"emission_price(modeltype::EnergyModel)\nemission_price(modeltype, p::ResourceEmit)\nemission_price(modeltype, p::ResourceEmit, t_inv::TS.AbstractStrategicPeriod)\n\nReturns the emission price of EnergyModel model as dictionary with TimeProfiles for each ResourceEmit, as TimeProfile for ResourceEmit p or, in strategic period t_inv for ResourceEmit p.\n\n\n\n\n\n","category":"function"},{"location":"library/public/model_data/#EnergyModelsBase.co2_instance","page":"Modeltype and Data","title":"EnergyModelsBase.co2_instance","text":"co2_instance(modeltype::EnergyModel)\n\nReturns the CO‚ÇÇ instance used in modelling.\n\n\n\n\n\n","category":"function"},{"location":"library/public/model_data/#lib-pub-mod_data-data","page":"Modeltype and Data","title":"Additional data","text":"","category":"section"},{"location":"library/public/model_data/","page":"Modeltype and Data","title":"Modeltype and Data","text":"Emission data are used to provide the individual nodes with potential emissions. The approach is also explained on the page Data functions.","category":"page"},{"location":"library/public/model_data/#lib-pub-mod_data-data-types","page":"Modeltype and Data","title":"Data and Emission types","text":"","category":"section"},{"location":"library/public/model_data/","page":"Modeltype and Data","title":"Modeltype and Data","text":"Data types are introduced for introducing additional parameters, variables, and constraints to the Nodes. The approach of using the data field of Nodes is explained on the page Data functions. EmptyData is no longer relevant for the modelling, but it is retained for avoiding any problems with existing models.","category":"page"},{"location":"library/public/model_data/#EnergyModelsBase.Data","page":"Modeltype and Data","title":"EnergyModelsBase.Data","text":"Abstract type used to define concrete struct containing the package specific elements to add to the composite type defined in this package.\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#EnergyModelsBase.EmptyData","page":"Modeltype and Data","title":"EnergyModelsBase.EmptyData","text":"Empty composite type for Data\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/","page":"Modeltype and Data","title":"Modeltype and Data","text":"EmissionData is one approach for utilizing the data field of Nodes. The thought process with EmissionData is to provide the user with options for each individual node to include emissions and potentially capture or not. The individual types can be used for all included reference Nodes, although capture is not possible for Sink nodes due to the lack of an output. This explained in more detail on the corresponding node page.","category":"page"},{"location":"library/public/model_data/#EnergyModelsBase.EmissionsData","page":"Modeltype and Data","title":"EnergyModelsBase.EmissionsData","text":"EmissionsData{T<:Union{TimeProfile,Float64}} <: Data\n\nAbstract type for EmissionsData can be used to dispatch on different types of capture configurations.\n\nIn general, the different types require the following input:\n\nemissions::Dict{ResourceEmit, T} are the process emissions per capacity usage through the variable :cap_use. It allows for an input as TimeProfile or Float64.\nco2_capture::Float64 is the CO‚ÇÇ capture rate.\n\nTypes\n\nCaptureProcessEnergyEmissions: Capture both the process emissions and the energy usage related emissions.\nCaptureProcessEmissions: Capture the process emissions, but not the energy usage related emissions.\nCaptureEnergyEmissions: Capture the energy usage related emissions, but not the process emissions. Does not require emissions as input.\nEmissionsProcess: No capture, but process emissions are present. Does not require co2_capture as input, but will ignore it, if provided.\nEmissionsEnergy: No capture and no process emissions. Does not require co2_capture or emissions as input, but will ignore them, if provided.\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#EnergyModelsBase.CaptureData","page":"Modeltype and Data","title":"EnergyModelsBase.CaptureData","text":"CaptureData{T} <: EmissionsData{T}\n\nSupertype for all EmissionsData that include CO‚ÇÇ capture.\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#EnergyModelsBase.EmissionsEnergy","page":"Modeltype and Data","title":"EnergyModelsBase.EmissionsEnergy","text":"struct EmissionsEnergy{T} <: EmissionsData{T}\n\nEmissionsEnergy(_, _)\nEmissionsEnergy(_)\nEmissionsEnergy()\n\nNo capture, no process emissions are present. Does not require co2_capture or emissions as input, but accepts it and will ignore it, if provided.\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#EnergyModelsBase.EmissionsProcess","page":"Modeltype and Data","title":"EnergyModelsBase.EmissionsProcess","text":"struct EmissionsProcess{T} <: EmissionsData{T}\n\nEmissionsProcess(emissions::Dict{<:ResourceEmit,T}) where T\nEmissionsProcess(emissions::Dict{<:ResourceEmit,T}, _) where T\nEmissionsProcess()\n\nNo capture, but process emissions are present. Does not require co2_capture as input, but accepts it and will ignore it, if provided.\n\nFields\n\nemissions::Dict{ResourceEmit, T}: emissions per unit produced.\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#EnergyModelsBase.CaptureEnergyEmissions","page":"Modeltype and Data","title":"EnergyModelsBase.CaptureEnergyEmissions","text":"struct CaptureEnergyEmissions{T} <: CaptureData{T}\n\nCaptureEnergyEmissions(emissions::Dict{<:ResourceEmit, T}, co2_capture::Float64) where T\nCaptureEnergyEmissions(co2_capture::Float64)\n\nCapture the energy usage related emissions, but not the process emissions. Does not require emissions as input, but can be supplied.\n\nFields\n\nemissions::Dict{ResourceEmit, T} are the process emissions per capacity usage through the variable :cap_use.\nco2_capture::Float64 is the CO‚ÇÇ capture rate.\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#EnergyModelsBase.CaptureProcessEmissions","page":"Modeltype and Data","title":"EnergyModelsBase.CaptureProcessEmissions","text":"struct CaptureProcessEmissions{T} <: CaptureData{T}\n\nCaptureProcessEmissions(emissions::Dict{<:ResourceEmit, T}, co2_capture::Float64) where T\n\nCapture the process emissions, but not the energy usage related emissions.\n\nFields\n\nemissions::Dict{ResourceEmit, T} are the process emissions per capacity usage through the variable :cap_use.\nco2_capture::Float64 is the CO‚ÇÇ capture rate.\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#EnergyModelsBase.CaptureProcessEnergyEmissions","page":"Modeltype and Data","title":"EnergyModelsBase.CaptureProcessEnergyEmissions","text":"struct CaptureProcessEnergyEmissions{T} <: CaptureData{T}\n\nCaptureProcessEnergyEmissions(emissions::Dict{<:ResourceEmit, T}, co2_capture::Float64) where T\n\nCapture both the process emissions and the energy usage related emissions.\n\nFields\n\nemissions::Dict{ResourceEmit, T} are the process emissions per capacity usage through the variable :cap_use.\nco2_capture::Float64 is the CO‚ÇÇ capture rate.\n\n\n\n\n\n","category":"type"},{"location":"library/public/model_data/#lib-pub-mod_data-data-fun_field","page":"Modeltype and Data","title":"Functions for accessing fields of EmissionsData types","text":"","category":"section"},{"location":"library/public/model_data/","page":"Modeltype and Data","title":"Modeltype and Data","text":"The following functions are declared for accessing fields from an EmissionsData type.","category":"page"},{"location":"library/public/model_data/","page":"Modeltype and Data","title":"Modeltype and Data","text":"warning: Warning\nIf you want to introduce new EmissionsData types, it is important that the functions co2_capture and process_emissions are either functional for your new types or you have to declare corresponding functions. The first approach can be achieved through using the same name for the respective fields.","category":"page"},{"location":"library/public/model_data/#EnergyModelsBase.co2_capture","page":"Modeltype and Data","title":"EnergyModelsBase.co2_capture","text":"co2_capture(data::CaptureData)\n\nReturns the CO‚ÇÇ capture rate of the data.\n\n\n\n\n\n","category":"function"},{"location":"library/public/model_data/#EnergyModelsBase.process_emissions","page":"Modeltype and Data","title":"EnergyModelsBase.process_emissions","text":"process_emissions(data::EmissionsData)\nprocess_emissions(data::EmissionsData{T}, p::ResourceEmit)\nprocess_emissions(data::EmissionsData{T}, p:ResourceEmit, t)\n\nReturns the ResourceEmits that have process emissions of the EmissionsData data.\n\nWhen the ResourceEmit p is specified, it returns the process emissions as TimeProfile (FixedProfile, if the emissions are provided as Float64 and FixedProfile(0) if no values are provided.)\n\nWhen the ResourceEmit p and the operational period t are specified, it returns the value (or 0, if there are no process emissions for the specifed ResourceEmit p).\n\n\n\n\n\n","category":"function"},{"location":"nodes/storage/#nodes-storage","page":"Storage","title":"Storage","text":"","category":"section"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"Storage nodes are subtypes of Storage as they have in general an input and output (except for permanent CO‚ÇÇ storage). Storages require additional variables and parameters. As a consequence, a new abstract type is specified.","category":"page"},{"location":"nodes/storage/#nodes-storage-phil","page":"Storage","title":"Philosophy of Storage nodes","text":"","category":"section"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"Storage nodes differ from the other nodes as they are designed per default as parametric types using the concept of EnergyModelsBase.StorageBehavior. In addition, capacities and operational expenses are not included at the first level of the composite type, but instead on a lower level.","category":"page"},{"location":"nodes/storage/#nodes-storage-phil-parametric","page":"Storage","title":"Parametric implementation","text":"","category":"section"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The parametric input is not applied for any field, but instead for allowing simplified dispatch on the individual storage behavior of a Storage node. As TimeStruct, and hence, EnergyModelsBase supports the inclusion of both representative periods and operational scenarios, it was the aim in the design to provide a reusable approach for calculating the level balances. The structure of the level balance calculation is explained on Storage level constraints while you can find the mathematical description in the Section Level constraints.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"We differentiate between Accumulating and Cyclic storage behaviors. The former allows for a net change of the storage level within an investment period, while the latter requires a cyclic behavior for the level balance.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"A single concrete type is included for Accumulating using AccumulatingEmissions. This type was introduced for ResourceEmit resources to represent a permanent storage node. It was initially utilized for CO‚ÇÇ storage.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"Two concrete types are included for Cyclic, CyclicRepresentative and CyclicStrategic. These two types differ only if the time structure includes representative periods. If not, they are equivalent. In the case of inclusion of representative periods, CyclicRepresentative enforces the cyclic constraint within a representative period while CyclicStrategic enforces the cyclic constraint within the investment period. In the case of CyclicStrategic, we hence allow for a net change in the storage level within a representative period. This net change is then used for the scaling.","category":"page"},{"location":"nodes/storage/#nodes-storage-phil-capacities","page":"Storage","title":"Capacities","text":"","category":"section"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"Storage nodes can have up to three capacities, charge, storage level, and discharge. In practice, a storage allways requires a level capacity corresponding to the maximum amount of stored energy. However, it is not necessary to include charge and discharge capacities if they are","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"not representing an additional cost and\nit is possible to charge/discharge the storage within a single operational period.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"In this case, the Storage implementation allows the user to specify EnergyModelsBase.AbstractStorageParameters reflecting the required input. We allow for multiple combinations within EnergyModelsBase.AbstractStorageParameters containing a capacity, a variable OPEX, and/or a fixed OPEX. This is beneficial for ,e.g., compressed hydrogen storage in which the charge capacity requires investments in compressors, while the discharge capacity is purely limited by the structural limits.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The individual types are","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"StorCapOpex - the capacity includes a capacity as well as a fixed and variable OPEX,\nStorCap - the capacity only includes a capacity,\nStorCapOpexVar - the capacity includes a capacity as well as a variable OPEX,\nStorCapOpexFixed - the capacity includes a capacity as well as a fixed variable OPEX, and\nStorOpexVar - the capacity includes only a variable OPEX.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"EnergyModelsBase provides although union types for simplifying providing new dispatch. These are EnergyModelsBase.UnionOpexFixed, EnergyModelsBase.UnionOpexVar, and EnergyModelsBase.UnionCapacity.","category":"page"},{"location":"nodes/storage/#nodes-storage-fields","page":"Storage","title":"Introduced type and its fields","text":"","category":"section"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The RefStorage node is implemented as a reference node that can be used for a Storage. It includes basic functionalities common to most energy system optimization models.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The fields of a RefStorage are given as:","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"id:\nThe field id is only used for providing a name to the node.\ncharge::AbstractStorageParameters:\n  More information can be found on storage parameters.\nlevel::UnionCapacity:\nThe level storage parameters must include a capacity. More information can be found on storage parameters.\nnote: Permitted values for storage parameters in `charge` and `level`\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. Similarly, you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. The variable operating expenses can be provided as OperationalProfile as well. In addition, all capacity and fixed OPEX values have to be non-negative.\nstor_res::ResourceEmit:\nThe stor_res is the stored Resource.\ninput::Dict{<:Resource,<:Real} and output::Dict{<:Resource,<:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries. It is not necessary to specify the stored Resource (outlined above), but it is in general advisable.\nAll values have to be non-negative.\nwarning: Ratios for Storage\nIn the current implementation, we do not consider output conversion factors for the outflow from the RefStorage node. Similarly, we do not consider the input conversion factor of the stored resource. Instead, it is assumed that there is no loss of the stored resource in the storage.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used.\nnote: Note\nThe field data is not required as we include a constructor when the value is excluded.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"danger: Discharge values for `RefStorage`\nRefStorage nodes do not include a discharge capacity or corresponding operating expenses. Instead, it is possible to empty the storage within a single operational period. If you need to specify a discharge capacity (or want to implement it as a ratio to the charge capacity), you have to create a new Storage type. This is explain on Advanced creation of new nodes.In practice, the key change would be to provide an additional field called discharge to the new Storage type.","category":"page"},{"location":"nodes/storage/#nodes-storage-math","page":"Storage","title":"Mathematical description","text":"","category":"section"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"textttvar_exampleindex_1 index_2","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"with square brackets, while functions are represented as","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"func_example(index_1 index_2)","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"with paranthesis.","category":"page"},{"location":"nodes/storage/#nodes-storage-math-var","page":"Storage","title":"Variables","text":"","category":"section"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The variables of Storages include:","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"textttopex_var\ntextttopex_fixed\ntextttstor_level_inst\ntextttstor_level\ntextttstor_charge_inst if the Storage has the field charge with a capacity\ntextttstor_charge_use\ntextttstor_discharge_inst if the Storage has the field discharge with a capacity\ntextttstor_discharge_use\ntextttflow_in\ntextttflow_out\ntextttstor_level_Œî_op\ntextttstor_level_Œî_rp if the TimeStruct includes RepresentativePeriods\ntextttemissions_node if specified through the function has_emissions or if you use a RefStorage{AccumulatingEmissions}.","category":"page"},{"location":"nodes/storage/#nodes-storage-math-con","page":"Storage","title":"Constraints","text":"","category":"section"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"A qualitative overview of the individual constraints can be found on Constraint functions. This section focuses instead on the mathematical description of the individual constraints. It omits the direction inclusion of the vector of network nodes (or all nodes, if nothing specific is implemented). Instead, it is implicitly assumed that the constraints are valid forall n  N^textStorage for all Storage types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The following standard constraints are implemented for a Storage node. Storage nodes utilize the declared method for all nodes ùí©. The constraint functions are called within the function create_node. Hence, if you do not have to call additional functions, but only plan to include a method for one of the existing functions, you do not have to specify a new create_node method.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"constraints_capacity:\nbeginaligned\ntextttstor_level_usen t  leq textttstor_level_instn t \ntextttstor_charge_usen t  leq textttstor_charge_instn t \ntextttstor_discharge_usen t  leq textttstor_discharge_instn t\nendaligned\nconstraints_capacity_installed:\nbeginaligned\ntextttstor_level_instn t  = capacity(level(n) t) \ntextttstor_charge_instn t  = capacity(charge(n) t) \ntextttstor_discharge_instn t  = capacity(discharge(n) t)\nendaligned\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_in:\nThe auxiliary resource constraints are independent of the chosen storage behavior:\ntextttflow_inn t p = inputs(n p) times textttflow_inn stor_res(n)\nqquad forall p in inputs(n) setminus stor_res(n)\nThe stored resource constraints are depending on the chosen storage behavior. If no behavior is specified, it is given by\ntextttflow_inn t stor_res(n) = textttstor_charge_usen t\nIf the storage behavior is AccumulatingEmissions, it is given by\ntextttflow_inn t stor_res(n) = textttstor_charge_usen t - textttemissions_noden t stor_res(n)\nThis allows the storage node to provide a soft constraint for emissions.\nconstraints_flow_out:\ntextttflow_outn t stor_res(n) = textttstor_discharge_usen t\ntip: Behavior in the case of `AccumulatingEmissions`\nIn this case, the constraints are still declared. The variables are however fixed to 0. Hence, it will have no impact.\nconstraints_level:\nThe level constraints are more complex compared to the standard constraints. They are explained in detail below in Level constraints.\nconstraints_opex_fixed:\nbeginaligned\ntextttopex_fixedn t_inv =  \n  opex_fixed(level(n) t_inv) times textttstor_level_instn first(t_inv) +  \n  opex_fixed(charge(n) t_inv) times textttstor_charge_instn first(t_inv) +  \n  opex_fixed(discharge(n) t_inv) times textttstor_discharge_instn first(t_inv)\nendaligned\ntip: Why do we use `first()`\nThe variables textttstor_level_inst are declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacities in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\nbeginaligned\ntextttopex_varn t_inv =  sum_t in t_inv\n  opex_var(level(n) t) times textttstor_leveln t times scale_op_sp(t_inv t) +  \n  opex_var(charge(n) t) times textttstor_charge_usen t times scale_op_sp(t_inv t) +  \n  opex_var(discharge(n) t) times textttstor_discharge_usen t times scale_op_sp(t_inv t)\nendaligned\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified data of the storage node, see above.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"info: Implementation of capacity and OPEX\nThe capacity constraints, both constraints_capacity and constraints_capacity_installed are only set for capacities that are included through the corresponding field and if the corresponding storage parameters have a field capacity. Otherwise, they are omitted. The field level is required to have a storage parameter with capacity.Even if a Storage node includes the corresponding capacity field (i.e., charge, level, and discharge), we only include the fixed and variable OPEX constribution for the different capacities if the corresponding storage parameters have a field opex_fixed and opex_var, respectively. Otherwise, they are omitted.","category":"page"},{"location":"nodes/storage/#nodes-storage-math-con-level","page":"Storage","title":"Level constraints","text":"","category":"section"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The overall structure is outlined on Constraint functions. The level constraints are called through the function constraints_level which then calls additional functions depending on the chosen time structure (whether it includes representative periods and/or operational scenarios) and the chosen storage behaviour.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The constraints introduced in constraints_level_aux are given by","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"textttstor_level_Œî_opn t = textttstor_charge_usen t - textttstor_discharge_usen t","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"corresponding to the change in the storage level in an operational period. If the storage behavior is AccumulatingEmissions, it is instead given by","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"textttstor_level_Œî_opn t = textttstor_charge_usen t","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"In this case, we also fix variables and provide lower bounds:","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"beginaligned\n textttemissions_noden t stor_res(n) geq 0 \n textttemissions_noden t p_em = 0 qquad  forall p_em in P^em setminus stor_res(n) \n textttstor_level_Œî_opn t geq 0 \n textttstor_discharge_usen t = 0 \n textttflow_outn t p = 0 qquad  forall p in output(n)\nendaligned","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"If the time structure includes representative periods, we calculate the change of the storage level in each representative period within the function constraints_level_iterate:","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"textttstor_level_Œî_rpn t_rp = sum_t in t_rp\ntextttstor_level_Œî_opn t times scale_op_sp(t_rp t)","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"In the case of CyclicStrategic, we add an additional constraint to the change in the function constraints_level_rp:","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"sum_t_rp in T^rp textttstor_level_Œî_rpn t_rp = 0","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"while we fix the value in the case of CyclicRepresentative to 0:","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"textttstor_level_Œî_rpn t_rp = 0","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"Accumulating storage behaviors do not add any constraint for the variable textttstor_level_Œî_rp.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"If the time structure includes operational scenarios using CyclicRepresentative, we enforce that the last value in each operational scenario is the same within the function constraints_level_scp.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The general level constraint is eventually calculated in the function constraints_level_iterate:","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"textttstor_leveln t = prev_level +\ntextttstor_level_Œî_opn t times duration(t)","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"in which the value prev_level is depending on the type of the previous operational (t_prev) and strategic level (t_invprev) (as well as the previous representative period (t_rpprev)). It is calculated through the function previous_level.","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"We can distinguish the following cases:","category":"page"},{"location":"nodes/storage/","page":"Storage","title":"Storage","text":"The first operational period (in the first representative period) in an investment period (given by typeof(t_prev) = typeof(t_rp prev) = = nothing). In this situation, the previous level is dependent on the chosen storage behavior. In the default case of a Cyclic behaviors, it is given by the last operational period of either the strategic or representative period:\nbeginaligned\n  prev_level  = textttstor_leveln last(t_sp)\n  prev_level  = textttstor_leveln last(t_rp)\nendaligned\nIf the storage behavior is instead given by CyclicStrategic and the time structure includes representative periods, we calculate the previous level instead as:\nbeginaligned\nt_rplast  =  last(repr_periods(t_sp)) \nprev_level =  textttstor_leveln first(t_rplast) -  \n  textttstor_level_Œî_opn first(t_rplast) times duration(first(t_rplast)) +  \n  textttstor_level_Œî_rpn t_rplast\nendaligned\nt_rplast corresponds in this situation to the last representative period in the current investment period.\nIf the storage behavior is instead given by CyclicStrategic, the previous level is set to 0:\nprev_level = 0\nThe first operational period in subsequent representative periods in any investment period (given by typeof(t_prev) = nothing). The previous level is again dependent on the chosen storage behavior. The default approach calculates it as:\nbeginaligned\n prev_level =  textttstor_leveln first(t_rpprev) -  \n   textttstor_level_Œî_opn first(t_rpprev) times duration(first(t_rpprev)) +  \n   textttstor_level_Œî_rpn t_rpprev\nendaligned\nwhile a CyclicRepresentative storage behavior calculates it as:\nprev_level = textttstor_leveln last(t_rp)\nThis situation only occurs in cases in which the time structure includes representative periods.\nAll other operational periods:\n\n prev_level = textttstor_leveln t_prev","category":"page"},{"location":"manual/investments/#man-emi","page":"Investment options","title":"Adding investments","text":"","category":"section"},{"location":"manual/investments/","page":"Investment options","title":"Investment options","text":"Investment options are added through loading the package EnergyModelsInvestments. EnergyModelsInvestments was previously seen as extension package to EnergyModelsBase, that it was dependent on EnergyModelsBase and only allowed investment options in EnergyModelsBase. This approach was reversed from version 0.7 onwards and EnergyModelsInvestments is now a standalone package and provides an extension to EnergyModelsBase.","category":"page"},{"location":"manual/investments/#man-emi-gen","page":"Investment options","title":"General concept","text":"","category":"section"},{"location":"manual/investments/","page":"Investment options","title":"Investment options","text":"Investment options are added separately to each individual node through the field data. Hence, it is possible to use different prices for the same technology in different regions or allow investments only in a limited subset of technologies.","category":"page"},{"location":"manual/investments/","page":"Investment options","title":"Investment options","text":"We differentiate between SingleInvData and StorageInvData. Both types inlude as fields AbstractInvData which can be either in the form of StartInvData or NoStartInvData. The exact description of the individual investment data and their fields can be found in the public library of EnergyModelsInvestments.","category":"page"},{"location":"manual/investments/","page":"Investment options","title":"Investment options","text":"Investments require the application of an InvestmentModel instead of an OperationalModel. This allows us to provide two core functions with new methods, constraints_capacity_installed (as described on Constraint functions), variables_capex, a function previously not declaring any variables, and the function objective for declaring the objective function.","category":"page"},{"location":"manual/investments/#man-emi-var","page":"Investment options","title":"Added variables","text":"","category":"section"},{"location":"manual/investments/","page":"Investment options","title":"Investment options","text":"Investment options increase the number of variables. The individual variables are described in the documentation of EnergyModelsInvestments.","category":"page"},{"location":"manual/investments/","page":"Investment options","title":"Investment options","text":"All nodes (except Storage nodes) with investments use the prefix :cap. Storage nodes utilize the prefices :stor_level for level capacity investments, :stor_charge for storage charging capacity investments, and :stor_discharge for storage discharge capacity investments. Storage nodes only include these variables if they have the investment potential for the individual capacities.","category":"page"},{"location":"manual/investments/","page":"Investment options","title":"Investment options","text":"tip: Differentiation in capacity investments of Storage nodes\nStorage nodes have in general the possibility to allow for investments in all individual capacities or only a subset of capacities. However, we do not consider a discharge capacity for a RefStorage node as it is as simple as possible. Hence, it is possible to discharge a RefStorage node within an operational period.Although we include the potential for investments in both the charge and level capacities, we do not enforce that you include investment data for both capacities. Hence, it is entirely up to the user to specify whether he wants to include, e.g., an unlimited charge capacity and only investments in the level capacity, or a fixed level capacity and investments in charge capacities, or any combination.","category":"page"},{"location":"manual/philosophy/#man-phil","page":"Philosophy","title":"Philosophy","text":"","category":"section"},{"location":"manual/philosophy/#man-phil-gen","page":"Philosophy","title":"General design philosophy","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"One key aim in the development of EnergyModelsBase was to create an energy system model that","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"offers maximum flexibility with respect to the description of technologies,\nis simple to extend with additional features without requiring changes in the core structure, and\nis designed in a way such that the thought process for understanding the model is straight forward.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Julia as a programming language offers the flexibility required in points 1 and 2 through the concept of multiple dispatch. EnergyModelsBase hence focuses on only creating variables and constraints that are used, instead of creating all potential constraints and variables and constrain a large fraction of these variables to a value of 0. In that respect, EnergyModelsBase moves away from a parameter driven flexibility to a type driven flexibility. Point 3 is achieved through a one direction flow in function calls, that is that we limit the number of required files and function calls for the individual technology constraint creations, and meaningful names of the individual functions.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"The general concept of the model in EnergyModelsBase is based on a graph structure. The technologies within the modeled energy system are represented by Nodes. These Nodes correspond to, eg, a hydropower plant, a gas turbine, or the Haber-Bosch process. The individual nodes are then connected via Links/edges representing the transport of mass or energy between the technologies. EnergyModelsBase is represented using directed graphs, that is, flow is only possible in one direction through the links. The included Resources ùí´ are user defined. These resources have a unit associated with them, although this is not modelled explicitly in the current implementation. These units define the units/values that have to be applied when converting resources.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"EnergyModelsBase does not include all necessary constraints for individual technologies. Instead, it is seen as a lightweight core structure that can be extended by the user through the development of specific Node functions. Potential additional Nodes can focus on, e.g.:","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Piecewise linear efficiencies of technologies,\nInclusion of ramping constraints for technologies for which these are relevant,\nMinimmum capacity usage based on disjunctions, or\nImproved description of start-up and shut-down energy and time demands through disjunctions","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"to name some of potential new constraints.","category":"page"},{"location":"manual/philosophy/#man-phil-nodes","page":"Philosophy","title":"Description of technologies","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"The package utilizes different types that represent components in an energy system. These types can be summarized as:","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Source types have only an ouput to the system. Practical examples are solar PV, wind power, or available resources at a given price.\nNetworkNode types have both an input and an ouput. Practical examples are next to all technologies in an energy system, like e.g., a natural gas reforming plant with CCS (input: natural gas and electricity, output: hydrogen and CO‚ÇÇ) or an electrolyser (input: electricity, output: hydrogen).\nSink types have only an input from the system. They correspond in general to an energy/mass demand.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"In addition, there are two types that are subtypes of NetworkNode:","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Availability types are routing types. They guarantee the energy/mass balance of all connected inputs/outputs.\nStorage types are a special subtype as they include different variables.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"These types are connected using links that transport the energy/mass.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"New technologies can be introduced by defining a new composite type for the technology. You can find a description on how you can create a new node on the page Creating a new node.","category":"page"},{"location":"manual/philosophy/#man-phil-ext","page":"Philosophy","title":"Extensions to the model","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"There are in general four ways to extend the model:","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Introducing new technology descriptions as described in Creating a new node,\nCall of the create_model function with subsequent function calls for adding additional constraints,\nDispatching on the type EnergyModel, and\nUse the field data in the individual composite types.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Introducing new technology descriptions is the basis for extending the model. This approach allows for a different mathematical description compared to the included reference nodes. As an example, it is possible to introduce a new demand node that provides a profit for satisfying a demand combined with having no penalty if the demand is not satisfied.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Calling create_model within a new function allows the introduction of entirely new functions. This approach is chosen in EnergyModelsGeography although it still uses dispatch on individual technology nodes.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Dispatching on the type EnergyModel allows for adding methods to all functions that have modeltype included in the call. This is done in the package EnergyModelsInvestments where investments are added to the model through introducting the abstract type AbstractInvestmentModel. It can be problematic when one also wants to use investments. In addition, care has to be taken with respect to method amibiguity when dispatching on the type EnergyModel.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"The Array{Data} field provides us with flexibility with respect to providing additional data to the existing nodes. It is implemented in EnergyModelsBase for including emissions (both process and energy usage related). In that case, it allows for flexibility through either saying whether process (or energy related emissions) are present, or not. In addition, it allows for capturing the CO‚ÇÇ from either the individual CO‚ÇÇ sources (process and energy usage related), alternatively from both sources, or not at all. The individual data types are explained in the Section Additional data in the public library as well as on Data functions. In addition, it is already used in the package EnergyModelsInvestments through the introduction of the abstract type InvestmentData as subtype of Data. The introduction of InvestmentData allows providing additional parameters to individual technologies. However, the implementation in EnergyModelsInvestments does not utilize the extension through the Data functions. Instead, as outlined above, it dispatches on the type EnergyModel.","category":"page"},{"location":"manual/constraint-functions/#man-con","page":"Constraint functions","title":"Constraint functions","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"The package provides standard constraint functions that can be used for new developed nodes. These standard constraint functions are used exclusively in all create_node(m, n, ùíØ, ùí´, modeltype) functions. They allow for both removing repititions of code as well as dispatching only on certain aspects. The majority of the constraint functions are created for the abstract type of the Node dispatching, that is, the supertypes described in Description of Technologies. If a constraint function is not using the abstract type for dispatching, a warning is shown in this manual.","category":"page"},{"location":"manual/constraint-functions/#man-con-cap","page":"Constraint functions","title":"Capacity constraints","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Capacity constraints are constraints that limit both the capacity usage and installed capacity. The core function is given by","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_capacity(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"correponding to the constraint on the usage of the capacity of a technology node n. It is implemented for Node, Storage, and Sink types. The general implementation is limiting the capacity usage. That is, limiting the variable textttcap_usen t to the maximum installed capacity textttcap_instn t (and correspondingly for both rate and level variables for storage). Sink nodes behave differently as we allow for both surplus (textttsink_surplusn t) and deficits (textttsink_deficitn t), as explained in Sink variables.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Within this function, the function","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_capacity_installed(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"is called to limit the variable textttcap_inst (or textttstor_charge__inst, textttstor_level_inst and textttstor_discharge__inst for Storage nodes) of a technology node n. This functions is also used to subsequently dispatch on model type for the introduction of investments.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"warning: Warning\nAs the function constraints_capacity_installed is used for including investments for nodes, it is important that it is also called when creating a new node. It is not possible to only add a function forconstraints_capacity_installed(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)without adding a function forconstraints_capacity_installed(m, n::Node, ùíØ::TimeStructure, modeltype::EMI.AbstractInvestmentModel)as this can lead to a method ambiguity error.","category":"page"},{"location":"manual/constraint-functions/#man-con-flow","page":"Constraint functions","title":"Flow constraints","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Flow constraints handle how the flow variables of a Node are connected to the internal variables. In EnergyModelsBase, we only consider capacity variables as internal variables. This can however be extended through the development of new Nodes, if desired.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_flow_in(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the constraints calculating the required inflow to a node n for a given capacity usage. It is implemented for Node (using textttcap_usen t) and Storage (using textttstor_rate_usen t) types.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_flow_out(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the constraints calculating the outflow of a node n for a given capacity usage. It is implemented for Node types using textttcap_usen t but not used for the Storage subtypes introduced in the model. The outflow of a Storage node is instead specified through the storage level balance.","category":"page"},{"location":"manual/constraint-functions/#man-con-stor_level","page":"Constraint functions","title":"Storage level constraints","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Storage level constraints are required to provide flexibility on how the level of a Storage node should be calculated depending on the chosen StorageBehavior.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_level(m, n::Storage, ùíØ, ùí´, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the main constraint for calculating the level balance of a Storage node. Within this constraint, two different functions are called:","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_level_aux(m, n::Storage, ùíØ, ùí´, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"and","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_level_iterate(m, n::Storage, prev_pers, cyclic_pers, t_inv, ts, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"The first function, constraints_level_aux, is used to calculate additional properties of a Storage node. These properties are independent of the chosen TimeStructure, but dependent on the stored Resource type and the storage type. General properties are the calculation of the change in storage level in an operational period, as described in Capacity variables as well as bounds on variables. It is implemented for a generic Storage node as well for a RefStorage{AccumulatingEmissions} node. Using the AccumulatingEmissions requires that the stored resource is a ResourceEmit and limits the variable textttstor_level_Deltatexttt_opn t p geq 0 as well as introduces emission variables.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"The second function, constraints_level_iterate, iterates through the time structure and eventually declares the level balance of the Storage node within a strategic period. It automatically deduces the type of the time structure, i.e., whether representative periods and/or operational scenarios are included, and subsequently calculates the corresponding previous period used in the level balance through calling the function previous_level.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"RepresentativePeriods are handled through scaling of the change in the level in a representative period. This requires that the RepresentativePeriods are sequential.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"The total function call structure is given by:","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_level(m, n::Storage, ùíØ, ùí´, modeltype::EnergyModel)\n‚îú‚îÄ constraints_level_aux(m, n, ùíØ, ùí´, modeltype::EnergyModel)\n‚îî‚îÄ constraints_level_iterate(m, n, prev_pers, cyclic_pers, t_inv, ts::RepresentativePeriods, modeltype::EnergyModel)\n   ‚îú‚îÄ constraints_level_rp(m, n, per, modeltype::EnergyModel)\n   ‚îî‚îÄ constraints_level_iterate(m, n, prev_pers, cyclic_pers, t_inv, ts::OperationalScenarios, modeltype::EnergyModel)\n      ‚îú‚îÄ constraints_level_scp(m, n, per, modeltype::EnergyModel)\n      ‚îî‚îÄ constraints_level_iterate(m, n, prev_pers, cyclic_pers, t_inv, ts::SimpleTimes, modeltype::EnergyModel)\n         ‚îú‚îÄ constraints_level_bounds(m, n, t, cyclic_pers, modeltype::EnergyModel)\n         ‚îî‚îÄ previous_level(m, n, prev_pers, cyclic_pers, modeltype::EnergyModel)\n            ‚îî‚îÄ previous_level_sp(m, n, cyclic_pers, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Not all functions are called, as the framework automatically deduces the chosen time structure. Hence, if the time structure is given as TwoLevel{SimpleTimes}, all functions related to representative epriods and scenario periods are omitted.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"tip: Introducing new storage behaviours\nIf you want to introduce a new storage behaviour, it is best to dispatch on the following functions. It is not necessary to dispatch on all of the mentioned functions for all storage behaviours.constraints_level_rp(m, n, per, modeltype) for inclusion of constraints on the variable textttstor_level_Œî_rpn t_rp,\nconstraints_level_scp(m, n, per, modeltype) for inclusion of constraints related to operational scenarios,\nprevious_level(m, n, prev_pers, cyclic_pers, modeltype) for changing the behaviour of how previous storage levels should be calculated, and\nprevious_level_sp(m, n, cyclic_pers, modeltype) for changing the behaviour of the first operational period (in the first representative period) within a strategic period.The exact implementation is not straight forward and care has to be taken if you want to dispatch on these functions to avoid method ambiguities. We plan on extending on the documentation on how you can best introduce new storage behaviours in a latter stage with an example.","category":"page"},{"location":"manual/constraint-functions/#man-con-opex","page":"Constraint functions","title":"Operational expenditure constraints","text":"","category":"section"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Operational expenditure (OPEX) constraints calculate the contribution of operating a technology. The constraints are declared for both the fixed and variable OPEX.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_opex_fixed(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the constraints calculating the fixed operational costs of a technology node n. It is implemented for Node, Storage, and Sink types. The fixed OPEX is in general dependent on the installed capacity.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"EnergyModelsBase provides a default approach for calculating the variable OPEX of Storage nodes to allow for variations in the individually chosen storage parameters. Depending on the chosen storage parameters, the fixed OPEX can include the capacities for the charge (through the variable textttstor_charge_instn t), storage level (through the variable textttstor_level_instn t), and discharge (through the variable textttstor_discharge_instn t) capacities. Note that the fixed OPEX can only be included if a storage parameter including a capacity is chosen.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"Sink nodes use the variable textttcap_inst for providing a demand. They do not have a capacity in their basic implementation. Hence, no fixed OPEX is calculated.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"constraints_opex_var(m, n::Node, ùíØ::TimeStructure, modeltype::EnergyModel)","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"corresponds to the constraints calculating the variable operational costs of a technology node n. It is implemented for Node, Storage, RefStorage{T<:ResourceEmit}, and Sink types. The variable OPEX is in general dependent on the capacity usage.","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"As it is the case for the constraints for the fixed OPEX,  EnergyModelsBase provides a default approach for calculating the variable OPEX of Storage nodes to allow for variations in the individually chosen storage parameters. Depending on the chosen storage parameters, the fixed OPEX can include values for charging (through the variable textttstor_charge_usen t), the storage level (through the variable textttstor_leveln t), and discharging (through the variable textttstor_discharge_usen t).","category":"page"},{"location":"manual/constraint-functions/","page":"Constraint functions","title":"Constraint functions","text":"The variable OPEX calculations of Sink nodes include both the potential of a penalty for the surplus and deficit as described in Sink variables.","category":"page"},{"location":"library/public/resources/#lib-pub-res","page":"Resources","title":"Resources","text":"","category":"section"},{"location":"library/public/resources/","page":"Resources","title":"Resources","text":"Resources correspond to the mass/energy that is converted or transported within an energy system. Resources are discrete, that is they do not have as default additional variables, e.g. pressure or temperature, associated with them. Instead, they are implemented through flows and levels, as explained in Optimization variables.","category":"page"},{"location":"library/public/resources/#Index","page":"Resources","title":"Index","text":"","category":"section"},{"location":"library/public/resources/","page":"Resources","title":"Resources","text":"Pages = [\"resources.md\"]","category":"page"},{"location":"library/public/resources/#lib-pub-res-types","page":"Resources","title":"Resource types","text":"","category":"section"},{"location":"library/public/resources/","page":"Resources","title":"Resources","text":"The following resources are implemented in EnergyModelsBase. EnergyModelsBase differentiates between ResourceCarrier and ResourceEmit resources. The key difference between both is that ResourceEmit resources can have emissions, e.g., CO‚ÇÇ or methane. Emissions are accounted for and can have either a cap and/or a price associated with them.","category":"page"},{"location":"library/public/resources/","page":"Resources","title":"Resources","text":"One important field for a resource is the CO‚ÇÇ intensity (co2_int). CO‚ÇÇ is handled differently than other emissions as the emissions are fundamental properties of a fuel based on the carbon content.","category":"page"},{"location":"library/public/resources/#EnergyModelsBase.Resource","page":"Resources","title":"EnergyModelsBase.Resource","text":"General resource supertype to be used for the declaration of subtypes.\n\n\n\n\n\n","category":"type"},{"location":"library/public/resources/#EnergyModelsBase.ResourceCarrier","page":"Resources","title":"EnergyModelsBase.ResourceCarrier","text":"ResourceCarrier{T<:Real} <: Resource\n\nResources that can be transported and converted. These resources cannot be included as resources that are emitted, e.g, in the variable emissions_strategic.\n\nFields\n\nid is the name/identifyer of the resource.\nco2_int::T is the CO‚ÇÇ intensity, e.g., t/MWh.\n\n\n\n\n\n","category":"type"},{"location":"library/public/resources/#EnergyModelsBase.ResourceEmit","page":"Resources","title":"EnergyModelsBase.ResourceEmit","text":"ResourceEmit{T<:Real} <: Resource\n\nResources that can be emitted (e.g., CO‚ÇÇ, CH‚ÇÑ, NO‚Çì).\n\nThese resources can be included as resources that are emitted, e.g, in the variable emissions_strategic.\n\nFields\n\nid is the name/identifyer of the resource.\nco2_int::T is the CO‚ÇÇ intensity, e.g., t/MWh.\n\n\n\n\n\n","category":"type"},{"location":"library/public/resources/#lib-pub-res-fun_field","page":"Resources","title":"Functions for accessing fields of Resource types","text":"","category":"section"},{"location":"library/public/resources/","page":"Resources","title":"Resources","text":"The following functions are declared for accessing fields from a Resource type. If you want to introduce new Resource types, it is important that this function are either functional for your new types or you have to declare a corresponding function.","category":"page"},{"location":"library/public/resources/#EnergyModelsBase.co2_int","page":"Resources","title":"EnergyModelsBase.co2_int","text":"co2_int(p::Resource)\n\nReturns the CO‚ÇÇ intensity of resource p\n\n\n\n\n\n","category":"function"},{"location":"library/public/links/#lib-pub-links","page":"Links","title":"Links","text":"","category":"section"},{"location":"library/public/links/","page":"Links","title":"Links","text":"Links are connecting the individual Nodes for the exchange of energy/mass. Links are directional, that is transport of mass/energy is only allowed in a single direction.","category":"page"},{"location":"library/public/links/#Index","page":"Links","title":"Index","text":"","category":"section"},{"location":"library/public/links/","page":"Links","title":"Links","text":"Pages = [\"links.md\"]","category":"page"},{"location":"library/public/links/#lib-pub-links-types","page":"Links","title":"Link types","text":"","category":"section"},{"location":"library/public/links/","page":"Links","title":"Links","text":"The following types for links are implemented in EnergyModelsBase. The thought process is to dispatch on the EMB.Formulation of a link as additional option. This is in the current stage not implemented.","category":"page"},{"location":"library/public/links/#EnergyModelsBase.Link","page":"Links","title":"EnergyModelsBase.Link","text":"Declaration of the general type for links connecting nodes.\n\n\n\n\n\n","category":"type"},{"location":"library/public/links/#EnergyModelsBase.Direct","page":"Links","title":"EnergyModelsBase.Direct","text":"Direct <: Link\n\nA direct link between two nodes.\n\nFields\n\nid is the name/identifier of the link.\nfrom::Node is the node from which there is flow into the link.\nto::Node is the node to which there is flow out of the link.\nformulation::Formulation is the used formulation of links. If not specified, a Linear link is assumed.\n\n\n\n\n\n","category":"type"},{"location":"library/public/links/#EnergyModelsBase.Linear","page":"Links","title":"EnergyModelsBase.Linear","text":"Linear Formulation, that is input equals output.\n\n\n\n\n\n","category":"type"},{"location":"library/public/links/#lib-pub-links-fun_field","page":"Links","title":"Functions for accessing fields of Link types","text":"","category":"section"},{"location":"library/public/links/","page":"Links","title":"Links","text":"The following functions are declared for accessing fields from a Link type.","category":"page"},{"location":"library/public/links/","page":"Links","title":"Links","text":"warning: New link types\nIf you want to introduce new Link types, it is important that the function formulation is either functional for your new types or you have to declare a corresponding function. The first approach can be achieved through using the same name for the respective fields.","category":"page"},{"location":"library/public/links/#EnergyModelsBase.inputs-Tuple{Link}","page":"Links","title":"EnergyModelsBase.inputs","text":"inputs(n::Link)\n\nReturns the input resources of a link l.\n\nThe default approach is to use the function link_res(l::Link).\n\n\n\n\n\n","category":"method"},{"location":"library/public/links/#EnergyModelsBase.outputs-Tuple{Link}","page":"Links","title":"EnergyModelsBase.outputs","text":"outputs(n::Link)\n\nReturns the output resources of a link l.\n\nThe default approach is to use the function link_res(l::Link).\n\n\n\n\n\n","category":"method"},{"location":"library/public/links/#EnergyModelsBase.formulation","page":"Links","title":"EnergyModelsBase.formulation","text":"formulation(l::Link)\n\nReturn the formulation of a Link l.\n\n\n\n\n\n","category":"function"},{"location":"library/public/links/#EnergyModelsBase.link_data","page":"Links","title":"EnergyModelsBase.link_data","text":"link_data(l::Link)\n\nReturns the Data array of link l.\n\nThe default options returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"library/public/links/#lib-pub-links-fun_identify","page":"Links","title":"Functions for identifying Links","text":"","category":"section"},{"location":"library/public/links/","page":"Links","title":"Links","text":"The following functions are declared for filtering on Link types.","category":"page"},{"location":"library/public/links/#EnergyModelsBase.has_capacity-Tuple{Link}","page":"Links","title":"EnergyModelsBase.has_capacity","text":"has_capacity(l::Link)\n\nChecks whether link l has a capacity.\n\nBy default, links do not have a capacity. You must dispatch on this function if you want to introduce links with capacities.\n\n\n\n\n\n","category":"method"},{"location":"library/public/links/#EnergyModelsBase.has_emissions-Tuple{Link}","page":"Links","title":"EnergyModelsBase.has_emissions","text":"has_emissions(l::Link)\n\nChecks whether link l has emissions.\n\nBy default, links do not have emissions. You must dispatch on this function if you want to introduce links with associated emissions, e.g., through leakage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/links/#EnergyModelsBase.has_opex-Tuple{Link}","page":"Links","title":"EnergyModelsBase.has_opex","text":"has_opex(l::Link)\n\nChecks whether link l has operational expenses.\n\nBy default, links do not have operational expenses. You must dispatch on this function if you want to introduce links with operational expenses.\n\n\n\n\n\n","category":"method"},{"location":"library/public/links/#EnergyModelsBase.is_unidirectional-Tuple{Link}","page":"Links","title":"EnergyModelsBase.is_unidirectional","text":"is_unidirectional(l::Link)\n\nReturns logic whether the link l can be used bidirectional or only unidirectional.\n\nnote: Bidirectional flow in links\nIn the current stage, EnergyModelsBase does not include any links which can be used bidirectional, that is with flow reversal.If you plan to use bidirectional flow, you have to declare your own nodes and links which support this. You can then dispatch on this function for the incorporation.\n\n\n\n\n\n","category":"method"},{"location":"manual/NEWS/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"manual/NEWS/#Version-0.8.4-(2025-07-03)","page":"Release notes","title":"Version 0.8.4 (2025-07-03)","text":"","category":"section"},{"location":"manual/NEWS/#Bugfixes","page":"Release notes","title":"Bugfixes","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fixed a bug when a Link did not have the same input and output Resource.\nFixed a bug when using Storage{CyclicStrategic} with TwoLevel{OperationalScenarios}:\nThe storage balance was wrongly calculated.\nUpdated constraints on the storage level when using OperationalScenarios without RepresentativePeriods.\nAdded tests to avoid these problems in the future.","category":"page"},{"location":"manual/NEWS/#Version-0.8.3-(2024-11-29)","page":"Release notes","title":"Version 0.8.3 (2024-11-29)","text":"","category":"section"},{"location":"manual/NEWS/#Reference-checks-possible-to-be-called","page":"Release notes","title":"Reference checks possible to be called","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Created function check_node_default().\nThe function can be called from other check_node to include all default checks","category":"page"},{"location":"manual/NEWS/#Version-0.8.2-(2024-11-27)","page":"Release notes","title":"Version 0.8.2 (2024-11-27)","text":"","category":"section"},{"location":"manual/NEWS/#Restructuring-of-function-calls","page":"Release notes","title":"Restructuring of function calls","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Restructured function flow for variable and constraint.\nAllows extension with new types that we have not yet considered for the cost function and the emissions.","category":"page"},{"location":"manual/NEWS/#Incorporation-of-bidirectional-flow","page":"Release notes","title":"Incorporation of bidirectional flow","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Allow (in theory) for nodes and links with bidirectional flow through avoiding hard-coding a lower bound on flow variables.\nNo existing links and nodes allow for bidirectional flow.\nBidirectional flow requires new links and nodes with new methods for the function is_unidirectional.","category":"page"},{"location":"manual/NEWS/#Rework-of-links","page":"Release notes","title":"Rework of links","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Extended the functionality of links significantly.\nAllow for\ndiffering input and output resources of links as well as specifying these directly,\nemissions of links,\nOPEX of links (with both fixed and variable OPEX created at the same time),\ncapacity of links,\ninclusion of specific link variables, and\ninvestments in links if the links have a capacity.\nThe majority of changes are incorporated through filter functions and require the user to define new methods for the included functions (i.e., has_opex, has_emissions, and has_capacity)\nInclusion of variables follows principle of additional node variables.","category":"page"},{"location":"manual/NEWS/#Minor-updates","page":"Release notes","title":"Minor updates","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Updated som docstrings.\nUpdated some minor changes in the documentation.","category":"page"},{"location":"manual/NEWS/#Version-0.8.1-(2024-10-16)","page":"Release notes","title":"Version 0.8.1 (2024-10-16)","text":"","category":"section"},{"location":"manual/NEWS/#Bugfixes-2","page":"Release notes","title":"Bugfixes","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fixed a bug in which it was possible to have wrong profiles if it must be indexed over an operational scenario or representative period.","category":"page"},{"location":"manual/NEWS/#Adjustment-to-EnergyModelsInvestments-changes","page":"Release notes","title":"Adjustment to EnergyModelsInvestments changes","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Adjusted the investment data checks.\nProvided legacy constructors for the previous usage of SingleInvData.\nIntroduced the investment examples to the example sections.\nAdded investment options tests.","category":"page"},{"location":"manual/NEWS/#Rework-of-documentation","page":"Release notes","title":"Rework of documentation","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"The documentation received a significant rework. The rework consists of:\nProviding webpages for the individual nodal descriptions in which the fields are described more in detail as well as a description of the constraints of the individual nodes.\nRestructured both the public and internal libraries","category":"page"},{"location":"manual/NEWS/#Minor-updates-2","page":"Release notes","title":"Minor updates","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Included an option to deactive the checks entirely with printing a warning.\nIntroduced the variable textttstor_level_Œî_sp using SparseVariables to simplify the extension in other Storage nodes.\nReplaced the function EMB.multiple with the function scale_op_sp to avoid issues with respect to a function of the same name in TimeStruct.\nThis type is now exported, simplifying its application in other packages.\nEMB.multiple is still included through a deprecation notice. It is however advisable to switch to the new function.","category":"page"},{"location":"manual/NEWS/#Version-0.8.0-(2024-08-20)","page":"Release notes","title":"Version 0.8.0 (2024-08-20)","text":"","category":"section"},{"location":"manual/NEWS/#Introduced-EnergyModelsInvestments-as-extension","page":"Release notes","title":"Introduced EnergyModelsInvestments as extension","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"EnergyModelsInvestments was switched to be an independent package in PR #28.\nThis approach required EnergyModelsBase to include all functions and type declarations internally.\nAn extension was introduced to handle these problems.","category":"page"},{"location":"manual/NEWS/#Minor-updates-3","page":"Release notes","title":"Minor updates","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Updated minor issues in the documentation (docstrings, indices, and quick start).\nUse dev version of EMB for examples when running as part of tests, solving Issue #17.\nNaming of the total emission constraint to allow for updates in the coefficients in other packages.","category":"page"},{"location":"manual/NEWS/#Version-0.7.0-(2024-05-24)","page":"Release notes","title":"Version 0.7.0 (2024-05-24)","text":"","category":"section"},{"location":"manual/NEWS/#Introduction-of-AbstractStorageParameters-type-for-increasing-potential-for-Storage-variations","page":"Release notes","title":"Introduction of AbstractStorageParameters type for increasing potential for Storage variations","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Introduced a :discharge capacity for Storage nodes in addition to the existing capacities.\nAbstractStorageParameters type allows for Storage capacities (:charge, :level, and :discharge) to include a capacity, variable OPEX, and or fixed OPEX.\nThis increases the flexibility for Storage node utilization.","category":"page"},{"location":"manual/NEWS/#Introduction-of-StorageBehavior-type-for-reusability-of-level-balances","page":"Release notes","title":"Introduction of StorageBehavior type for reusability of level balances","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Introduction of CyclicRepresentative behavior with support for OperationalScenarios. In this StorageBehavior, the accumulation within a representative period is set to 0.\nChange in Storage{AccumulatingEmissions} to avoid requiring a capacity when only emissions are present.","category":"page"},{"location":"manual/NEWS/#Checks","page":"Release notes","title":"Checks","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Do not print a warning, when using OperationalProfile with a time structure containing RepresentativePeriods.","category":"page"},{"location":"manual/NEWS/#Version-0.6.8-(2024-04-18)","page":"Release notes","title":"Version 0.6.8 (2024-04-18)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Added potential for negative emissions. This change requires the user to always constrain the variable emissions_node, if it is defined by the user. By default, this is achieved in the developed packages through EmissionsData or the addition of additional bounds on the variable :emissions_node through the JuMP function set_lower_bound.\nProvided a contribution section in the documentation.\nMinor changes in the naming convention in the documentation.\nRemoved \\texttt{} from docstrings.","category":"page"},{"location":"manual/NEWS/#Version-0.6.7-(2024-03-21)","page":"Release notes","title":"Version 0.6.7 (2024-03-21)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Allow for deactivation of timeprofile checks while printing a warning in this case.\nFixed a bug for a too short StrategicProfile in the checks.\nAdded checks for the case dictionary.\nExtended checks for the modeltype.\nAdded functions that can be used to check whether a TimeProfile can be indexed over StrategicPeriods, RepresentativePeriods, or OperationalScenarios.","category":"page"},{"location":"manual/NEWS/#Version-0.6.6-(2024-03-04)","page":"Release notes","title":"Version 0.6.6 (2024-03-04)","text":"","category":"section"},{"location":"manual/NEWS/#Examples","page":"Release notes","title":"Examples","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fixed a bug when running the examples from a non-cloned version of EnergyModelsBase.\nThis is achieved through a separate Project.toml in the examples folder.","category":"page"},{"location":"manual/NEWS/#Checks-2","page":"Release notes","title":"Checks","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fixed the bug preventing the time profile checks to run.\nIncluded checks of the input data and for all nodes.\nIncluded tests for checks.","category":"page"},{"location":"manual/NEWS/#Minor-updates-4","page":"Release notes","title":"Minor updates","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Added functions inputs, outputs, and data_nodes for Availability and outputs for Source nodes.\nAllow availability to not require all resources in the the input and output field.\nMoved all files declaring structures to a separate folder for improved readability.\nReworked the structure of the test folder.","category":"page"},{"location":"manual/NEWS/#Version-0.6.5-(2024-01-31)","page":"Release notes","title":"Version 0.6.5 (2024-01-31)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Updated the restrictions on the fields of individual types to be consistent.","category":"page"},{"location":"manual/NEWS/#Version-0.6.4-(2024-01-18)","page":"Release notes","title":"Version 0.6.4 (2024-01-18)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Minor modification to the EmissionsData allowing now also time dependent process emissions.\nThis is achieved through switching to a parametric type.","category":"page"},{"location":"manual/NEWS/#Version-0.6.3-(2024-01-17)","page":"Release notes","title":"Version 0.6.3 (2024-01-17)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Changed name of constraints_level  to constraints_level_sp when the time input is given as a StrategicPeriod to improve understandability.\nAdd modeltype::EnergyModel as an argument to the methods constraints_level_sp (see above) and constraints_level_aux.","category":"page"},{"location":"manual/NEWS/#Version-0.6.2-(2024-01-17)","page":"Release notes","title":"Version 0.6.2 (2024-01-17)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"When variables are created with the method variables_nodes, it will lead to an ErrorException when the method tries to create a variable that has already been created. This is ok, and this error should be ignored. This change specifies exactly what error should be ignored, to avoid that other types of errors are also ignored.","category":"page"},{"location":"manual/NEWS/#Version-0.6.1-(2024-01-11)","page":"Release notes","title":"Version 0.6.1 (2024-01-11)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fix: add missing parenthesis in the objective function.","category":"page"},{"location":"manual/NEWS/#Version-0.6.0-(2023-12-14)","page":"Release notes","title":"Version 0.6.0 (2023-12-14)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Switched fields Input and Output of Availability nodes from Dict{Resource, Real} to Array{<:Resource}. The former is still available as a constructor, while a new constructor is introduced which requires the input only once.\nAll fields in composite types are now lower case.\nRenamed Network to NetworkNode. NetworkNode can be considered to be replaced in a later iterations as it is not really needed.\nAdded functions for extracting the fields of Nodes, Resources, and EnergyModels to allow for extensions.\nAdded export of functions that are frequently used in other packages.\nMoved the emissions to a Data type on which we can dispatch, depending on the chosen approach for capture and process emissions.\nRedesigned storage as parametric type to dispatch on the level balance. This includes as well the introduction of a new variable.\nIncluded potential for different durations of operational periods.\nIncluded representative periods. These do only affect a Storage node as these are the only time dependent nodes.\nAdded emission prices to OperationalModel.","category":"page"},{"location":"manual/NEWS/#Version-0.5.2-(2023-11-06)","page":"Release notes","title":"Version 0.5.2 (2023-11-06)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Introduced method create_model that can take a JuMP.Model as input to simplify potential use of other type of models\nFixed the documentation to avoid errors","category":"page"},{"location":"manual/NEWS/#Version-0.5.1-(2023-06-16)","page":"Release notes","title":"Version 0.5.1 (2023-06-16)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Updated the documentation based on the new format","category":"page"},{"location":"manual/NEWS/#Version-0.5.0-(2023-06-01)","page":"Release notes","title":"Version 0.5.0 (2023-06-01)","text":"","category":"section"},{"location":"manual/NEWS/#Switch-to-TimeStruct.jl","page":"Release notes","title":"Switch to TimeStruct.jl","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Switched the time structure representation to TimeStruct.jl\nTimeStruct.jl is implemented with only the basis features that were available in TimesStructures.jl. This implies that neither operational nor strategic uncertainty is included in the model","category":"page"},{"location":"manual/NEWS/#Version-0.4.0-(2023-05-30)","page":"Release notes","title":"Version 0.4.0 (2023-05-30)","text":"","category":"section"},{"location":"manual/NEWS/#Additional-input-data-changes","page":"Release notes","title":"Additional input data changes","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Changed the structure in which the extra field Data is included in the nodes\nIt is changed from Dict{String, Data} to Array{Data}","category":"page"},{"location":"manual/NEWS/#Version-0.3.3-(2023-04-26)","page":"Release notes","title":"Version 0.3.3 (2023-04-26)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Changed where storage variables are declared to avoid potential method ambiguity through new storage variables when using EnergyModelsInvestments","category":"page"},{"location":"manual/NEWS/#Version-0.3.2-(2023-02-07)","page":"Release notes","title":"Version 0.3.2 (2023-02-07)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Generalized the function names for identifying and sorting the individual introduced types.","category":"page"},{"location":"manual/NEWS/#Version-0.3.1-(2023-02-03)","page":"Release notes","title":"Version 0.3.1 (2023-02-03)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Take the examples out to the directory examples","category":"page"},{"location":"manual/NEWS/#Version-0.3.0-(2023-02-02)","page":"Release notes","title":"Version 0.3.0 (2023-02-02)","text":"","category":"section"},{"location":"manual/NEWS/#Fields-of-reference-types-and-new-types","page":"Release notes","title":"Fields of reference types and new types","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Removal of all process emissions and CO‚ÇÇ capture from reference types to avoid having to include them as well","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"in all subtypes defined later to keep the fallback option. This requires in the future to***remove*** CO‚ÇÇ as output when using CO‚ÇÇ capture as it was previously the case. The original types are retained so that they can still be used","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Introduction of a type RefStorageEmissions to account for a storage unit that can be used for storing ResourceEmit","category":"page"},{"location":"manual/NEWS/#Introduction-of-functions-for-constraints-generation","page":"Release notes","title":"Introduction of functions for constraints generation","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Substitution of variable and fixed OPEX calculations as well as capacity and flow constraints through functions which utilize dispatching on node types","category":"page"},{"location":"manual/NEWS/#Redefinition-of-introduction-of-global-data","page":"Release notes","title":"Redefinition of introduction of global data","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Removal of the type AbstractGlobalData and all subtypes and substitution through EnergyModel and the corresponding subtypes\nAddition of the field CO2_instance in the type OperationalModel\nAddition of ModelType to the function create_node to be able to use different ids for the CO‚ÇÇ resource","category":"page"},{"location":"manual/NEWS/#Additional-changes","page":"Release notes","title":"Additional changes","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Redefining CO2Int in fields of type Resource to CO2_int to be consistent with the other types\nMinor changes in constraint description that do not break previous code\nChanged the input to the function variables_node to simplify the generation of variables for a specific node type","category":"page"},{"location":"manual/NEWS/#Version-0.2.7-(2022-12-12)","page":"Release notes","title":"Version 0.2.7 (2022-12-12)","text":"","category":"section"},{"location":"manual/NEWS/#Internal-release","page":"Release notes","title":"Internal release","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Renamed packages to use common prefix\nUpdated README","category":"page"},{"location":"manual/NEWS/#Version-0.2.4-(2022-09-07)","page":"Release notes","title":"Version 0.2.4 (2022-09-07)","text":"","category":"section"},{"location":"manual/NEWS/#Feature-update-and-changes-in-export","page":"Release notes","title":"Feature update and changes in export","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Inclusion of time dependent profiles for surplus and deficit of sinks\nInclusion of parameter checks for surplus and deficit of sinks\nExport of all reference nodes for easier identification of the nodes\nChanges in the test structure with improved testing of variables\nChanges in doc strings for individual functions/types","category":"page"},{"location":"manual/NEWS/#Version-0.2.3-(2021-09-07)","page":"Release notes","title":"Version 0.2.3 (2021-09-07)","text":"","category":"section"},{"location":"manual/NEWS/#Changes-in-naming","page":"Release notes","title":"Changes in naming","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Major changes in both variable and parameter naming, check the commit message for an overview","category":"page"},{"location":"manual/NEWS/#Version-0.2.2-(2021-08-20)","page":"Release notes","title":"Version 0.2.2 (2021-08-20)","text":"","category":"section"},{"location":"manual/NEWS/#Feature-updates","page":"Release notes","title":"Feature updates","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Change of Availability to abstract type and introduction of GenAvailability as composite type to be able to use multiple dispatch on the availability nodes\nInclusion of the entry fixed OPEX to the node composite types\nInclusion of the entry data to the node composite types to provide input required for certain additional packages like investments\nNew function for checks of node data so that we have an a priori check of all model data","category":"page"},{"location":"manual/NEWS/#Changes-in-naming-2","page":"Release notes","title":"Changes in naming","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Introduce the optimization variables storlevel and stormax for storages, and use these instead of capusage and capmax for the constraints on Storage.\nUse the new variable cap_storage in Storage nodes for the installed storage capacity.","category":"page"},{"location":"manual/NEWS/#Version-0.2.1-(2021-04-22)","page":"Release notes","title":"Version 0.2.1 (2021-04-22)","text":"","category":"section"},{"location":"manual/NEWS/#Feature-updates-2","page":"Release notes","title":"Feature updates","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Reduction in variables through introduction of input/output (#2)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"dictionaries for all nodes that only include necessary components","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Improvement related to emissions to avoid wrong accounting when other emission carriers than CO‚ÇÇ are present (#2)\nLink resources generated automatically from input (#2)","category":"page"},{"location":"manual/NEWS/#Changes-in-naming-3","page":"Release notes","title":"Changes in naming","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Removal of prefix \"create\" before \"constraints\" and \"variables\"\n\"createmodule\" switched to \"createnode\"","category":"page"},{"location":"manual/NEWS/#Version-0.2.0-(2021-04-19)","page":"Release notes","title":"Version 0.2.0 (2021-04-19)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Inclusion of abstract type and structures for both resources and (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"differentiation in nodes","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Development of new functions for the given data structures to obtain (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"subsets of the system","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Development of the core structure in model.jl for allowing variations (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"in the different nodes","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Implementation of fallback solutions for source, network, storage,","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"and sink (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Inclusion of availability node for easier distribution of energy in a","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"single geographical node and transfer from one geographical node to the next (#1)","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Providing a test case that can be used for playing around with the simple","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"system (#1)","category":"page"},{"location":"manual/NEWS/#Version-0.1.0-(2021-03-19)","page":"Release notes","title":"Version 0.1.0 (2021-03-19)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Initial (skeleton) version","category":"page"},{"location":"#EnergyModelsBase","page":"Home","title":"EnergyModelsBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EnergyModelsBase is an operational, multi nodal energy system model, written in Julia. The model is based on the JuMP optimization framework. It is a multi carrier energy model, where the definition of the carriers are fully up to the user of the model. One of the primary design goals was to develop a model that can easily be extended with new functionalities without the need to understand and remember every variable and constraint in the model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For running a basic energy system model, only the base technology package EnergyModelsBase and the time structure package TimeStruct are needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main package provides simple descriptions for energy sources, sinks, conversion, and storage units. It corresponds to an operational model without geographic features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other packages can the optionally be added if specific functionality or technology nodes are needed. The most important packages are","category":"page"},{"location":"","page":"Home","title":"Home","text":"EnergyModelsGeography:  this package makes it possible to easily extend your energy model with different  geographic areas, where transmission can be set to allow for the transport of  resources between the different areas.\nEnergyModelsInvestments:  this package implements functionality for investments, where the length of the  investment periods are fully flexible and is decided by setting the time  structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Open Packages implementing technology specific nodes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"EnergyModelsRenewableProducers: implements NonDisRES for intermittent (Non-Dispatchable) Renewable Energy Sources and HydroStor modeling a regulated hydro storage plant as well as PumpedHydroStor modelling a pumped hydro storage plant.","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"manual/quick-start.md\",\n    \"manual/philosophy.md\",\n    \"manual/optimization-variables.md\",\n    \"manual/constraint-functions.md\",\n    \"manual/data-functions.md\",\n    \"manual/simple-example.md\",\n    \"manual/investments.md\",\n    \"manual/NEWS.md\",\n]\nDepth = 1","category":"page"},{"location":"#Description-of-the-nodes","page":"Home","title":"Description of the nodes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"nodes/source.md\",\n    \"nodes/networknode.md\",\n    \"nodes/storage.md\",\n    \"nodes/sink.md\",\n    \"nodes/availability.md\",\n]\nDepth = 1","category":"page"},{"location":"#How-to-guides","page":"Home","title":"How to guides","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"how-to/create-new-node.md\",\n    \"how-to/utilize-timestruct.md\",\n    \"how-to/update-models.md\",\n    \"how-to/contribute.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"#Public-library","page":"Home","title":"Public library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"library/public/resources.md\",\n    \"library/public/model_data.md\",\n    \"library/public/nodes.md\",\n    \"library/public/links.md\",\n    \"library/public/functions.md\",\n    \"library/public/misc.md\",\n    \"library/public/emi_extension.md\",\n]\nDepth = 1","category":"page"},{"location":"#Internal-library","page":"Home","title":"Internal library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"library/internals/types.md\",\n    \"library/internals/functions.md\",\n    \"library/internals/reference_EMIExt.md\",\n]\nDepth = 1","category":"page"}]
}
